#!/usr/bin/python
#
# Copyright (C) 2011 Karsten Wiesner
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# pycbc should follow <http://www.python.org/dev/peps/pep-0008/>
#
# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Application of gravitational wave search for inspiral mergers based on the 
pycbc (py-thon c-ompact b-inary c-oalecence) package 
"""

import sys
import random

from pycbc.straindata.cpu import StrainDataCpu as StrainData 
from pycbc.templatebank.cpu import TemplateBankCpu as TemplateBank 
from pycbc.matchedfilter.cpu import MatchedFilterCpu as MatchedFilter
from pycbc.cpu import CpuDeviceContext as ProccessingTargetContext

import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(name)s %(asctime)s %(levelname)s %(message)s',
                    filename='pycbc_run.log',
                    filemode='w')

logger= logging.getLogger('pycbc.main_script')


start_message = 'Starting pycbc single detector minimal pipeline ...'
logger.debug(start_message)
print start_message

# setup straindata
search_time = 128 # typ design spec: 2048
sample_freq = 256 # typ design spec: 4096
length =      search_time * sample_freq
segments = 15
gps_start_time= 871147532
gps_end_time= gps_start_time + search_time
interferometer = "H1"

with ProccessingTargetContext(1) as context:
 
    strain_data= StrainData(context, gps_start_time, gps_end_time, 
                        segments, sample_freq, 
                        interferometer)
                        
    logger.debug("instanciated StrainData w/ segment length: {0}".format(strain_data.segments_length))

    # initialize straindata w/ white noise
    for i in range(length):
        tmp= random.uniform(-1,1)
        strain_data.time_series[i] = tmp
        
    # print repr(strain_data.time_series)

    # convert straindata to single precision
    strain_data.convert_to_single_preci()

    # segmenting straindata and transform into frequency domain
    strain_data.perform_fft_segments()

    # transfer straindata to appropriate memory space on target device
    strain_data.render()

    # create 5 templates (testing the iterator of TemplateBank)
    bank = TemplateBank( context, 5, strain_data.segments_length, strain_data.segments_delta_x)
    logger.debug("instanciated TemplateBank w/ waveform length: {0}".format(bank.waveform_length))

    # create matched filter
    matched_filter = MatchedFilter(context, strain_data.segments_length, strain_data.segments_delta_x)
    logger.debug("instanciated MatchedFilter w/ length: {0}".format(matched_filter.length))

    # instanciate result vectors
    #### snr = SnrResultTimeSeries(strain_data.segments_length, strain_data.segments_delta_x)
    #### logger.debug("instanciated SnrResultTimeSeries as {0}".format(repr(snr)))

    # filter the data against the template bank
    for template in bank:        
        htilde = bank.perform_generate_waveform(template)
        #print("generating htilde {0}".format(repr(htilde)))
        for stilde in strain_data:
            snr = matched_filter.perform_generate_snr(stilde, htilde)
            
    ############################################################################
    # prepare to leave the processing context (objects that contain device 
    # memory are not deleted automatically here!)
    del(strain_data)
    del(bank)
    del(matched_filter)
    
    # leaving the ProccessingTargetContext now (destroying the device context)
    ############################################################################
    
end_message = '... end of pycbc single detector minimal pipeline.'
logger.debug(end_message)
print end_message
       




        
