#! /usr/bin/env python

import argparse, numpy, h5py
from time import time
import types
import pycbc
from pycbc import version, waveform
from pycbc.types import MultiDetOptionAction, zeros, load_frequencyseries
from pycbc.filter import matched_filter_core
import pycbc.waveform.bank
from pycbc import DYN_RANGE_FAC
from pycbc.conversions import mchirp_from_mass1_mass2
from pycbc.conversions import mtotal_from_mchirp_eta, mass1_from_mtotal_eta
from pycbc.conversions import mass2_from_mtotal_eta
from scipy.optimize import differential_evolution
from pycbc.waveform.waveform import props
from pycbc.io import live
from pycbc.detector import Detector

# Define the function for computing network snr
def compute_network_snr_core(v, *argv):
    data = argv[0]
    coinc_times = argv[1]
    ifos = argv[2]
    flen = argv[3]
    approximant = argv[4]
    flow = argv[5]
    f_end = argv[6]
    delta_f = argv[7]
    sample_rate = argv[8]
    distance = 1.0 / DYN_RANGE_FAC
    mtotal = mtotal_from_mchirp_eta(v[0], v[1])
    mass1 = mass1_from_mtotal_eta(mtotal, v[1])
    mass2 = mass2_from_mtotal_eta(mtotal, v[1])

    htilde = waveform.get_waveform_filter\
        (zeros(flen, dtype=numpy.complex64),
         approximant=approximant,
         mass1=mass1, mass2=mass2, spin1z=v[2], spin2z=v[3],
         f_lower=flow, f_final=f_end, delta_f=delta_f,
         delta_t=1.0/sample_rate, distance=distance)
    htilde.sigmasq = types.MethodType(pycbc.waveform.bank.sigma_cached,
                                      htilde)
    htilde.approximant = approximant
    htilde.min_f_lower = flow
    htilde.end_frequency = f_end
    htilde.f_lower = flow
    network_snrsq = 0
    snr_series_dict = {}
    for ifo in ifos:
        sigmasq = htilde.sigmasq(data[ifo].psd)
        snr, _, norm = matched_filter_core(htilde, data[ifo],
                                           h_norm=sigmasq)
        duration = 0.095
        half_dur_samples = int(snr.sample_rate * duration / 2)
        onsource_idx = float(coinc_times[ifo] - snr.start_time) * snr.sample_rate
        onsource_idx = int(round(onsource_idx))
        onsource_slice = slice(onsource_idx - half_dur_samples,
                               onsource_idx + half_dur_samples + 1)
        snr_series = snr[onsource_slice] * norm
        snr_series_dict[ifo] = snr * norm
        snr_series_dict['sigmasq_' + ifo] = sigmasq
        network_snrsq += max(abs(snr_series._data))**2
    return (network_snrsq**0.5), snr_series_dict

def compute_network_snr(v, *argv):
    nsnr, _ = compute_network_snr_core(v, *argv)
    return -nsnr


parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version',
                    version=version.git_verbose_msg)
parser.add_argument('--verbose', action='store_true')
parser.add_argument('--params-file',
                    help='Location of the attributes file created by PyCBC '
                         'Live')
parser.add_argument("--data-files", type=str, nargs='+',
                    action=MultiDetOptionAction,
                    metavar='IFO:DATA_FILE',
                    help="Locations of the overwhitened data files produced "
                         "by PyCBC Live.")
parser.add_argument("--psd-files", type=str, nargs='+',
                    action=MultiDetOptionAction,
                    metavar='IFO:PSD_FILE',
                    help="Locations of the PSD files produced "
                         "by PyCBC Live.")
parser.add_argument("--approximant", required=True,
                    help="Waveform approximant string.")
parser.add_argument("--snr-threshold", default=5.0,
                    help="If the SNR in ifo X is below this threshold do not "
                         "consider it part of the coincidence.")

args = parser.parse_args()
pycbc.init_logging(args.verbose)

logging.info('Starting optimize SNR')

data = {}
for ifo in args.data_files.keys():
    data[ifo] = load_frequencyseries(args.data_files[ifo])
    data[ifo].psd = load_frequencyseries(args.psd_files[ifo])

fp = h5py.File(args.params_file, 'r')
ifos = data.keys()

coinc_times = {}
for ifo in ifos:
    try:
        coinc_times[ifo] = fp['coinc_times'][ifo][()]
    except KeyError:
        pass

coinc_ifos = list(coinc_times.keys())
    
flen = fp['flen'][()]
approximant = args.approximant
flow = fp['flow'][()]
f_end = fp['f_end'][()]
delta_f = fp['delta_f'][()]
sample_rate = fp['sample_rate'][()]

extra_args = [data, coinc_times, coinc_ifos, flen,
              approximant, flow, f_end, delta_f, sample_rate]

mass1 = fp['mass1'][()]
mass2 = fp['mass2'][()]
spin1z = fp['spin1z'][()]
spin2z = fp['spin2z'][()]
mchirp = pycbc.conversions.mchirp_from_mass1_mass2(mass1, mass2)
minchirp = mchirp * (1 - mchirp / 50.0)
maxchirp = mchirp * (1 + mchirp / 50.0)
minchirp = 1 if minchirp < 1 else minchirp
maxchirp = 80 if maxchirp > 80 else maxchirp

bounds = [(minchirp, maxchirp), (0.01, 0.2499), (-0.9, 0.9), (-0.9, 0.9)]

logging.info('Starting optimization')

results = differential_evolution(compute_network_snr, bounds,
                                 maxiter=100, workers=-1,
                                 popsize=200, mutation=(0.5,1),
                                 recombination=0.7,
                                 args=extra_args)

logging.info('Optimization complete')

mtotal = mtotal_from_mchirp_eta(results.x[0], results.x[1])
mass1 = mass1_from_mtotal_eta(mtotal, results.x[1])
mass2 = mass2_from_mtotal_eta(mtotal, results.x[1])
spin1z = results.x[2]
spin2z = results.x[3]

fup_ifos = set(ifos) - set(coinc_ifos)

for ifo in fup_ifos:
    coinc_times[ifo] = coinc_times[coinc_ifos[0]]

extra_args[2] = ifos

_, snr_series_dict = compute_network_snr_core(results.x, *extra_args)

# Prepare for GraceDB upload
coinc_results = {}
followup_data = {}

loudest_ifo = None
loudest_snr_allifos = 0
loudest_snr_time_allifos = None
loudest_snrs = {}
loudest_snr_times = {}
loudest_snr_idxs = {}

for ifo in ifos:
    duration = 0.095
    half_dur_samples = int(sample_rate * duration / 2)
    onsource_idx = float(coinc_times[ifo] - snr_series_dict[ifo].start_time) \
        * snr_series_dict[ifo].sample_rate
    onsource_idx = int(round(onsource_idx))
    onsource_slice = slice(onsource_idx - half_dur_samples,
                           onsource_idx + half_dur_samples + 1)
    max_snr_idx = numpy.argmax(abs(snr_series_dict[ifo][onsource_slice]))
    max_snr_idx = max_snr_idx + onsource_idx - half_dur_samples
    max_snr = snr_series_dict[ifo][max_snr_idx]
    max_snr_time = snr_series_dict[ifo].start_time \
        + max_snr_idx*(1./sample_rate)
    loudest_snr_idxs[ifo] = max_snr_idx
    loudest_snr_times[ifo] = float(max_snr_time)
    loudest_snrs[ifo] = max_snr
    if abs(max_snr) > loudest_snr_allifos:
        loudest_snr_allifos = abs(max_snr)
        loudest_ifo = ifo
        loudest_snr_time_allifos = loudest_snr_times[ifo]

    new_snr_slice = slice(max_snr_idx - int(sample_rate/10),
                          max_snr_idx + int(sample_rate/10)+1)
    snr_series_dict[ifo] = snr_series_dict[ifo][new_snr_slice]

netsnr = 0
for idx, ifo in enumerate(ifos):
    coinc_results['foreground/'+ifo+'/mass1'] = mass1
    coinc_results['foreground/'+ifo+'/mass2'] = mass2
    coinc_results['foreground/'+ifo+'/spin1z'] = spin1z
    coinc_results['foreground/'+ifo+'/spin2z'] = spin2z
    coinc_results['foreground/'+ifo+'/f_lower'] = flow
    coinc_results['foreground/'+ifo+'/window'] = 0.1
    coinc_results['foreground/'+ifo+'/sample_rate'] = int(sample_rate)
    coinc_results['foreground/'+ifo+'/template_id'] = 0
    followup_data[ifo] = {}
    followup_data[ifo]['psd'] = data[ifo].psd
    followup_data[ifo]['snr_series'] = snr_series_dict[ifo]

    # Should this trigger be considered part of the coincidence?
    # Check snr_peak
    snr_peak = abs(loudest_snrs[ifo])
    # And check light travel time
    lttbd = Detector(ifo).light_travel_time_to_detector(Detector(loudest_ifo))
    # Add small buffer
    lttbd += 0.005

    if snr_peak < args.snr_threshold or \
            abs(loudest_snr_times[ifo] - loudest_snr_time_allifos) > lttbd:
        coinc_results['foreground/'+ifo+'/end_time'] = loudest_snr_time_allifos
        continue

    coinc_results['foreground/'+ifo+'/end_time'] = loudest_snr_times[ifo]
    coinc_results['foreground/'+ifo+'/snr_series'] = snr_series_dict[ifo]
    coinc_results['foreground/'+ifo+'/psd_series'] = data[ifo].psd
    coinc_results['foreground/'+ifo+'/delta_f'] = delta_f
    coinc_results['foreground/'+ifo+'/event_id'] = 'sngl_inspiral:event_id:'+str(idx)
    coinc_results['foreground/'+ifo+'/snr'] = abs(loudest_snrs[ifo])
    netsnr += abs(loudest_snrs[ifo])**2
    coinc_results['foreground/'+ifo+'/sigmasq'] \
        = snr_series_dict['sigmasq_' + ifo]
    coinc_results['foreground/'+ifo+'/coa_phase'] \
        = numpy.angle(loudest_snrs[ifo])
    coinc_results['foreground/'+ifo+'/chisq'] = 1.
    coinc_results['foreground/'+ifo+'/chisq_dof'] = 1
coinc_results['foreground/stat'] = numpy.sqrt(netsnr)
coinc_results['foreground/ifar'] = fp['ifar'][()]

kwargs = {'psds': {ifo: followup_data[ifo]['psd'] for ifo in ifos},
          'low_frequency_cutoff': flow,
          'followup_data': followup_data}
comments = ['Automatic PyCBC followup to find largest SNR parameters']

doc = live.SingleCoincForGraceDB(coinc_ifos, coinc_results,
                                 upload_snr_series=True,
                                 followup_ifos=fup_ifos, **kwargs)
gracedb_server = 'https://gracedb-playground.ligo.org/api/'
test_event = True
gid = doc.upload(str(loudest_snr_times[ifos[0]])+'.xml',
                 gracedb_server=gracedb_server,
                 testing=test_event,
                 extra_strings=comments)

logging.info('Event uploaded as {}.'.format(gid))
