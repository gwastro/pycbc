#!/usr/bin/python
#
# Copyright (C) 2011 Karsten Wiesner
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# pycbc should follow <http://www.python.org/dev/peps/pep-0008/>
#
# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Application of gravitational wave search for inspiral mergers based on the 
pycbc (py-thon c-ompact b-inary c-oalecence) package 

Single Detector CBC Pipeline

Current Status: "Application Prototype" 

"""

import sys

# preliminary hard coded path to packages 
sys.path.append('/Users/kawies/dev/src/pycbc')

# @todo lalsuite like commandline parsing
# commandline arguments can (but doesn't have to) be used to 
# set up the following mapping of different memorytypes 
# and implementations

from pycbc.straindata.straindata_cpu import StrainData as StrainData 
from pycbc.injector import Injector as Injector
from pycbc.resampler import  Resampler as Resampler
from pycbc.bandpassfilter import  ForwardsBackwardsButterworthFilter as BandpassFilter

from pycbc.datavector.datavectorcpu import real_vector_single_t as PreprocessedStrainData
from pycbc.datavector.datavectorcpu import real_vector_single_t as TemplateWaveform
from pycbc.datavector.datavectorcpu import real_vector_single_t as SnrData

#from pycbc.datavector.datavectorcuda import real_vector_single_t as PreprocessedStrainData
#from pycbc.datavector.datavectorcuda import real_vector_single_t as TemplateWaveform
#from pycbc.datavector.datavectorcuda import real_vector_single_t as SnrData

#from pycbc.datavector.datavectoropencl import real_vector_single_t as PreprocessedStrainData
#from pycbc.datavector.datavectoropencl import real_vector_single_t as TemplateWaveform
#from pycbc.datavector.datavectoropencl import real_vector_single_t as SnrData

# examples for datavectors:

# from pycbc.datavector.datavectorcpu import real_vector_double_t as FrequencySeries...
# from pycbc.datavector.datavectorcpu import complex_vector_single_t as TimeSeries ....
# from pycbc.datavector.datavectorcpu import complex_vector_double_t as TimeSeries ....
# from pycbc.datavector.datavectorcuda import complex_vector_single_t as TimeSeries ....
# from pycbc.datavector.datavectorcuda import complex_vector_double_t as TimeSeries ....

# ...

#from pycbc.matchedfilter.matchedfilter_opencl import MatchedFilterOpenCl as MatchedFilter
from pycbc.matchedfilter.matchedfilter_cpu import MatchedFilterCpu as MatchedFilter

# @todo imports:
#
#    pycbc.template_bank    module defining the template banks
#    pycbc.chisq_veto       module defining the chisq vetos
#    pycbc.events           module defining handling of events


# Provisionally displaced the test of the matched filter API to here ###########

proc_size= 16

htilde = TemplateWaveform(proc_size)
print htilde
print len(htilde)
htilde[0]= 1.234
print htilde[10]
htilde.start= 30
print htilde.start
htilde.dx= 30
print htilde.dx
htilde.generic_new_element_for_testing= 55
print htilde.generic_new_element_for_testing

stilde = PreprocessedStrainData(proc_size)
print stilde
print len(stilde)
stilde[1]= 1.234
print stilde[10]
stilde.start= 30
print stilde.start
stilde.dx= 30
print stilde.dx

snr = SnrData(proc_size)
print snr
print len(snr)
snr[2]= 1.234
print snr[10]
snr.start= 30
print snr.start
snr.dx= 30
print snr.dx

for i in range(len(htilde)):
    print i, snr[i]

for i in range(len(stilde)):
    print i, snr[i]

for i in range(len(snr)):
    print i, snr[i]


matched_filter = MatchedFilter(proc_size)
print matched_filter

matched_filter.perform_generate_snr(stilde, htilde, snr)
print snr


max = matched_filter.perform_max(snr)
print max


################################################################################
# main cbc search context
#

# read the input h(t) from a single detector
data = StrainData(15, 1024, "H1")
#data.read_frames("H1:LSC-STRAIN", 871147532, 871149580, "/path/to/cache.txt")

# perform software injections
#injector = Injector(data.time_series.length)
#injector.read_injections("/path/to/injections.xml")
#data = injector.inject_to_time_series(data)
#data.time_series.display()

# resample the data to the desired sampling frequency
resample_filter = Resampler(4096)
#data = resample_filter.resample_time_series(data)
#data.time_series.display()

# high pass the strain data to avoid dynamic range problems
high_pass_filter = BandpassFilter(0.1, 0.2, 0.3)
#data = high_pass_filter.high_pass(data, 35.0, 24)

# convert the data to a four-byte floating point number
#data.time_series.to_float()
#data.time_series.display()

print "exit pycbc"
exit()  # implemented prototype until here #####################################



# create the overwhitening filter
overwhitening_spectrum = pycbc.Spectrum(delta_t, N)
overwhitening_spectrum.power_spectrum(data, "medianmean", "hanning", 256, 128)
overwhitening_spectrum.inverse()       # 1/x
overwhitening_spectrum.truncate(16)    # ifft -> truncate in time domain -> fft

# create the overwhitened data segments in the frequency domain
data.fft_segments(256, 128)
data *= overwhitening_spectrum     # overwhitening_spectrum

# create a template bank to filter against

#Hint: TemplateBank would get it's target architecture (C, Cuda, openCl ...)
#      from the constructor call but the type of approximant would be read from the
#      xml-file. So it should instanciate it's gen_waveform_implementation-member
#      after reading the xml-file (by itself).

bank = TemplateBank()
bank.read( "/path/to/templates.xml" )

# apply any template-specific data preconditioning
data *= bank.condition_data()

# Point of data transfer between the different memories (Python, CPU, Cuda ...)
# could be specified here by calling
# a data transfer object (it knows how to transfer data by the datatypes 
# it is called with:

# data_transfer(data, stilde)  

# create the objects needed to perform the filtering
matched_filter = MatchedFilter( data )
chisq_veto = ChisqVeto( 15, psd )
events = SingleDetectorEvent()

# filter the data against the template bank
for htilde in bank:
    htilde.generate_filter_waveform()
    chisq.compute_frequency_bins(htilde)
    for stilde in data:
        snr = matched_filter.generate_snr( stilde, htilde )
        if matched_filter.max() > 5.5:
            chisq_veto.generate_chisq( snr )
            events.find_events( htilde, snr, chisq_veto )

# cluster the events across the template bank
events.cluster_events( 0.1 )
events.write( "/path/to/output.xml" )
