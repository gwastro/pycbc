#!/usr/bin/env /usr/bin/python
import logging, sys, numpy 
from optparse import OptionParser, OptionGroup
from pycbc import vetoes, psd, waveform, events, strain, scheme, DYN_RANGE_FAC
from pycbc.filter import  matched_filter_core, sigmasq, make_frequency_series
from pycbc.types import TimeSeries, FrequencySeries, zeros, float32, complex64

# Option Parsing ##############################################################
parser = OptionParser(
    usage   = "%prog [OPTIONS]",
    description = "Find single detector gravitational-wave triggers." )

parser.add_option("-V", "--verbose", action="store_true", help="print extra debugging information", default=False )
parser.add_option("--output", type=str)

parser.add_option("--snr-threshold", help="The the minimum snr threshold", type=float)
parser.add_option("--low-frequency-cutoff", help="The low frequency cutoff to use for filtering (Hz)", type=float)

parser.add_option("--approximant", help="Approximant to use for filtering.", type=str)
parser.add_option("--order", type=str)

parser.add_option("--cluster-method", choices=["template", "window"])
parser.add_option("--cluster-window", type=int, help="Length of clustering window in seconds", default = -1)
parser.add_option("--maximization-interval", help="Maximize triggers over the template bank (ms)", type=int, default=0)

parser.add_option("--bank-file", type=str)
parser.add_option("--bank-veto-bank-file", type=str)

parser.add_option("--chisq-bins", type=int, default=0)
parser.add_option("--chisq-threshold", type=float, default=0)
parser.add_option("--chisq-delta", type=float, default=0)

parser.add_option("--trig-start-time", type=int, default=0)
parser.add_option("--trig-end-time", type=int, default=0)
parser.add_option("--segment-length", type=int, help="The length of a segment (s)")
parser.add_option("--segment-start-pad", type=int, help="Length of corruption at the beginning of a segment(s)")
parser.add_option("--segment-end-pad", type=int, help="Length of corruption at the end of a segment (s)")

# Add options groups
psd.insert_psd_option_group(parser)
strain.insert_strain_option_group(parser)
scheme.insert_processing_option_group(parser)

opt, argv = parser.parse_args()

# Check that the values returned for the options make sense
psd.verify_psd_options(opt, parser)
strain.verify_strain_options(opt, parser)
scheme.verify_processing_options(opt, parser)

if opt.verbose:
    log_level = logging.DEBUG
else:
    log_level = logging.WARN

logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)

ctx = scheme.from_cli(opt)
strain_ts = strain.from_cli(opt)
sample_rate = int(1.0/strain_ts.delta_t)

with ctx:
    logging.info("Making frequency-domain data segments")
    strain_segments = strain.StrainSegments(strain_ts, 
                                            segment_length=opt.segment_length, 
                                            segment_start_pad=opt.segment_start_pad,
                                            segment_end_pad=opt.segment_end_pad,
                                            trigger_start=opt.trig_start_time,
                                            trigger_end=opt.trig_end_time)                                                              
    segments = strain_segments.fourier_segments()

    logging.info("Computing noise PSD")
    psd = psd.from_cli(opt, len(segments[0]), segments[0].delta_f,
                             opt.low_frequency_cutoff, strain_ts, DYN_RANGE_FAC).astype(float32)       
    bank_chisq = vetoes.SingleDetBankVeto(opt.bank_veto_bank_file, 
                                          opt.approximant, psd, segments,
                                          opt.low_frequency_cutoff, 
                                          phase_order=opt.order)                                       
    power_chisq = vetoes.SingleDetPowerChisq(opt.chisq_bins)
  
    logging.info("Overwhitening frequency-domain data segments")
    for seg in segments:
        seg /= psd
            
    template_work_mem = zeros((len(segments[0])-1)*2, dtype=complex64)
    snr_work_mem = zeros((len(segments[0])-1)*2, dtype=complex64)
    corr_work_mem = zeros((len(segments[0])-1)*2, dtype=complex64)

    event_mgr = events.EventManager(opt, 
                         ['time_index', 'snr', 'chisq', 'bank_chisq'], 
                         [int, complex64, float32, float32, float32], psd=psd)

    logging.info("Read in template bank")
    bank = waveform.FilterBank(opt.bank_file, opt.approximant, 
                    len(segments[0]), segments[0].delta_f, 
                    opt.low_frequency_cutoff, dtype=complex64, 
                    phase_order=opt.order, psd=psd, out=template_work_mem)  

    for t_num, template in enumerate(bank):  
        event_mgr.new_template(tmplt=template.params, sigmasq=template.sigmasq)                                                                                    
        for s_num, stilde in enumerate(segments):               
            logging.info("Filtering template %d/%d segment %d/%d" % \
                         (t_num + 1, len(bank), s_num + 1, len(segments)))       
            snr, corr, norm = matched_filter_core(template, stilde, h_norm=template.sigmasq, 
                                                  low_frequency_cutoff=opt.low_frequency_cutoff, 
                                                  out=snr_work_mem, corr_out=corr_work_mem)                                         
            idx, snrv = events.threshold(snr[stilde.analyze], opt.snr_threshold / norm)            
            if len(idx) == 0:
                continue                 
             
            logging.info("%s points above threshold" % str(len(idx)))
            bank_chisqv = bank_chisq.values(template, s_num, snr, norm, idx+stilde.analyze.start)
            power_chisqv = power_chisq.values(corr, snr, norm, psd, idx+stilde.analyze.start, template, bank, opt.low_frequency_cutoff)
            
            snrv *= norm
            idx += stilde.cumulative_index
            
            event_mgr.add_template_events( ["snr", "time_index", "chisq", "bank_chisq"], [snrv, idx, power_chisqv, bank_chisqv])

        if opt.cluster_method == "window":
            cluster_window = opt.cluster_window * sample_rate
        elif opt.cluster_method == "template":
            cluster_window = template.length_in_time * sample_rate
            
        event_mgr.cluster_template_events("time_index", "snr", cluster_window) 
        event_mgr.finalize_template_events()   
        
logging.info("Found %s triggers" % str(len(event_mgr.events)))

if opt.chisq_threshold and opt.chisq_bins:
    logging.info("Removing triggers with poor chisq")
    event_mgr.chisq_threshold(opt.chisq_threshold, opt.chisq_bins, opt.chisq_delta)
    logging.info("%s remaining triggers" % str(len(event_mgr.events)))

if opt.maximization_interval:       
    logging.info("Maximizing triggers over %s ms window" % opt.maximization_interval)
    event_mgr.maximize_over_bank("time_index", "snr", opt.maximization_interval * sample_rate / 1000)
    logging.info("%s remaining triggers" % str(len(event_mgr.events)))

logging.info("Writing out triggers")
event_mgr.write_events(opt.output)
logging.info("Finished")
