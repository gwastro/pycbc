#! /usr/bin/env python
# Copyright (C) 2016  Collin Capano
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#
__description__ = \
""""Loads a bank of waveforms and compresses them using the specified
compression algorithm. The resulting compressed waveforms are saved to an
hdf file."""

import argparse
import numpy
import h5py
import logging
import pycbc
from pycbc.waveform import compress
from pycbc import waveform
from pycbc.types import FrequencySeries
from pycbc import pnutils
from pycbc import filter

parser = argparse.ArgumentParser(description=__description__)
parser.add_argument("--bank-file", type=str,
                help="Bank hdf file to load.")
parser.add_argument("--output", type=str,
                help="The hdf file to save the templates and compressed "
                     "waveforms to.")
parser.add_argument("--low-frequency-cutoff", type=float, required=True,
                help="The low frequency cutoff to use for generating "
                     "the waveforms (Hz)")
parser.add_argument("--approximant", type=str,
                help="The approximant to generate the waveforms with. If "
                     "none provided, will attempt to retrieve the approximant "
                     "from the bank file.")
parser.add_argument("--sample-rate", type=int, required=True,
                help="Half this value sets the maximum frequency of the "
                     "compressed waveforms.")
parser.add_argument("--segment-length", type=float, required=True,
                help="The inverse of this sets the delta-f used for "
                     "generating waveforms prior to compressing.")
parser.add_argument("--tmplt-index", nargs=2, type=int, default=None,
                help="Only generate compressed waveforms for the given "
                     "indices in the bank file. Must provide both a start "
                     "and a stop index. Default is to compress all of the "
                     "templates in the bank file.")
parser.add_argument("--compression-algorithm", type=str, default="mchirp",
                help="The compression algorithm to use for selecting "
                     "frequency points. Options are %s. Default is mchirp." %(
                     ', '.join(compress.compression_algorithms.keys())))
parser.add_argument("--fixed-sample-points", action="store_true",
                help="Use the same frequency vector for all waveforms. "
                     "To use, the compression algorithm must be 'mchirp'. In "
                     "this case, the frequency vector will be based on the "
                     "lowest-mass template in the desried range.")
parser.add_argument("--t-pad", type=float, default=0.02,
                help="The minimum duration used for t(f) in seconds. The "
                     "inverse of this gives the maximum frequency step that "
                     "will be used in the compressed waveforms. Default is "
                     "0.02.")
parser.add_argument("--check-compression", action="store_true", default=False,
                help="Check the overlap between the compressed waveform and "
                     "the full waveform. Results are saved to the output.")
parser.add_argument("--interpolation", type=str, default="linear",
                help="If check-compression, the interpolation to use for "
                     "decompressing the waveforms. Options are 'linear', or "
                     "any interpolation recognized by scipy's interp1d kind "
                     "argument. Default is linear.")
parser.add_argument("--verbose", action="store_true", default=False)


args = parser.parse_args()

pycbc.init_logging(args.verbose)

if args.fixed_sample_points and args.compression_algorithm != 'mchirp':
    raise ValueError("fixed-sample-points requires the mchirp algorithm")

df = 1./args.segment_length
fmin = args.low_frequency_cutoff
# figure out the length of the full waveforms in the frequency domain
N = int(args.sample_rate*args.segment_length/2 + 1)
# scratch space
scratch = FrequencySeries(numpy.zeros(N, dtype=numpy.complex128), delta_f=df)
if args.check_compression is not None:
    decomp_scratch = FrequencySeries(numpy.zeros(N, dtype=numpy.complex128),
        delta_f=df)
# we'll need the full frequency series
allf = numpy.arange(N)*df

# load the bank
logging.info("loading bank")
bank = waveform.FilterBank(args.bank_file, N, df, fmin, numpy.complex128,
    approximant=args.approximant, out=scratch)
templates = bank.table
if args.tmplt_index is not None:
    imin, imax = args.tmplt_index
    templates = templates[imin:imax]
else:
    imin, imax = 0, templates.size

# the index of the starting frequency in the full frequency series
kmin = int(fmin*args.segment_length)

# we'll use the SEOBNRv2 ringdown frequency as maximum frequencies for the
# sample points
logging.info("computing maximum frequencies")
kmaxes = (args.segment_length*pnutils.get_freq('fSEOBNRv2RD',
            templates.mass1, templates.mass2,
            templates.spin1z, templates.spin2z)).astype(int)
kmaxes[kmaxes > N] = N

# generate output file
# FIXME: this should be moved to a class or function
logging.info("writing template info to output")
output = h5py.File(args.output, 'w')
output['mass1'] = templates['mass1']
output['mass2'] = templates['mass2']
output['spin1z'] = templates['spin1z']
output['spin2z'] = templates['spin2z']
output['template_hash'] = templates['template_hash']

if args.fixed_sample_points:
    logging.info("getting fixed sample points")
    useidx = pnutils.mass1_mass2_to_mchirp_eta(
        templates.mass1, templates.mass2)[0].argmin()
    fixed_points = compress.mchirp_compression(templates.mass1[useidx],
        templates.mass2[useidx], fmin, df*(kmaxes.max()-1),
        min_seglen=args.t_pad, df_multiple=df)
    output['compressed_waveforms/frequency'] = fixed_points
else:
    sample_points = None
# get the compressed sample points for each template
logging.info("getting compressed amplitude and phase")
for ii in range(imin, imax):
    htilde = bank[ii]
    tmplt = bank.table[ii]
    kmax = kmaxes[ii]
    # get the compressed sample points
    if args.fixed_sample_points:
        sample_points = fixed_points[:kmax-1]
    elif args.compression_algorithm == 'mchirp':
        sample_points = compress.mchirp_compression(tmplt.mass1, tmplt.mass2,
            fmin, (kmax-1)*df, min_seglen=args.t_pad, df_multiple=df)
    elif args.compression_algorithm == 'spa':
        sample_points = compress.spa_compression(htilde, fmin, (kmax-1)*df,
            min_seglen=args.t_pad, sample_frequencies=allf)
    else:
        raise ValueError("unrecognized compression algorithm %s" %(
            args.compression_algorithm))
    # compress
    sample_index = (sample_points/df).astype(int)
    amp = waveform.amplitude_from_frequencyseries(htilde)
    phase = waveform.phase_from_frequencyseries(htilde)
    compAmp = amp[sample_index]
    compPhase = phase[sample_index]

    output['compressed_waveforms/%i/amplitude' %(ii-imin)] = compAmp.data 
    output['compressed_waveforms/%i/phase' %(ii-imin)] = compPhase.data
    if args.fixed_sample_points:
        output['compressed_waveforms/%i/frequency' %(ii-imin)] = \
            h5py.SoftLink('/compressed_waveforms/frequency')
    else:
        output['compressed_waveforms/%i/frequency' %(ii-imin)] = \
            sample_points
    if args.check_compression:
        hdecomp = compress.fd_decompress(compAmp, compPhase, sample_points,
            out=decomp_scratch, f_lower=fmin, interpolation=args.interpolation)
        ff = filter.overlap(hdecomp, htilde)
        output['compressed_waveforms/%i' %(ii-imin)].attrs['interpolation'] = \
            args.interpolation
        output['compressed_waveforms/%i' %(ii-imin)].attrs['overlap'] = ff
logging.info("finished")
output.close()
