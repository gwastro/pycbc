#!/usr/bin/env python
""" Ingest and process DQ data
"""
import logging, argparse, numpy, h5py, time, copy
import pycbc, pycbc.strain
from pycbc.version import git_verbose_msg as version
from pycbc.workflow import resolve_td_option
from ligo.segments import segmentlist, segment

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--version', action='version', version=version)
parser.add_argument('--verbose', action="store_true")
parser.add_argument("--dq-sample-rate", default=1, type=int,
                    help="Sample rate to calculate dq timeseries, "
                         "in Hz [default=1Hz]")
parser.add_argument("--dq-sample-method", required=True,
                    help="Method used to calculate dq timeseries. "
                         "Options are 'max' or 'blrms'")
parser.add_argument("--gps-start-time", type=int,required=True,
                    help="The gps start time of the data "
                          "(integer seconds)")
parser.add_argument("--gps-end-time", type=int,required=True,
                    help="The gps end time of the data "
                         "(integer seconds)")
parser.add_argument("--output-file", required=True,
                    help="name of output file")

pycbc.strain.insert_strain_option_group(parser, gps_times=False)

parser.set_defaults(pad_data=0)

args = parser.parse_args()
pycbc.init_logging(args.verbose)

def get_dq(seg):
    """ Get the DQ data for the given data chunck
    """
    
    logging.info('Getting dq values for %.1f-%.1f (%.1f s)', seg[0],
                 seg[1], abs(seg[1]-seg[0]))
    argstmp = copy.deepcopy(args)
    argstmp.gps_start_time = int(seg[0])
    argstmp.gps_end_time = int(seg[1])
    tmp_segment = segment([argstmp.gps_start_time, argstmp.gps_end_time])
    argstmp.channel_name = resolve_td_option(args.channel_name, tmp_segment)

    try:
        gwstrain = pycbc.strain.from_cli(argstmp)
    except RuntimeError:
        time.sleep(10)
        return get_dq(seg)

    logging.info('Normalizing dq values for %.1f-%.1f (%.1f s)', seg[0],
                 seg[1], abs(seg[1]-seg[0]))

    dq_sample_rate = float(args.dq_sample_rate) 
    dq_step_size = gwstrain.sample_rate/dq_sample_rate

    dq_method = args.dq_sample_method
    
    if dq_method == "max":
        # maximize gwstrain over given interval
        val_dq = numpy.array([max(gwstrain.numpy()
                                  [int(n*dq_step_size):
                                   int((n+1)*dq_step_size)])
                              for n in numpy.arange(0, len(gwstrain.numpy()) /
                                                    dq_step_size)])
    elif dq_method=="blrms":
        # Calculate the blrms over given interval
        val_dq = numpy.array([numpy.mean(gwstrain.numpy()
                                          [int(n*dq_step_size):
                                           int((n+1)*dq_step_size)]**2)**0.5
                               for n in numpy.arange(0, len(gwstrain.numpy()) /
                                                     dq_step_size)])
    else:
        raise TypeError("%s is not an available dq method. " 
                        "Options are 'max' or 'blrms'", dq_method)

    # figure out list of times
    times_dq = numpy.arange(gwstrain.start_time,gwstrain.end_time,
                            1./dq_sample_rate)

    return val_dq, times_dq

ifo = args.channel_name[0:2]

dq = get_dq((args.gps_start_time,args.gps_end_time))

f = h5py.File(args.output_file, 'w')
start, end = [args.gps_start_time], [args.gps_end_time]

f[ifo + '/start_time'] = numpy.array(start, dtype=numpy.uint32)
f[ifo + '/end_time'] = numpy.array(end, dtype=numpy.uint32)
f[ifo + '/dq_val'] = numpy.array(dq[0], dtype=numpy.float32)
f[ifo + '/times'] = numpy.array(dq[1], dtype=numpy.uint32)

logging.info('Done!')

