#!/usr/bin/env python

# Copyright 2016 Thomas Dent
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.


import sys, h5py
import argparse, logging

import copy, numpy as np

from pycbc import io, events, init_logging
from pycbc.events import triggers, trigger_fits as trstats, veto
from pycbc.events import stat as statsmod, fits_by_template as fbt
from pycbc.types.optparse import MultiDetOptionAction
import pycbc.version


parser = argparse.ArgumentParser(usage="",
    description="Perform maximum-likelihood fits of single inspiral trigger"
                " distributions to various functions")
pycbc.add_common_pycbc_options(parser)
parser.add_argument("--version", action=pycbc.version.Version)
parser.add_argument("--trigger-file",
                    help="Input hdf5 file containing single triggers. "
                    "Required")
parser.add_argument("--bank-file", default=None,
                    help="hdf file containing template parameters. Required")
parser.add_argument("--template-fraction-range", default="0/1",
                    help="Optional, analyze only part of template bank. "
                    "Format is PART/NUM_PARTS")
parser.add_argument("--veto-file", nargs='*', default=[], action='append',
                    help="File(s) in .xml format with veto segments to apply "
                    "to triggers before fitting")
parser.add_argument("--veto-segment-name", nargs='*', default=[], action='append',
                    help="Name(s) of veto segments to apply. Optional, if not "
                    "given all segments for a given ifo will be used")
parser.add_argument("--gating-veto-windows", nargs='+',
                    action=MultiDetOptionAction,
                    help="Seconds to be vetoed before and after the central time "
                         "of each gate. Given as detector-values pairs, e.g. "
                         "H1:-1,2.5 L1:-1,2.5 V1:0,0")
parser.add_argument("--output", required=True,
                    help="Location for output file containing fit coefficients"
                    ". Required")
parser.add_argument("--ifo", required=True,
                    help="Ifo producing triggers to be fitted. Required")
parser.add_argument("--fit-function",
                    choices=["exponential", "rayleigh", "power"],
                    help="Functional form for the maximum likelihood fit")
parser.add_argument("--stat-threshold", type=float,
                    help="Only fit triggers with statistic value above this "
                    "threshold.  Required.  Typically 6-6.5")
parser.add_argument("--save-trig-param",
                    help="For each template, save a parameter value read from "
                    "its trigger(s). Ex. template_duration")
parser.add_argument("--prune-param",
                    help="Parameter to define bins for 'pruning' loud triggers"
                    " to make the fit insensitive to signals and outliers. "
                    "Choose from mchirp, mtotal, template_duration or a named "
                    "frequency cutoff in pnutils or a frequency function in "
                    "LALSimulation")
parser.add_argument("--prune-bins", type=int,
                    help="Number of bins to divide bank into when pruning")
parser.add_argument("--prune-number", type=int,
                    help="Number of loudest events to prune in each bin")
parser.add_argument("--log-prune-param", action='store_true',
                    help="Bin in the log of prune-param")
parser.add_argument("--f-lower", default=-1.,
                    help="Starting frequency for calculating template "
                    "duration, required if this is the prune parameter")
# FIXME : support using the trigger file duration as prune parameter?
# FIXME : have choice of SEOBNRv2 or PhenD duration formula ?
parser.add_argument("--min-duration", default=0.,
                    help="Fudge factor for templates with tiny or negative "
                    "values of template_duration: add to duration values "
                    "before pruning. Units seconds")
parser.add_argument("--approximant", default="SEOBNRv4",
                    help="Approximant for template duration. Default SEOBNRv4")

statsmod.insert_statistic_option_group(parser,
    default_ranking_statistic='single_ranking_only')
args = parser.parse_args()

init_logging(args.verbose)

args.veto_segment_name = sum(args.veto_segment_name, [])
args.veto_file = sum(args.veto_file, [])

if len(args.veto_segment_name) != len(args.veto_file):
    raise RuntimeError("Number of veto files much match veto file names")

if (args.prune_param or args.prune_bins or args.prune_number) and not \
   (args.prune_param and args.prune_bins and args.prune_number):
    raise RuntimeError("To prune, need to specify param, number of bins and "
                       "nonzero number to prune in each bin!")

logging.info('Opening trigger file: %s' % args.trigger_file)
trigf = h5py.File(args.trigger_file, 'r')
logging.info('Opening template file: %s' % args.bank_file)
templatef = h5py.File(args.bank_file, 'r')

count_in_template = fbt.count_in_template(trigf[args.ifo], templatef)
logging.info('%i trigs before thresholding', sum(count_in_template))

logging.info('Removing trigs below threshold %f', args.stat_threshold)
# get the stat values and an others required
rank_method = statsmod.get_statistic_from_opts(args, [args.ifo])
abovethresh, stat, additional_datasets = fbt.get_stat(
    trigf[args.ifo],
    rank_method,
    args.stat_threshold,
    additional_datasets=['end_time','template_id']
)
logging.info('%i trigs left after thresholding', len(stat))

logging.info("Getting template_id and time")
tid = additional_datasets['template_id']
time = additional_datasets['end_time']

if args.save_trig_param:
    logging.info("Getting %s from template bank for saving", args.save_trig_param)
    tparam_region = trigf[args.ifo][args.save_trig_param + '_template'][:]
    tparam = []
    for region in tparam_region:
        try:
            tparam.append(trigf[args.ifo][args.save_trig_param][region][0])
        except IndexError:
            # Should only happen if there are no triggers in the template
            tparam.append(np.nan)

all_segments = fbt.retained_segments(
    trigf,
    args.ifo,
    veto_file=args.veto_file,
    veto_segment_name=args.veto_segment_name,
    gating_veto_windows=args.gating_veto_windows
)
total_time = abs(all_segments)

vretain = fbt.segment_mask(time, all_segments)

logging.info("Removing triggers in vetoed segments")
stat = stat[vretain]
tid = tid[vretain]
time = time[vretain]

# do pruning (removal of trigs at N loudest times defined over param bins)
if args.prune_param:
    logging.info('Getting %s values', args.prune_param)
    pars = triggers.get_param(
        args.prune_param,
        args,
        templatef['mass1'][:],
        templatef['mass2'][:],
        templatef['spin1z'][:],
        templatef['spin2z'][:]
    )

    # Find which triggers would be removed by pruning
    prune_mask = fbt.prune_mask(
        stat,
        time,
        pars[tid],
        prune_number=args.prune_number,
        prune_bins=args.prune_bins,
        prune_window=0.1,
        log=args.log_prune_param
    )

    stat = stat[prune_mask]
    tid = tid[prune_mask]
    time = time[prune_mask]


# parse template range - Is this still wanted? Fitting doesn't take long at all
num_templates = len(templatef['template_hash'])
rangestr = args.template_fraction_range
part = int(rangestr.split('/')[0])
pieces = int(rangestr.split('/')[1])
tmin = int(num_templates / float(pieces) * part)
tmax = int(num_templates / float(pieces) * (part + 1))
trange = range(tmin, tmax)

# initialize result storage
counts_total = count_in_template[trange]

counts_above = []
fits = []
tpars = []

counts_above, fits = fbt.fit_triggers(
    stat,
    tid,
    args.fit_function,
    args.stat_threshold,
    trange
)

logging.info("Calculating median sigma for each template")
sigma_regions = trigf[args.ifo + '/sigmasq_template'][:]
median_sigma = []
for reg in sigma_regions:
    strigs = trigf[args.ifo + '/sigmasq'][reg]
    median_sigma.append(np.median(strigs) ** 0.5)

logging.info("Outputting results")
with h5py.File(args.output, 'w') as outfile:
    outfile.create_dataset("template_id", data=trange)
    outfile.create_dataset("count_above_thresh", data=counts_above)
    outfile.create_dataset("fit_coeff", data=fits)
    if args.save_trig_param:
        outfile.create_dataset("template_param", data=tpars)
    outfile.create_dataset("count_in_template", data=counts_total)
    outfile.create_dataset("median_sigma", data=median_sigma)
    # Add some metadata
    outfile.attrs.create("ifo", data=args.ifo.encode())
    outfile.attrs.create("fit_function", data=args.fit_function.encode())
    outfile.attrs.create("sngl_stat", data=args.sngl_ranking)
    if args.save_trig_param:
        outfile.attrs.create("save_trig_param", data=args.save_trig_param.encode())
    outfile.attrs.create("stat_threshold", data=args.stat_threshold)
    outfile.attrs.create("analysis_time", data=total_time)

logging.info('Done!')
