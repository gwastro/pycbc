#!/usr/bin/env python

# Copyright (C) 2018 Ian Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Plot single-detector qscan of strain data
"""

import sys
import argparse
import logging
import numpy

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
from matplotlib.colors import LogNorm
from matplotlib.image import NonUniformImage

import pycbc.strain
import pycbc.version
import pycbc.results

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument("--version", action="version",
                    version=pycbc.version.git_verbose_msg)
parser.add_argument('--output-file', required=True, help='Output plot')
parser.add_argument('--center-time', type=float,
                    help='Center plot on the given GPS time')

parser.add_argument('--qtransform-delta-t', default=None,
                    help='The time resolution to interpolate to (optional)')
parser.add_argument('--qtransform-delta-f', default=None,
                    help='Frequency resolution to interpolate to (optional)')
parser.add_argument('--qtransform-logfsteps', type=int, default=None,
                    help='Do a log interpolation (incompatible with '
                         '--qtransform-delta-f option) and set the number '
                         'of steps to take')
parser.add_argument('--qtransform-frange-lower', default=None,
                    help='Lower frequency at which to compute qtransform. '
                         'Optional, default=30')
parser.add_argument('--qtransform-frange-upper', default=None,
                    help='Upper frequency at which to compute qtransform. '
                         'Optional, default=Half of Nyquist')
parser.add_argument('--qtransform-qrange-lower', default=4,
                    help='Lower limit of the range of q to consider, '
                         'default=4')
parser.add_argument('--qtransform-qrange-upper', default=64,
                    help='Upper limit of the range of q to consider, '
                         'default=4')
parser.add_argument('--qtransform-mismatch', default=0.2,
                    help='Mismatch between frequency tiles, default=0.2')

parser.add_argument('--linear-y-axis', dest='log_y', default=True, 
                    action='store_false',
                    help='Use a linear y-axis. By default a log axis is used.')
parser.add_argument('--plot-title',
                    help="If given, use this as the plot title")
parser.add_argument('--plot-caption',
                    help="If given, use this as the plot caption")

pycbc.strain.insert_strain_option_group(parser)
opts = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)

#opts.low_frequency_cutoff = opts.f_low
strain = pycbc.strain.from_cli(opts, pycbc.DYN_RANGE_FAC)

if opts.center_time is None:
    center_time = (opts.gps_start_time + opts.gps_end_time) / 2.
else:
    center_time = opts.center_time

if opts.qtransform_frange_upper is None and \
        opts.qtransform_frange_lower is None:
    curr_frange = (30, opts.sample_rate / 4.)
elif opts.qtransform_frange_upper is None or \
        opts.qtransform_frange_lower is None:
    err_msg = 'Must provide either both --qtransfor-frange-upper and '
    err_msg += '--qtransfor-frange-lower or neither option.'
    raise ValueError(err_msg)
else:
    curr_frange = (opts.qtransform_frange_lower, opts.qtransform_frange_upper)

times, freqs, qvals = strain.qtransform\
    (delta_t=opts.qtransform_delta_t, delta_f = opts.qtransform_delta_f,
     logfsteps=opts.qtransform_logfsteps, frange=curr_frange,
     qrange=(opts.qtransform_qrange_lower, opts.qtransform_qrange_upper),
     mismatch=opts.qtransform_mismatch)
delay_time = opts.center_time - opts.gps_start_time
time_start_idx = int(opts.sample_rate * (delay_time - 1))
time_end_idx = int(opts.sample_rate * (delay_time + 1))
rqvals = qvals[:,time_start_idx:time_end_idx]
rtimes = times[time_start_idx:time_end_idx]
rtimes = rtimes - rtimes[0] - 1

if opts.log_y:
    # This is a PITA. The Y-axis is not tied to the image at all. So we use a
    # log scale with values running between the desired limits.
    freqs = numpy.log(freqs)
    min_val = min(freqs)
    max_val = max(freqs)
    freqs = freqs * (curr_frange[1] - curr_frange[0]) / (max_val - min_val)
    freqs = freqs - freqs[0] + curr_frange[0]

fig = plt.figure()
ax = fig.gca()
im = NonUniformImage(ax, interpolation='nearest',
                     extent=(-1, 1, curr_frange[0], curr_frange[1]),
                     norm=LogNorm(vmin=1, vmax=rqvals.max()))
im.set_data(rtimes, freqs, rqvals) 
ax.images.append(im)
ax.set_xlim(-1,1)
ax.set_ylim(10,512)
if opts.log_y:
    ax.set_yscale('log')
ax.set_xlabel('Time from {} (s)'.format(opts.center_time))
ax.set_ylabel('Frequency (Hz)')
cbar = fig.colorbar(im)
cbar.ax.set_ylabel('Normalized energy frequency (Hz)')

if opts.plot_title is None:
    opts.plot_title = 'Q-transform plot'
if opts.plot_caption is None:
    # FIXME: Someone please improve!
    opts.plot_caption = ("This shows the Q-transform as a function of time and "
                        "frequency")

pycbc.results.save_fig_with_metadata\
    (fig, opts.output_file, cmd=' '.join(sys.argv), fig_kwds={'dpi': 150},
     title=opts.plot_title, caption=opts.plot_caption)
