#!/usr/bin/env python

"""
Program for plotting the results of the pycbc_faithsim and pycbc_collect_result script
that compare two approximants and compute the match between them.
"""

import argparse
import matplotlib

matplotlib.use("Agg")
import matplotlib.cm
import pylab
import numpy as np
from ligo.lw import utils, table, lsctables
from matplotlib.ticker import MultipleLocator, FormatStrFormatter
from pycbc import pnutils


cfields = (
    "match",
    "overlap",
    "time_offset",
    "sigma1",
    "sigma2",
    "mass1",
    "mass2",
    "spin1x",
    "spin1y",
    "spin1z",
    "spin2x",
    "spin2y",
    "spin2z",
    "inclination",
    "latitude",
    "longitude",
    "polarization",
    "coa_phase",
    "mass_ratio",
    "mchirp",
    "total_mass",
    "spin1_magnitude",
    "spin2_magnitude",
)

dtypec = {
    "names": cfields,
    "formats": (
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
        "f8",
    ),
}


def basic_scatter(
    out_name,
    neg_idx,
    xname,
    yname,
    title,
    xval,
    yval,
    cval,
    cname,
    vmin,
    vmax,
    xmin,
    ymin,
    majorL,
    minorL,
    colormap,
):
    if colormap != "jet":
        cmap = colormap
    else:
        cmap = matplotlib.cm.jet
        cmap.set_under(color="gray")

    if vmin is not None:
        vmin = float(vmin)

    if vmax is not None:
        vmax = float(vmax)

    fig = pylab.figure(num=None)
    pylab.scatter(
        xval,
        yval,
        c=cval,
        linewidths=0,
        s=3,
        vmin=vmin,
        vmax=vmax,
        cmap=cmap,
        alpha=0.7,
    )

    if len(neg_idx) > 0:
        pylab.scatter(
            xval[neg_idx],
            yval[neg_idx],
            c="red",
            marker="x",
            label="Unable to generate waveforms",
        )
        matplotlib.pyplot.legend()

    if cval is not None:
        bar = pylab.colorbar()
        bar.set_label(cname)

    pylab.xlabel(xname)
    pylab.ylabel(yname)

    if xmin is None:
        xmin = min(xval)
    else:
        xmin = float(xmin)

    if ymin is None:
        ymin = min(yval)
    else:
        ymin = float(ymin)

    pylab.xlim(xmin, max(xval))
    pylab.ylim(ymin, max(yval))

    ax = fig.gca()
    if majorL:
        majorL = float(majorL)
        ax.xaxis.set_major_locator(MultipleLocator(majorL))
        ax.yaxis.set_major_locator(MultipleLocator(majorL))
    if minorL:
        minorL = float(minorL)
        ax.xaxis.set_minor_locator(MultipleLocator(minorL))
        ax.yaxis.set_minor_locator(MultipleLocator(minorL))

    pylab.grid()
    pylab.title(title)

    pylab.savefig(out_name, dpi=500)


parser = argparse.ArgumentParser(usage="", description=__doc__[1:])
parser.add_argument(
    "--input-file",
    required=True,
    help="resulting .dat file from pycbc_faithsim_collect_full_results",
)
parser.add_argument("--parameter-x", required=True)
parser.add_argument("--parameter-y", required=True)
parser.add_argument("--parameter-z", required=True)
parser.add_argument("--colormap", default="jet")
parser.add_argument("--vmin", default=None, help="min value of the colorbar")
parser.add_argument("--vmax", default=None, help="max value of the colorbar")
parser.add_argument("--xmin", default=None)
parser.add_argument("--ymin", default=None)
parser.add_argument("--majorL", default=None)
parser.add_argument("--minorL", default=None)
parser.add_argument("--output-plot", required=True, help="name of the output plot")

args = parser.parse_args()

data = np.loadtxt(args.input_file, dtype=dtypec)

red_data = data[data["match"] > -0.5]

title = args.parameter_x + " VS " + args.parameter_y + " colorbar " + args.parameter_z

neg_idx = np.flatnonzero(data["match"] < 0)

if args.parameter_z == "time_offset":
    basic_scatter(
        args.output_plot,
        neg_idx,
        args.parameter_x,
        args.parameter_y,
        title,
        red_data[args.parameter_x],
        red_data[args.parameter_y],
        red_data[args.parameter_z],
        args.parameter_z,
        vmin=args.vmin,
        vmax=args.vmax,
        xmin=args.xmin,
        ymin=args.ymin,
        majorL=args.majorL,
        minorL=args.minorL,
        colormap=args.colormap,
    )

else:
    basic_scatter(
        args.output_plot,
        neg_idx,
        args.parameter_x,
        args.parameter_y,
        title,
        data[args.parameter_x],
        data[args.parameter_y],
        data[args.parameter_z],
        args.parameter_z,
        vmin=args.vmin,
        vmax=args.vmax,
        xmin=args.xmin,
        ymin=args.ymin,
        majorL=args.majorL,
        minorL=args.minorL,
        colormap=args.colormap,
    )
