#!/usr/bin/python
""" Make table of the foreground coincident events
"""
import argparse, h5py, numpy, logging, mpld3, mpld3.plugins, mpld3.utils
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plot
from glue.ligolw import ligolw, table, lsctables, utils as ligolw_utils
from glue import segments
import pycbc.results.followup, pycbc.pnutils
import os.path

from pycbc.results.mpld3_utils import ClickLink

# dummy class needed for loading LIGOLW files
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
    pass
lsctables.use_in(LIGOLWContentHandler)

def veto_indices(times, ifo, veto_files):
    """ Return the list of indices that should be vetoed by the segments in the
    lsit of veto_files.
    """
    time_sorting = numpy.argsort(times)
    times = times[time_sorting]
    indices = numpy.array([], dtype=numpy.uint32)
   
    for veto_file in veto_files:
        indoc = ligolw_utils.load_filename(veto_file, False, contenthandler=LIGOLWContentHandler)
        segment_table  = table.get_table(indoc, lsctables.SegmentTable.tableName)
        
        seg_def_table = table.get_table(indoc, lsctables.SegmentDefTable.tableName)
        def_ifos = seg_def_table.getColumnByName('ifos')
        def_ids = seg_def_table.getColumnByName('segment_def_id')
        ifo_map =  {}
        for def_ifo, def_id in zip(def_ifos, def_ids):
            ifo_map[def_id] = def_ifo
        
        start = numpy.array(segment_table.getColumnByName('start_time')) + numpy.array(segment_table.getColumnByName('start_time_ns')) * 1e-9
        end = numpy.array(segment_table.getColumnByName('end_time')) + numpy.array(segment_table.getColumnByName('end_time_ns')) * 1e-9
        ifos = [ifo_map[v] for v in segment_table.getColumnByName('segment_def_id')]
        
        veto_segs = segments.segmentlist()
        for s, e, ifo_row in zip(start, end, ifos):
            if ifo != ifo_row:
                continue
                
            veto_segs += [segments.segment(s, e)]

        veto_segs.coalesce()        

        left = numpy.searchsorted(times, start, side='left')
        right = numpy.searchsorted(times, end, side='right')
        for li, ri, ifo_row in zip(left, right, ifos):
            if ifo != ifo_row:
                continue
                
            seg_indices = numpy.arange(li, ri, 1).astype(numpy.uint32)
            indices=numpy.union1d(seg_indices, indices)  
            
    return time_sorting[indices], veto_segs


def keep_ind(times, start, end):
    time_sorting = times.argsort()
    times = times[time_sorting]
    indices = numpy.array([], dtype=numpy.uint32)
    left = numpy.searchsorted(times, start, side='left')
    right = numpy.searchsorted(times, end, side='right')
    
    for li, ri in zip(left, right):
        seg_indices = numpy.arange(li, ri, 1).astype(numpy.uint32)
        indices=numpy.union1d(seg_indices, indices)  
    return time_sorting[indices] 

parser = argparse.ArgumentParser()
parser.add_argument('--trigger-file')
parser.add_argument('--injection-file')
parser.add_argument('--injection-tag')
parser.add_argument('--veto-file')
parser.add_argument('--injection-window', type=float)
parser.add_argument('--verbose', action='count')
parser.add_argument('--output-file')
args = parser.parse_args()

if args.verbose:
    log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)
    
logging.info('Read in the data')
f = h5py.File(args.trigger_file, 'r')

stat1 = f['foreground/stat1'][:]
stat2 = f['foreground/stat2'][:]
ifar = f['foreground/ifar'][:]
time1 = f['foreground/time1'][:]
time2 = f['foreground/time2'][:]
ana_start = f['foreground/analyzed_start'][:]
ana_end = f['foreground/analyzed_end'][:]
#print ana_start, ana_end
time = 0.5 * (time1 + time2)
time_sorting = time.argsort()

logging.info('Read in the injection file')
indoc = ligolw_utils.load_filename(args.injection_file, False, contenthandler=LIGOLWContentHandler)
sim_table = table.get_table(indoc, lsctables.SimInspiralTable.tableName)
inj_time = numpy.array(sim_table.get_column('geocent_end_time') + 1e-9 * sim_table.get_column('geocent_end_time_ns'), dtype=numpy.float64)
inj_m1 = numpy.array(sim_table.get_column('mass1'), dtype=numpy.float32)
inj_m2 = numpy.array(sim_table.get_column('mass2'), dtype=numpy.float32)
inj_s1x = numpy.array(sim_table.get_column('spin1x'), dtype=numpy.float32)
inj_s1y = numpy.array(sim_table.get_column('spin1y'), dtype=numpy.float32)
inj_s1z = numpy.array(sim_table.get_column('spin1z'), dtype=numpy.float32)
inj_s2x = numpy.array(sim_table.get_column('spin2x'), dtype=numpy.float32)
inj_s2x = numpy.array(sim_table.get_column('spin2y'), dtype=numpy.float32)
inj_s2z = numpy.array(sim_table.get_column('spin2z'), dtype=numpy.float32)
dist_h = numpy.array(sim_table.get_column('eff_dist_h'), dtype=numpy.float32)
dist_l = numpy.array(sim_table.get_column('eff_dist_l'), dtype=numpy.float32)
dec_dist = numpy.minimum(dist_h, dist_l)
inj_mchirp, inj_eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(inj_m1, inj_m2)

logging.info('Determined the found injections by time')
left = numpy.searchsorted(time[time_sorting], inj_time - args.injection_window, side='left')
right = numpy.searchsorted(time[time_sorting], inj_time + args.injection_window, side='right')

i1, v1 = veto_indices(inj_time, 'H1', [args.veto_file])
i2, v2 = veto_indices(inj_time, 'L1', [args.veto_file])
vi = numpy.concatenate([i1, i2])
ki = keep_ind(inj_time, ana_start, ana_end)


#import pylab
#pylab.figure()
#for s, e in zip(ana_start, ana_end):
#    pylab.axvspan(s, e, color='gray')
    
#pylab.scatter(time, stat1)
#pylab.show()

print ana_start, ana_end
print "KI", len(ana_start), len(vi), len(ki)

found = numpy.where((right-left) == 1)[0]
missed = numpy.where((right-left) == 0)[0]
ambiguous = numpy.where((right-left) > 1)[0]

# Keep only those that were in analyzed times
found = numpy.intersect1d(ki, found)
missed = numpy.intersect1d(ki, missed)



# Keep only those in unvetoed times
found = numpy.delete(found, numpy.in1d(found, vi))
missed = numpy.delete(missed, numpy.in1d(missed, vi))

found_fore = numpy.arange(0, len(inj_time), 1)[left[found]]
ifar_found = ifar[time_sorting][found_fore]


color = numpy.zeros(len(found))
ten = numpy.where(ifar_found > 10)[0]
hundred = numpy.where(ifar_found > 100)[0]
thousand = numpy.where(ifar_found > 1000)[0]

color[hundred] = 0.5
color[thousand] = 1.0

print len(found), len(missed), len(inj_time), len(numpy.where((right-left) == 1)[0])

fig = plot.figure()
mpoints = plot.scatter(inj_time[missed], dec_dist[missed], marker='x', color='black', label='missed', s=40)
points = plot.scatter(inj_time[found], dec_dist[found], c=color, s=40, 
             linewidth=0, vmin=0, vmax=1, 
             marker='o', label='found')
plot.xlabel('Time (s)')
plot.ylabel('Injected Decisive Distance')
plot.legend()
plot.grid()

urls = pycbc.results.followup.times_to_urls(inj_time[found], 2.0, args.injection_tag)
murls = pycbc.results.followup.times_to_urls(inj_time[missed], 2.0, args.injection_tag)
mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
mpld3.plugins.connect(fig, ClickLink(points, urls))
mpld3.plugins.connect(fig, ClickLink(mpoints, murls))

mpld3.save_html(fig, open(args.output_file, 'w'))


fig = plot.figure()
mpoints = plot.scatter(inj_mchirp[missed], dec_dist[missed], marker='x', color='black', label='missed', s=40)
points = plot.scatter(inj_mchirp[found], dec_dist[found], c=color, s=40, 
             linewidth=0, vmin=0, vmax=1, 
             marker='o', label='found')
plot.xlabel('Mchirp')
plot.ylabel('Injected Decisive Distance')
plot.legend()
plot.grid()

urls = pycbc.results.followup.times_to_urls(inj_time[found], 2.0, args.injection_tag)
murls = pycbc.results.followup.times_to_urls(inj_time[missed], 2.0, args.injection_tag)
mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
mpld3.plugins.connect(fig, ClickLink(points, urls))
mpld3.plugins.connect(fig, ClickLink(mpoints, murls))
oname = os.path.split(args.output_file)[0] + '/mchirp-' + os.path.split(args.output_file)[1]

mpld3.save_html(fig, open(oname, 'w'))

