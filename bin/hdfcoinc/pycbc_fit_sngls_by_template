#!/usr/bin/python

# Copyright 2016 Thomas Dent
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.

from __future__ import division

import sys, h5py
import argparse, logging

import numpy as np

from pycbc import io, events
from pycbc.events import trigger_fits as trstats
import pycbc.version

#### DEFINITIONS AND FUNCTIONS ####

stat_dict = {
    "new_snr"       : events.newsnr,
    "effective_snr" : events.effsnr,
    "snr"           : lambda snr, rchisq : snr,
    "snronchi"      : lambda snr, rchisq : snr / (rchisq ** 0.5)
}

def get_stat(statchoice, snr, rchisq, fac):
    if fac is not None:
        if statchoice not in ["new_snr", "effective_snr"]:
            raise RuntimeError("Can't use --stat-factor with this statistic!")
        return stat_dict[statchoice](snr, rchisq, fac)
    else:
        return stat_dict[statchoice](snr, rchisq)

#### MAIN ####

parser = argparse.ArgumentParser(usage="",
    description="Perform maximum-likelihood fits of single inspiral trigger"
                " distributions to various functions")

parser.add_argument("--version", action="version",
                    version=pycbc.version.git_verbose_msg)
parser.add_argument("-V", "--verbose", action="store_true",
                    help="Print extra debugging information", default=False)
parser.add_argument("--trigger-file", 
                    help="Input hdf5 file containing single triggers. "
                    "Required")
parser.add_argument("--template-file", default=None,
                    help="hdf file containing template parameters. Required")
parser.add_argument("--template-fraction-range", help="Optional, format string to"
                    " analyze part of template bank. Format is PART/NUM_PARTS",
                    default="0/1")
parser.add_argument("--veto-files", nargs='*',
                    help="Files in .xml format with veto segments to apply to "
                    "triggers before fitting")
parser.add_argument("--veto-segment-name", default=None,
                    help="Name of veto segments to apply. Optional: if not "
                    "given, all segments for a given ifo will be used")
parser.add_argument("--output", required=True,
                    help="Location for output file containing fit coefficients"
                    ".  Required")
parser.add_argument("--ifo", required=True,
                    help="Ifo producing triggers to be fitted.  Required")
parser.add_argument("--fit-function",
                    choices=["exponential", "rayleigh", "power"],
                    help="Functional form for the maximum likelihood fit")
parser.add_argument("--sngl-stat", default="new_snr",
                    choices=["snr", "snronchi", "effective_snr", "new_snr"],
                    help="Function of SNR and chisq to perform fits with")
parser.add_argument("--stat-factor", type=float,
                    help="Adjustable magic number used in some sngl "
                    "statistics.  Values commonly used: 6 for new_snr, 250 "
                    "or 50 for effective_snr")
parser.add_argument("--stat-threshold", type=float,
                    help="Only fit triggers with statistic value above this "
                    "threshold.  Required.  Typically 6-6.5")

args = parser.parse_args()

if args.verbose:
    log_level = logging.DEBUG
else:
    log_level = logging.WARN
logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)

def parse_template_range(num_templates, rangestr):
    part = int(rangestr.split('/')[0])
    pieces = int(rangestr.split('/')[1])
    tmin = int(num_templates / float(pieces) * part)
    tmax = int(num_templates / float(pieces) * (part + 1))
    return tmin, tmax

# initialize result storage
tids = []
counts = []
counts_above = []
fits = []

logging.info("Fitting above threshold %f" % args.stat_threshold)

logging.info('Opening trigger file: %s' % args.trigger_file)
trigf = io.ReadSnglsByTemplate(args.trigger_file, args.template_file,
                               args.veto_segment_name, args.veto_files)

num_templates = len(h5py.File(args.template_file, 'r')['template_hash'])
tmin, tmax = parse_template_range(num_templates, args.template_fraction_range)
trange = range(tmin, tmax)
logging.info('Analyzing template %s - %s' % (tmin, tmax-1))

for tnum in trange:
    trigs = trigf.set_template(tnum)
    snr = trigf['snr']
    chisq = trigf['chisq']
    chisq_dof = trigf['chisq_dof']
    rchisq = chisq / (2 * chisq_dof - 2)
    statv = get_stat(args.sngl_stat, snr, rchisq, args.stat_factor)

    count = len(snr)
    count_above = sum(statv >= args.stat_threshold)
    if count_above == 0:
        # 'stupid' value to indicate no data, shouldn't hurt if averaged over
        alpha = -0.01
    else:
        alpha, sig_alpha = trstats.fit_above_thresh(
                                 args.fit_function, statv, args.stat_threshold)
    tids.append(tnum)
    counts.append(count)
    counts_above.append(count_above)
    fits.append(alpha)
    if (tnum % 100 == 0): logging.info("Fitted template %i / %i" % (tnum-tmin, tmax-tmin))

outfile = h5py.File(args.output, 'w')
#ifofits = outfile.create_group(args.ifo)
# store template-dependent fit output
outfile.create_dataset("template_id", data=trange)
outfile.create_dataset("ntrigs", data=counts)
outfile.create_dataset("count_above_thresh", data=counts_above)
outfile.create_dataset("fit_coeff", data=fits)
# add some metadata to the fits
outfile.attrs.create("ifo", data=args.ifo)
outfile.attrs.create("fit_function", data=args.fit_function)
outfile.attrs.create("sngl_stat", data=args.sngl_stat)
if args.stat_factor:
    outfile.attrs.create("stat_factor", data=args.stat_factor)
outfile.attrs.create("stat_threshold", data=args.stat_threshold)

outfile.close()
logging.info('Done!')
