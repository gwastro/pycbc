import argparse, h5py, numpy, pycbc.results, pycbc.detector, sys
from pycbc.types import MultiDetOptionAction
import pycbc.pnutils, pycbc.events
import pycbc.version
from itertools import combinations


parser = argparse.ArgumentParser()
parser.add_argument("--version", action="version", version=pycbc.version.git_verbose_msg)
parser.add_argument('--injection-file', help='HDF File containing the matched injections')
parser.add_argument('--single-trigger-files', nargs='*', help="HDF format single detector trigger files", action=MultiDetOptionAction)
parser.add_argument('--verbose', action='count')
parser.add_argument('--show-missed', action='store_true')
parser.add_argument('--output-file')
args = parser.parse_args()

f = h5py.File(args.injection_file,'r')
inj = f['injections']
found_cols, found_names, found_formats = [], [], []

if args.show_missed:
    title = "Missed Injections"
    idx = f['missed/after_vetoes'][:]
else:
    title = "Found Injections"
    found = f['found_after_vetoes']
    idx = found['injection_index'][:]
    if('detector_1' in f.attrs):
        tdiff = (found['time1'][:] - found['time2'][:]) * 1000
        tdiff_str = '%s - %s time (ms)' % (f.attrs['detector_1'], f.attrs['detector_2'])
        ids = {f.attrs['detector_1']: found['trigger_id1'][:],
               f.attrs['detector_2']: found['trigger_id2'][:],}
        found_cols = [tdiff, found['stat'], found['ifar'], found['ifar_exc']]
        found_names = [tdiff_str, 'Ranking Stat.', 'Inc. IFAR (yrs)', 'Exc. IFAR']
        found_formats =  ['##.##', '##.##', '##', '##']

    else:
        detectors = ['L1','H1','V1','K1','I1']
        keys = f['found_after_vetoes'].keys()
        detectors_used = []
        found = f['found_after_vetoes']
        for det in detectors:
            if(det in keys):
                detectors_used.append(det)
        detectors_two_combinations= numpy.array(list(combinations(detectors_used,2)))
        tdiff = []
        tdiff_str = []
        tdiff_format =[]
        for i in range(len(detectors_two_combinations)):
            time_1 = found[detectors_two_combinations[i,0]+'/time'][:]
            time_2 = found[detectors_two_combinations[i,1]+'/time'][:]
            tdiff_1 = ['{:.2f}'.format((t1 - t2)*1000) if t1 > 0 and t2 > 0 else 'N/A' for t1,t2 in zip(time_1, time_2)]
            tdiff.append(tdiff_1)
            tdiff_head= '%s - %s time (ms)' % (detectors_two_combinations[i,0], detectors_two_combinations[i,1])
            tdiff_str.append(tdiff_head)
            tdiff_format.append('##.##')
        ids = {detector:found[detector+'/trigger_id'][:] for detector in detectors_used}
    
        found_cols = tdiff + [numpy.round(found['stat'],2), numpy.round(found['fap_exc'],2), numpy.round(found['ifar_exc'],2)]
        found_names = tdiff_str + ['Ranking Stat.', 'Exc. FAP', 'Exc. IFAR']
        found_formats =  tdiff_format + ['##.##', '##', '##']


    if args.single_trigger_files:
        for ifo in args.single_trigger_files:
            f = h5py.File(args.single_trigger_files[ifo], 'r')[ifo]
            i = ids[ifo]
            snr = f['snr'][:][i]
            chisq = f['chisq'][:][i] / (2 * f['chisq_dof'][:][i] - 2)
            newsnr = pycbc.events.ranking.newsnr(snr, chisq)
            
            found_names += ["%s SNR" % ifo, "CHISQ", "NewSNR"]
            found_cols += [numpy.round(snr,2), numpy.round(chisq,2), numpy.round(newsnr,2)]
            found_formats += ['##.##', '##.##', '##.##']

eff_dist = {'eff_dist_l':'Eff Dist(L)','eff_dist_h':'Eff Dist(H)','eff_dist_v':'Eff Dist(V)',
            'eff_dist_k':'Eff Dist(K)','eff_dist_i':'Eff Dist(I)'}
keys = inj.keys()
eff_dist_str = []
eff_distance = []
eff_dist_format = []
for dist in eff_dist :
    if(dist in keys):
        eff_distance.append(numpy.round(inj[dist][:][idx],2))
        eff_dist_str.append(eff_dist[dist])
        eff_dist_format.append('##.##')
                
dec_dist = numpy.max(eff_distance,0)
m1, m2 = inj['mass1'][:][idx], inj['mass2'][:][idx]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)
dec_chirp_dist = pycbc.pnutils.chirp_distance(dec_dist, mchirp)

columns = [numpy.round(dec_chirp_dist,2), numpy.round(inj['end_time'][:][idx],2), 
           numpy.round(m1,2), numpy.round(m2,2), numpy.round(mchirp,2), numpy.round(eta,2),
           numpy.round(inj['spin1x'][:][idx],2), numpy.round(inj['spin1y'][:][idx],2), numpy.round(inj['spin1z'][:][idx],2),
           numpy.round(inj['spin2x'][:][idx],2), numpy.round(inj['spin2y'][:][idx],2), numpy.round(inj['spin2z'][:][idx],2),
           numpy.round(inj['distance'][:][idx],2)] + eff_distance + found_cols
         
names = ['DChirp Dist', 'Inj Time', 'Mass1', 'Mass2', 'Mchirp', 'Eta',
         's1x', 's1y', 's1z',
         's2x', 's2y', 's2z', 
         'Dist']  + eff_dist_str + found_names 

format_strings = ['##.##', '##.##', '##.##', '##.##', '##.##', '##.##',
                  '##.##', '##.##', '##.##',
                  '##.##', '##.##', '##.##',
                  '##.##'] + eff_dist_format +  found_formats 
columns = numpy.array(columns)
html_table = pycbc.results.html_table(columns, names, 
                                 format_strings=format_strings, 
                                 page_size=20)
                                 
kwds = { 'title' : title, 
        'caption' : "A table of %s and their coincident statistic information." % title.lower(),
        'cmd' :' '.join(sys.argv), }
pycbc.results.save_fig_with_metadata(str(html_table), args.output_file, **kwds)
