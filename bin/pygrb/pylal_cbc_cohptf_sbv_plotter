#!/usr/bin/env python

#Copyright (C) 2019 Ian W. Harry, Gino Contestabile, Francesco Pannarale

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

# set up timer
import time
start = int(time.time()*10**6)
elapsed_time = lambda: int(time.time()*10**6-start)

import sys
import glob
import numpy
import os,matplotlib,copy
matplotlib.use('Agg')
from matplotlib import rc
import scipy.stats
from optparse import OptionParser
from glue import segments
from lal import LIGOTimeGPS
from glue.ligolw import lsctables,table,utils,ligolw
import pycbc.version
from pycbc.results.pygrb_plotting_utils import sbv_plot_handler
#### TODO: remove these dependencies!
from pylal import MultiInspiralUtils
from pylal.dq import dqSegmentUtils
from pylal.coh_PTF_pyutils import get_bestnr, calculate_contours, readSegFiles, get_det_response
import matplotlib.pyplot as plt
####

__author__  = "Ian Harry <ian.harry@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pylal_cbc_cohptf_sbv_plotter"

# =============================================================================
# Create filename tags for zoomed and non-zoomed plots 
# =============================================================================

def generate_raw_zoom_tags(run_tag, plot_tag):
  fig_tag_raw = "%s_%s" % (run_tag, plot_tag) 
  fig_tag_zoom = "%s_%s" % (fig_tag_raw, "zoom")

  return [fig_tag_raw, fig_tag_zoom]

# =============================================================================
# Extract trigger or injection data
# =============================================================================
#def get_data(trigs, ifos):
#
#  # Work out if using sngl chisqs
#  ifoAtt = { 'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t' } 
#  i = ifoAtt[ifos[0]]
#  sngl_chisq      = 'chisq_%s' % i\
#                    in lsctables.MultiInspiralTable.loadcolumns
#  sngl_bank_chisq = 'bank_chisq_%s' % i\
#                    in lsctables.MultiInspiralTable.loadcolumns
#  sngl_cont_chisq = 'cont_chisq_%s' % i\
#                    in lsctables.MultiInspiralTable.loadcolumns
#  
#  # Initiate amplitude generator
#  numAmp  = 4
#  amplitudes = xrange(1,numAmp+1)
#  
#  # Set basic data
#  trigTime      = numpy.asarray(trigs.get_end())
#  trigSNR       = numpy.asarray(trigs.get_column('snr'))
#  trigBestNR    = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
#                             null_thresh=null_thresh,snr_threshold=snrThresh,\
#                             sngl_snr_threshold = snglSnrThresh,\
#                             chisq_threshold = newSnrThresh,\
#                             null_grad_thresh = nullGradThresh,\
#                             null_grad_val = nullGradVal) for t in trigs]
#  trigBestNR    = numpy.array(trigBestNR)
#  trigNullSNR   = numpy.asarray(trigs.get_null_snr())
#  trigNullstat  = numpy.asarray(trigs.get_column('null_statistic'))
#  trigTraceSNR  = numpy.asarray(trigs.get_column('null_stat_degen'))
#  trigMchirp    = numpy.asarray(trigs.get_column('mchirp'))
#  
#  # Get chisq data
#  trigChiSquare = numpy.asarray(trigs.get_column('chisq'))
#  trigBankVeto  = numpy.asarray(trigs.get_column('bank_chisq')) 
#  trigAutoVeto  = numpy.asarray(trigs.get_column('cont_chisq'))
#  numpy.putmask(trigChiSquare, trigChiSquare==0, 0.005)
#  numpy.putmask(trigBankVeto, trigBankVeto==0, 0.005)
#  numpy.putmask(trigAutoVeto, trigAutoVeto==0, 0.005)
#   
#  # Get single detector data
#  trigCoincSNR  = (trigs.get_column('coinc_snr'))
#  trigIfoSNR    = dict((ifo, trigs.get_sngl_snr(ifo)) for ifo in ifos)
#  tmp           = numpy.sort(trigIfoSNR.values(), 0)
#  if len(ifos) > 0:
#    trigFirstSNR  = tmp[-1,:]
#  if len(ifos) > 1:
#    trigSecondSNR = tmp[-2,:]
#  if len(ifos) > 2:
#    trigThirdSNR  = tmp[-3,:]
#  if sngl_bank_chisq:
#    trigIfobankCS = trigs.get_sngl_bank_chisqs(ifos)
#    trigIfobankCS = format_single_chisqs(trigIfobankCS, trigs, ifos):
#  if sngl_cont_chisq:
#    trigIfoautoCS = trigs.get_sngl_cont_chisqs(ifos)
#    trigIfoautoCS = format_single_chisqs(trigIfoautoCS, trigs, ifos):
#  if sngl_chisq:
#    trigIfostanCS = trigs.get_sngl_chisqs(ifos)
#    trigIfostanCS = format_single_chisqs(trigIfostanCS, trigs, ifos):
#  trigSigma  = trigs.get_sigmasqs()
#  trigSigmaTot = numpy.zeros(numtrigs)
#  
#  # Get amplitude terms
#  trigAmp         = dict((amp,\
#                          numpy.asarray(trigs.get_column('amp_term_%d' % amp)))\
#                          for amp in amplitudes)
#  trigRelAmp1     = numpy.sqrt((trigAmp[1]**2 + trigAmp[2]**2)/\
#                               (trigAmp[3]**2 + trigAmp[4]**2))
#  trigGammaR      = trigAmp[1] - trigAmp[4]
#  trigGammaI      = trigAmp[2] + trigAmp[3]
#  trigDeltaR      = trigAmp[1] + trigAmp[4]
#  trigDeltaI      = trigAmp[3] - trigAmp[2]
#  trigNorm1       = trigDeltaR*trigDeltaR + trigDeltaI*trigDeltaI
#  trigNorm2       = trigGammaR*trigGammaR + trigGammaI*trigGammaI
#  trigNorm3       = ((trigNorm1**0.25) + (trigNorm2**0.25))**2
#  trigAmpPlus     = (trigNorm1)**0.5 + (trigNorm2)**0.5
#  trigAmpCross    = abs((trigNorm1)**0.5 - (trigNorm2)**0.5)
#  trigRelAmp2     = trigAmpPlus/trigAmpCross
#  trigInclination = trigAmpCross/trigNorm3
#
#  return

# =============================================================================
# Format single detector chi-square data as numpy array and floor at 0.005
# =============================================================================

def format_single_chisqs(trigIfoCS, trigs, ifos):
  for ifo in ifos:
    trigIfoCS[ifo] = numpy.asarray(trigIfoCS[ifo])
    numpy.putmask(trigIfoCS[ifo], trigIfoCS[ifo]==0, 0.005)

  return trigIfoCS

# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():

  usage = """usage: %prog [options] 
  
pylal_cbc_cohptf_sbv_plotter will calculate all signal based vetoes and the final detection statistics, whilst plotting a whole bunch of stuff. Required arguments

--trig-file
--grb-name
"""

  parser = OptionParser(usage, version=__version__)

  parser.add_option("-v", "--verbose", action="store_true", default=False,\
                    help="verbose output, default: %default")

  parser.add_option("-t", "--trig-file", action="store", type="string",\
                    default=None, help="The location of the trigger file")

  parser.add_option("-I", "--inj-file", action="store", type="string",\
                    default=None, help="The location of the injection file")

  parser.add_option("-n", "--grb-name", action="store", type="string",\
                    default=None, help="Name of the GRB such as 090802")

  parser.add_option("-o", "--output-path", action="store", type="string",\
                    default=os.getcwd(), help="output directory, "+\
                                              "default: %default")

  parser.add_option("-Q", "--chisq-index", action="store", type="float",\
                    default=4.0, help="chisq_index for newSNR calculation, "+\
                                      "default: %default")

  parser.add_option("-N", "--chisq-nhigh", action="store", type="float",\
                    default=3.0, help="nhigh for newSNR calculation, "+\
                                      "default: %default")

  parser.add_option("-a", "--segment-dir", action="store", type="string",\
                    help="directory holding buffer, on and off source "+\
                         "segment files.")

  parser.add_option("-B", "--sngl-snr-threshold", action="store", type="float",\
                    default=4.0, help="Single detector SNR threshold, the"+\
                    "two most sensitive detectors should have SNR above this"+\
                    " default: %default")

  parser.add_option("-d", "--snr-threshold", action="store", type="float",\
                    default=6.0, help="SNR threshold for recording triggers,"+\
                                      " default: %default")

  parser.add_option("-c", "--newsnr-threshold", action="store", type="float",\
                    default=None, help="NewSNR threshold for calculating the "+\
                    "chisq of triggers (based on value of auto and bank chisq"+\
                    " values. By default will take the same value as "+\
                    "snr-threshold")

  parser.add_option("-A", "--null-snr-threshold", action="store",\
                    type="string", default="4.25,6",\
                    help="comma separated lower,higher null SNR thresholds, "+\
                         " for null SNR cut, default: \"%default\"")

  parser.add_option("-C", "--null-grad-thresh", action="store", type="float",\
                    default=20., help="Threshold above which to increase the,"+\
                    "values of the null SNR cut. default: %default")

  parser.add_option("-D", "--null-grad-val", action="store", type="float",\
                    default=0.2, help="Rate the null SNR cut will increase"+\
                    "above the threshold. default: %default")

  parser.add_option("-l", "--veto-directory",action="store",type="string",\
                    default=None,\
                    help="The location of the CATX veto files")

  parser.add_option("-b", "--veto-category",action="store",type="int",\
                   default=None, help="Apply vetoes up to this level inclusive")

  parser.add_option( "-M", "--max-chirp-mass", action="store", type="float",\
                     default=8.0,\
                     help="maximum allowed chirp mass, default %default" )

  (opts,args) = parser.parse_args()

  if not opts.trig_file:
    parser.error("must provide trig file")

  if not opts.grb_name:
    parser.error("must provide --grb-name")

  if not opts.segment_dir:
    parser.error("must provide --segment-dir")

  if opts.veto_directory and not opts.veto_category:
    parser.error("Must supply veto category if applying vetoes")

  if not opts.newsnr_threshold:
    opts.newsnr_threshold = opts.snr_threshold

  return opts, args


# =============================================================================
# Main script starts here
# =============================================================================

# Read in options

opts, args = parse_command_line()

trigFile  = os.path.abspath(opts.trig_file)
injFile   = None
if opts.inj_file:
  injFile = os.path.abspath(opts.inj_file)
tag       = 'GRB%s' % opts.grb_name
outdir    = os.path.abspath(opts.output_path)
segdir    = opts.segment_dir
chisq_index = opts.chisq_index
chisq_nhigh = opts.chisq_nhigh
null_thresh = map(float, opts.null_snr_threshold.split(','))
max_mchirp = opts.max_chirp_mass
vetoFiles = []
if opts.veto_directory:
  vetoString = ','.join([str(i) for i in range(2,opts.veto_category+1)])
  vetoFiles = glob.glob(opts.veto_directory +'/*CAT[%s]*.xml' %(vetoString))
snrThresh = opts.snr_threshold
snglSnrThresh = opts.sngl_snr_threshold
newSnrThresh = snglSnrThresh
nullGradThresh = opts.null_grad_thresh
nullGradVal    = opts.null_grad_val
verbose   = opts.verbose

if verbose:
  sys.stdout.write("Imported and ready to go at %d.\n" % elapsed_time())

# Set output directory
if not os.path.isdir(outdir):
  os.makedirs(outdir)

# Get rcParams
rc('font', size=14)
#makePaperPlots() # in coh_PTF_pyutils.py

#
# Load triggers
#

if verbose:
  sys.stdout.write("Loading triggers...\n")

# Load file
xmldoc = utils.load_filename(trigFile, gz=trigFile.endswith("gz"), contenthandler = lsctables.use_in(ligolw.LIGOLWContentHandler))
searchSumm = table.get_table(xmldoc, lsctables.SearchSummaryTable.tableName)

# Extract IFOS
ifos = sorted(map(str, searchSumm[0].get_ifos()))
ifoAtt = { 'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t' } 

tmp, slideDict, segmentDict = \
        MultiInspiralUtils.ReadMultiInspiralTimeSlidesFromFiles([trigFile])
numSlides = len(slideDict)
lsctables.MultiInspiralTable.loadcolumns =\
        [slot for slot in tmp[0].__slots__ if hasattr(tmp[0], slot)]
trigs = lsctables.New(lsctables.MultiInspiralTable,\
        columns=lsctables.MultiInspiralTable.loadcolumns)

# Construct veto list
vetoes = segments.segmentlistdict()
for ifo in ifos:
  vetoes[ifo] = segments.segmentlist()

if vetoFiles:
  for file in vetoFiles:
    ifo = os.path.basename(file)[:2]
    if ifo in ifos:
      # This returns a coalesced list of the vetoes
      tmpVetoSegs = dqSegmentUtils.fromsegmentxml(open(file,'r'))
      for entry in tmpVetoSegs:
        vetoes[ifo].append(entry)

for ifo in ifos:
  vetoes[ifo].coalesce()

for slideID in range(numSlides):
  slidVetoes = copy.deepcopy(vetoes)
  for ifo in ifos:
    slidVetoes[ifo].shift(-slideDict[slideID][ifo])

  # Load triggers
  vets = slidVetoes.union(slidVetoes.keys())
  trigs.extend(t for t in tmp.veto(vets) if int(t.time_slide_id) == slideID)

numtrigs = len(trigs)
if numtrigs<1:
  sys.stderr.write("WARNING: No triggers found.")
elif numtrigs >= 1 and verbose:
  sys.stdout.write("%d triggers found at %d.\n"\
                   % (numtrigs, elapsed_time()))


#
# Load injections
#

if injFile:
  if verbose:
    sys.stdout.write("\nLoading injections...\n")
  xmldoc = utils.load_filename(injFile, gz=injFile.endswith("gz"), contenthandler = lsctables.use_in(ligolw.LIGOLWContentHandler))
  tmp = table.get_table(xmldoc, lsctables.MultiInspiralTable.tableName)
  injs = lsctables.New(lsctables.MultiInspiralTable,\
                      columns=lsctables.MultiInspiralTable.loadcolumns)
  injs.extend(t for t in tmp if t.get_end() not in vetoes)
  if verbose:
    sys.stdout.write("%d injections found at %d.\n"\
                     % (len(injs), elapsed_time()))

#
# Extract trigger data
#


# Work out if using sngl chisqs
i = ifoAtt[ifos[0]]
sngl_chisq      = 'chisq_%s' % i\
                  in lsctables.MultiInspiralTable.loadcolumns
sngl_bank_chisq = 'bank_chisq_%s' % i\
                  in lsctables.MultiInspiralTable.loadcolumns
sngl_cont_chisq = 'cont_chisq_%s' % i\
                  in lsctables.MultiInspiralTable.loadcolumns

# Initiate amplitude generator
numAmp  = 4
amplitudes = xrange(1,numAmp+1)

# Set basic data
trigTime      = numpy.asarray(trigs.get_end())
trigSNR       = numpy.asarray(trigs.get_column('snr'))
trigBestNR    = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
                           null_thresh=null_thresh,snr_threshold=snrThresh,\
                           sngl_snr_threshold = snglSnrThresh,\
                           chisq_threshold = newSnrThresh,\
                           null_grad_thresh = nullGradThresh,\
                           null_grad_val =  nullGradVal ) for t in trigs]
trigBestNR    = numpy.array(trigBestNR)
trigNullSNR   = numpy.asarray(trigs.get_null_snr())
trigNullstat  = numpy.asarray(trigs.get_column('null_statistic'))
trigTraceSNR  = numpy.asarray(trigs.get_column('null_stat_degen'))
trigMchirp    = numpy.asarray(trigs.get_column('mchirp'))

# Get chisq data
trigChiSquare = numpy.asarray(trigs.get_column('chisq'))
trigBankVeto  = numpy.asarray(trigs.get_column('bank_chisq')) 
trigAutoVeto  = numpy.asarray(trigs.get_column('cont_chisq'))
numpy.putmask(trigChiSquare, trigChiSquare==0, 0.005)
numpy.putmask(trigBankVeto, trigBankVeto==0, 0.005)
numpy.putmask(trigAutoVeto, trigAutoVeto==0, 0.005)
 
# Get single detector data
trigCoincSNR  = (trigs.get_column('coinc_snr'))
trigIfoSNR    = dict((ifo, trigs.get_sngl_snr(ifo)) for ifo in ifos)
tmp           = numpy.sort(trigIfoSNR.values(), 0)
if len(ifos) > 0:
  trigFirstSNR  = tmp[-1,:]
if len(ifos) > 1:
  trigSecondSNR = tmp[-2,:]
if len(ifos) > 2:
  trigThirdSNR  = tmp[-3,:]
if sngl_bank_chisq:
  trigIfobankCS = trigs.get_sngl_bank_chisqs(ifos)
  trigIfobankCS = format_single_chisqs(trigIfobankCS, trigs, ifos)
if sngl_cont_chisq:
  trigIfoautoCS = trigs.get_sngl_cont_chisqs(ifos)
  trigIfoautoCS = format_single_chisqs(trigIfoautoCS, trigs, ifos)
if sngl_chisq:
  trigIfostanCS = trigs.get_sngl_chisqs(ifos)
  trigIfostanCS = format_single_chisqs(trigIfostanCS, trigs, ifos)
trigSigma  = trigs.get_sigmasqs()
trigSigmaTot = numpy.zeros(numtrigs)

# Get amplitude terms
trigAmp         = dict((amp,\
                        numpy.asarray(trigs.get_column('amp_term_%d' % amp)))\
                        for amp in amplitudes)
trigRelAmp1     = numpy.sqrt((trigAmp[1]**2 + trigAmp[2]**2)/\
                             (trigAmp[3]**2 + trigAmp[4]**2))
trigGammaR      = trigAmp[1] - trigAmp[4]
trigGammaI      = trigAmp[2] + trigAmp[3]
trigDeltaR      = trigAmp[1] + trigAmp[4]
trigDeltaI      = trigAmp[3] - trigAmp[2]
trigNorm1       = trigDeltaR*trigDeltaR + trigDeltaI*trigDeltaI
trigNorm2       = trigGammaR*trigGammaR + trigGammaI*trigGammaI
trigNorm3       = ((trigNorm1**0.25) + (trigNorm2**0.25))**2
trigAmpPlus     = (trigNorm1)**0.5 + (trigNorm2)**0.5
trigAmpCross    = abs((trigNorm1)**0.5 - (trigNorm2)**0.5)
trigRelAmp2     = trigAmpPlus/trigAmpCross
trigInclination = trigAmpCross/trigNorm3

# Get antenna response based parameters
trigLongitude = numpy.degrees(trigs.get_column('ra'))
trigLatitude  = numpy.degrees(trigs.get_column('dec'))
fResp = dict((ifo, numpy.empty(numtrigs)) for ifo in ifos)
for i in xrange(numtrigs):
  # Calculate fResp for each IFO is we haven't done so already
  fPlus,fCross     = get_det_response(trigLongitude[i], trigLatitude[i],\
                                      trigTime[i])
  for ifo in ifos:
    fResp[ifo][i]    = sum(numpy.array([fPlus[ifo], fCross[ifo]])**2)
    trigSigmaTot[i] += trigSigma[ifo][i] * fResp[ifo][i]

for ifo in ifos:
  fResp[ifo] = fResp[ifo].mean()

# Normalise trigSigma
trigSigmaTot = numpy.array(trigSigmaTot)
for ifo in ifos:
  trigSigma[ifo] = numpy.asarray(trigSigma[ifo]) / trigSigmaTot

trigSigmaMean = {}
trigSigmaMax  = {}
trigSigmaMin  = {}
for ifo in ifos:
  try:
    trigSigmaMean[ifo] = trigSigma[ifo].mean()
    trigSigmaMax[ifo]  = trigSigma[ifo].max()
    trigSigmaMin[ifo]  = trigSigma[ifo].min()
  except ValueError:
    trigSigmaMean[ifo] = 0
    trigSigmaMax[ifo]  = 0
    trigSigmaMin[ifo]  = 0

if verbose:
  sys.stdout.write("Trigger parameters extracted at %d\n"\
                   % elapsed_time())

#
# Get injection data
#

# Initialize all injection related variables
injTime = None
injSNR = numpy.array(None)
injBestNR = None
injNullSNR = None
injNullstat = None
injTraceSNR = None
injChiSquare = numpy.array(None)
injBankVeto = None
injAutoVeto = None
injCoincSNR = None
injIfoSNR = dict((ifo, None) for ifo in ifos)
injFirstSNR = None
injSecondSNR = None
injThirdSNR = None
injIfobankCS = dict((ifo, None) for ifo in ifos)
injIfoautoCS = dict((ifo, None) for ifo in ifos)
injIfostanCS = dict((ifo, None) for ifo in ifos)
injRelAmp1 = None
injNorm3 = None
injRelAmp2 = None
injInclination = None

# Fill in injection related variables (if injection files exist)
if injFile:

  # Get basics
  injTime      = numpy.asarray(injs.get_end())
  injSNR       = numpy.asarray(injs.get_column('snr'))
  injBestNR    = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
                           null_thresh=null_thresh,snr_threshold=snrThresh,\
                           sngl_snr_threshold = snglSnrThresh,\
                           chisq_threshold = newSnrThresh,\
                           null_grad_thresh = nullGradThresh,\
                           null_grad_val = nullGradVal) for t in injs]
  injBestNR    = numpy.array(injBestNR)
  injNullSNR   = numpy.asarray(injs.get_null_snr())
  injNullstat  = numpy.asarray(injs.get_column('null_statistic'))
  injTraceSNR  = numpy.asarray(injs.get_column('null_stat_degen'))

  # Get chisq data
  injChiSquare = numpy.asarray(injs.get_column('chisq'))
  injBankVeto  = numpy.asarray(injs.get_column('bank_chisq'))
  injAutoVeto  = numpy.asarray(injs.get_column('cont_chisq'))

  # Get single detector data
  injCoincSNR  = numpy.asarray(injs.get_column('coinc_snr'))
  injIfoSNR    = dict((ifo, injs.get_sngl_snr(ifo)) for ifo in ifos)
  tmp          = numpy.sort(injIfoSNR.values(), 0)
  if len(ifos) > 0:
    injFirstSNR  = tmp[-1,:]
  if len(ifos) > 1:
    injSecondSNR = tmp[-2,:]
  if len(ifos) > 2:
    injThirdSNR  = tmp[-3,:]
  if sngl_bank_chisq:
    injIfobankCS = injs.get_sngl_bank_chisqs(ifos)
  if sngl_cont_chisq:
    injIfoautoCS = injs.get_sngl_cont_chisqs(ifos)
  if sngl_chisq:
    injIfostanCS = injs.get_sngl_chisqs(ifos)
  #injSigma  = injs.get_sigmasqs()

  # get amplitude terms
  injAmp    = dict((amp, numpy.asarray(injs.get_column('amp_term_%d' % amp)))\
                   for amp in amplitudes)
  injRelAmp1     = numpy.sqrt((injAmp[1]**2 + injAmp[2]**2)/\
                              (injAmp[3]**2 + injAmp[4]**2))
  injGammaR      = injAmp[1] - injAmp[4]
  injGammaI      = injAmp[2] + injAmp[3]
  injDeltaR      = injAmp[1] + injAmp[4]
  injDeltaI      = injAmp[3] - injAmp[2]
  injNorm1       = injDeltaR*injDeltaR + injDeltaI*injDeltaI
  injNorm2       = injGammaR*injGammaR + injGammaI*injGammaI
  injNorm3       = ((injNorm1**0.25) + (injNorm2**0.25))**2
  injAmpPlus     = (injNorm1)**0.5 + (injNorm2)**0.5
  injAmpCross    = abs((injNorm1)**0.5 - (injNorm2)**0.5)
  injRelAmp2     = injAmpPlus/injAmpCross
  injInclination = injAmpCross/injNorm3

  if verbose:
    sys.stdout.write("Injection parameters extracted at %d\n"\
                     % elapsed_time())

#
# Generate plots
#

if verbose:
  sys.stdout.write("\nPlotting...\n")

ptfcolormap = plt.cm.spring
ptfcolormap.set_over('g')
     
new_snrs = [5.5,6,6.5,7,8,9,10,11]
try:
  cont_value = new_snrs.index(newSnrThresh)
except ValueError:
  new_snrs.append(newSnrThresh)
  cont_value = -1
bank_conts, auto_conts,chi_conts,null_cont,snr_vals, colors =\
    calculate_contours(q=chisq_index, n=chisq_nhigh,new_snrs=new_snrs,\
                       new_snr_thresh=newSnrThresh,\
                       null_thresh=null_thresh[-1],\
                       null_grad_snr=nullGradThresh,\
                       null_grad_val=nullGradVal,\
                       chisq_dof=trigs[0].chisq_dof,\
                       bank_chisq_dof=trigs[0].bank_chisq_dof,\
                       cont_chisq_dof=trigs[0].cont_chisq_dof)

# Reset times
segs = readSegFiles(segdir)
grbTime = segs['on'][1] - 1
start = int(min(trigTime)) - grbTime
end   = int(max(trigTime)) - grbTime
duration = end-start
start -= duration*0.05
end += duration*0.05
trigTime = [t-grbTime for t in trigTime]
if injFile:
  injTime  = [t-grbTime for t in injTime]

# Plotting starts here: this is where we have WIP

# Plot coherent SNR versus time
fig_tag = '%s_%s' % (tag, "triggers_vs_time") 
for injF in [None, injFile]:
  sbv_plot_handler(trigTime, trigSNR, injTime, injSNR, injF, \
              "Time since %s" % (grbTime), "Coherent SNR", outdir, fig_tag,
              xlims=[start,end], use_logs=False, verbose=verbose)

# Plot BestNR versus time
fig_tag = '%s_%s' % (tag, "bestnr_vs_time") 
for injF in [None, injFile]:
  sbv_plot_handler(trigTime, trigBestNR, injTime, injBestNR, injF, \
              "Time since %s" % (grbTime), "BestNR", outdir, fig_tag,
              xlims=[start,end], use_logs=False, verbose=verbose)

# Plot single IFO SNR versus time
for ifo in ifos:
  fig_tag = '%s_%s_%s' % (tag, ifo, "triggers_vs_time") 
  for injF in [None, injFile]:
    sbv_plot_handler(trigTime, trigIfoSNR[ifo], injTime, injIfoSNR[ifo], injF, \
                "Time since %s" % (grbTime), "%s SNR" % (ifo), outdir, fig_tag,
                xlims=[start,end], use_logs=False, verbose=verbose)

# Coherent SNR versus null stat plots: non-zoomed and zoomed 
null_stat_colors = ['k-', 'g-', 'm-']
fig_tag_list = generate_raw_zoom_tags(tag, "null_stat_vs_snr")
null_stat_conts_1 = [null_cont]
null_stat_conts_2 = [null_cont]
null_thresh_width = null_thresh[1] - null_thresh[0]
null_stat_conts_2.append(numpy.asarray(null_cont) - null_thresh_width)
if null_thresh_width > 1:
   null_stat_conts_2.append(numpy.asarray(null_cont) - null_thresh_width + 1)
null_stat_conts_list = [null_stat_conts_1, null_stat_conts_2]
xlims_list = [None, [6,30]]
ylims_list = [None, [0,30]]
for fig_tag, null_stat_conts, xlims, ylims in \
             zip(fig_tag_list, null_stat_conts_list, xlims_list, ylims_list):
  sbv_plot_handler(trigSNR, trigNullstat, injSNR, injNullstat, injFile, \
                   "Coherent SNR", "Null statistic", outdir, fig_tag, \
                   snr_vals=snr_vals, conts=null_stat_conts, \
                   colors=null_stat_colors, xlims=xlims, ylims=ylims, \
                   use_logs=False, verbose=verbose)


# Coherent SNR versus overwhitened null stat plots: non-zoomed and zoomed
fig_tag_list = generate_raw_zoom_tags(tag, "null_stat2_vs_snr")
null_stat_conts_1 = [null_cont]
null_stat_conts_2 = [null_cont]
null_thresh_width = null_thresh[1] - null_thresh[0]
null_stat_conts_2.append(numpy.asarray(null_cont) - null_thresh_width)
if null_thresh_width > 1:
   null_stat_conts_2.append(numpy.asarray(null_cont) - null_thresh_width + 1)
null_stat_conts_list = [null_stat_conts_1, null_stat_conts_2]
xlims_list = [None, [6,30]]
ylims_list = [None, [0,30]]
for fig_tag, null_stat_conts, xlims, ylims in \
             zip(fig_tag_list, null_stat_conts_list, xlims_list, ylims_list):
  sbv_plot_handler(trigSNR, trigNullSNR, injSNR, injNullSNR, injFile, \
                   "Coherent SNR", "Overwhitened null statistic", outdir, fig_tag, \
                   snr_vals=snr_vals, conts=null_stat_conts, \
                   shade_cont_value=0, colors=null_stat_colors, \
                   xlims=xlims, ylims=ylims, use_logs=False, verbose=verbose)


# Coherent SNR versus coinc SNR plots: non-zoomed and zoomed
fig_tag_list = generate_raw_zoom_tags(tag, "coinc_snr_vs_snr")
xlims_list = [None, [6,30]]
ylims_list = [None, [4,30]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  sbv_plot_handler(trigSNR, trigCoincSNR, injSNR, injCoincSNR, injFile, \
                   "Coherent SNR", "Coincidence SNR", outdir, fig_tag, \
                   snr_vals=[4,30], conts=[[4,30]], colors=['g-'], \
                   xlims=xlims, ylims=ylims, use_logs=False, verbose=verbose)


# Coherent SNR versus traceSNR: non-zoomed and zoomed
maxSNR = trigSNR.max()
if injFile and injSNR.size and injSNR.max() > maxSNR:
  maxSNR = injSNR.max()
zoomSNR = numpy.arange(0.01,maxSNR,0.01)

fig_tag_list = generate_raw_zoom_tags(tag, "trace_snr_vs_snr")
xlims_list = [None, [6,30]]
ylims_list = [None, [4,30]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  sbv_plot_handler(trigSNR, trigTraceSNR, injSNR, injTraceSNR, injFile, \
                   "Coherent SNR", "Trace SNR", outdir, fig_tag, \
                   snr_vals=[6,30], conts=[[6,27.5]], colors=['g-'], \
                   xlims=xlims, ylims=ylims, use_logs=False, verbose=verbose)

# Plot coincident SNR versus trace SNR
fig_tag_list = generate_raw_zoom_tags(tag, "trace_snr_vs_coinc_snr")
xlims_list = [None, [0,30]]
ylims_list = [None, [0,30]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  sbv_plot_handler(trigCoincSNR, trigTraceSNR, injCoincSNR, injTraceSNR, injFile, \
            "Coincidence SNR", "Trace SNR", outdir, fig_tag, \
            use_logs=False, xlims=xlims, ylims=ylims, verbose=verbose)
 
# Plot coherent SNR versus bank veto
fig_tag_list = generate_raw_zoom_tags(tag, "bank_veto_vs_snr")
xlims_list = [[6,1000], [6,50]]
ylims_list = [None, [1,2000]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
  sbv_plot_handler(trigSNR, trigBankVeto, injSNR, injBankVeto, injFile, \
            "Coherent SNR", "Bank Veto", outdir, fig_tag, \
            snr_vals=snr_vals, conts=bank_conts, \
            shade_cont_value=cont_value, colors=colors, vert_spike=True, \
            xlims=xlims, ylims=ylims, verbose=verbose)
 
# Plot coherent SNR versus auto veto
fig_tag_list = generate_raw_zoom_tags(tag, "auto_veto_vs_snr")
xlims_list = [None, [6,30]]
ylims_list = [None, [10,20000]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 
  sbv_plot_handler(trigSNR, trigAutoVeto, injSNR, injAutoVeto, injFile, \
            "Coherent SNR", "Auto Veto", outdir, fig_tag, \
            snr_vals=snr_vals, conts=auto_conts, \
            shade_cont_value=cont_value,xlims=xlims, ylims=ylims, colors=colors, vert_spike=True, \
            verbose=verbose)

# Plot coherent SNR versus chisq veto
fig_tag_list = generate_raw_zoom_tags(tag, "chi_square_vs_snr")
xlims_list = [[6,1000], [0,50]]
ylims_list = [[1,10000], [1,2000]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 
  sbv_plot_handler(trigSNR[trigBestNR!=0], trigChiSquare[trigBestNR!=0], \
            injSNR[injBestNR!=0], injChiSquare[injBestNR!=0], injFile, \
            "Coherent SNR", "Chi Square", outdir, fig_tag, \
            snr_vals=snr_vals, conts=chi_conts, vert_spike=True, \
            shade_cont_value=cont_value, colors=colors, \
            xlims=xlims, ylims=ylims, \
            verbose=verbose)
          

# Plot coherent SNR versus loudest single SNR
fig_tag_list = generate_raw_zoom_tags(tag, "first_snr_vs_snr")
xlims_list = [None, [6,50]]
ylims_list = [None, [0,20]]
for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 
  sbv_plot_handler(trigSNR, trigFirstSNR, injSNR, injFirstSNR, injFile, \
            "Coherent SNR", "First loudest sngl SNR", outdir, fig_tag, \
            snr_vals=[0,50], conts=[[4,4]], use_logs=False, \
            colors=['g-'],xlims=xlims, ylims=ylims, verbose=verbose)

# Plot coherent SNR versus second loudest single SNR 
if(len(ifos)>1): 
  fig_tag_list = generate_raw_zoom_tags(tag, "second_snr_vs_snr")
  xlims_list = [None, [6,50]]
  ylims_list = [None, [0,20]]
  for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 

    sbv_plot_handler(trigSNR, trigSecondSNR, injSNR, injSecondSNR, injFile, \
              "Coherent SNR", "Second loudest sngl SNR", outdir, fig_tag, \
              snr_vals=[6, 10, 50], conts=[[2.5, 3.5, 13.5]], use_logs=False, \
              colors=['g-'],xlims=xlims, ylims=ylims, verbose=verbose)

# Plot coherent SNR versus third loudest single SNR
if len(ifos)>2: 

  fig_tag_list = generate_raw_zoom_tags(tag, "third_snr_vs_snr")
  xlims_list = [None, [6,50]]
  ylims_list = [None, [0,20]]
  for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 
    sbv_plot_handler(trigSNR, trigThirdSNR, injSNR, injThirdSNR, injFile, \
              "Coherent SNR", "Third loudest sngl SNR", outdir, fig_tag, \
              snr_vals=[0, 50], conts=[[4, 4]], use_logs=False, \

# TODO: plot SNR versus IFO SNR
sens1 = None
sens2 = None
for ifo in ifos:
  if not sens1:
    sens1 = ifo
  elif not sens2:
    senstvty = fResp[ifo]*trigSigmaMean[ifo]
    if (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens1]*trigSigmaMean[sens1]):
      sens2 = sens1
>>>>>>> refactored some plots and fixed typos
      sens1 = ifo
    else:
      sens2 = ifo
  else:
    if (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens1]*trigSigmaMean[sens1]):
      sens2 = sens1
      sens1 = ifo
    elif (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens2]*trigSigmaMean[sens2]):
      sens2 = ifo

for ifo in ifos:

  fig = plt.figure()
  ax  = fig.gca()
  ax.plot(trigSNR, trigIfoSNR[ifo], 'bx')
  ax.grid()
  if injFile:
    ax.plot(injSNR, injIfoSNR[ifo], 'r+')
  ax.plot(zoomSNR, ((fResp[ifo]*trigSigmaMean[ifo])**0.5) * zoomSNR, 'g-')
  ax.plot(zoomSNR, ((fResp[ifo]*trigSigmaMin[ifo])**0.5) * zoomSNR, 'g-')
  ax.plot(zoomSNR, ((fResp[ifo]*trigSigmaMax[ifo])**0.5) * zoomSNR, 'g-')
  ax.plot(zoomSNR, scipy.stats.ncx2.ppf(0.0455/2., 2,\
                                          (fResp[ifo]*trigSigmaMin[ifo])*\
                                           zoomSNR**2)**0.5, 'm-')
  ax.plot(zoomSNR, scipy.stats.ncx2.ppf(1-0.0455/2., 2,\
                                          (fResp[ifo]*trigSigmaMax[ifo])*\
                                           zoomSNR**2)**0.5, 'm-')
  ax.plot(zoomSNR, scipy.stats.ncx2.ppf(0.00135/2., 2,\
                                          (fResp[ifo]*trigSigmaMin[ifo])*\
                                           zoomSNR**2)**0.5, 'c-')
  ax.plot(zoomSNR, scipy.stats.ncx2.ppf(1-0.00135/2., 2,\
                                          (fResp[ifo]*trigSigmaMax[ifo])*\
                                           zoomSNR**2)**0.5, 'c-')
  ax.plot([0,50], [4,4], 'k-')
  if (ifo == sens1) or (ifo == sens2):
    # Shade vetoed area
    limy = ax.get_ylim()[0]
    polyx = [0,50]
    polyy = [4,4]
    polyx.extend([50,0])
    polyy.extend([limy, limy])
    ax.fill(polyx, polyy, color = '#dddddd')

  ax.set_xlabel("Coherent SNR")
  ax.set_ylabel("%s sngl SNR" % ifo)
  fig.savefig("%s/%s_%s_snr_vs_snr.png" % (outdir, tag, ifo),\
               bbox_inches='tight')
  
  ax.set_xlim([6,50])
  ax.set_ylim([0,20])
  fig.savefig("%s/%s_%s_snr_vs_snr_zoom.png" % (outdir, tag, ifo),\
               bbox_inches='tight')
  plt.close()
  

# Plot single detector chi-square plots: non-zoomed and zoomed 
for ifo in ifos:
  if sngl_bank_chisq:
   
    fig_tag_list = generate_raw_zoom_tags(tag, "bankchisq")
    xlims_list = [[4,1000], [4,50]]
    ylims_list = [None, [1,2000]]
    for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
 
      sbv_plot_handler(trigSNR, trigIfobankCS[ifo], injSNR, injIfobankCS[ifo], injFile, \
                "Coherent SNR", "%s sngl bank veto" % ifo, outdir, fig_tag, \
                xlims=xlims, ylims=ylims, verbose=verbose)
    
    fig_tag_list = generate_raw_zoom_tags(tag, "snr_vs_" + ifo + "_bankchisq")
    xlims_list = [[4,1000], [4,50]]
    ylims_list = [None, [1,2000]]
    for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
      sbv_plot_handler(trigIfoSNR[ifo], trigIfobankCS[ifo], \
                injIfoSNR[ifo], injIfobankCS[ifo], injFile, \
                "Coherent SNR", "%s sngl bank veto" % ifo, outdir, fig_tag, \
                xlims=xlims, ylims=ylims, verbose=verbose)
    
    fig_tag_list = generate_raw_zoom_tags(tag, "snr_vs__autochisq")
    xlims_list = [[4,1000], [4,50]]
    ylims_list = [None, [1,2000]]
    for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
      sbv_plot_handler(trigSNR, trigIfoautoCS[ifo], injSNR, injIfoautoCS[ifo], injFile, \
                "Coherent SNR", "%s sngl auto veto" % ifo, outdir, fig_tag, \
                xlims=xlims, ylims=ylims, verbose=verbose)
    
    fig_tag_list = generate_raw_zoom_tags(tag, "snr_vs_" + ifo + "_autochisq")
    xlims_list = [[4,1000], [4,50]]
    ylims_list = [None, [1,2000]]
    for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
      sbv_plot_handler(trigIfoSNR[ifo], trigIfoautoCS[ifo], \
                injIfoSNR[ifo], injIfoautoCS[ifo], injFile, \
                "Coherent SNR", "%s sngl auto veto" % ifo, outdir, fig_tag, \
                xlims=xlims, ylims=ylims, verbose=verbose)
  if sngl_chisq:
    try:
      
      fig_tag_list = generate_raw_zoom_tags(tag, "snr_vs_chisq")
      xlims_list = [[4,1000], [4,50]]
      ylims_list = [None, [1,2000]]
      for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
        sbv_plot_handler(trigSNR, trigIfostanCS[ifo], injSNR, injIfostanCS[ifo], injFile, \
                  "Coherent SNR", "%s sngl chi squared veto" % ifo, outdir, fig_tag, \
                  xlims=xlims, ylims=ylims, verbose=verbose)

    except OverflowError:
      sys.stderr.write("WARNING: Sngl chisq versus snr "+\
                       "failed with zeros in a loglog plot\n")
    try:
      fig_tag_list = generate_raw_zoom_tags(tag, "snr_vs_" + ifo + "chisq") #Why was it named the same as the one above? 
      xlims_list = [[4,1000], [4,50]]
      ylims_list = [None, [1,2000]]
      for fig_tag, xlims, ylims in \
             zip(fig_tag_list, xlims_list, ylims_list):
  
        sbv_plot_handler(trigIfoSNR[ifo], trigIfostanCS[ifo], \
                  injIfoSNR[ifo], injIfostanCS[ifo], injFile, \
                  "Coherent SNR", "%s sngl chi squared veto" % ifo, outdir, fig_tag, \
                  xlims=xlims, ylims=ylims, verbose=verbose)
      
    except OverflowError:
      sys.stderr.write("WARNING: Sngl chisq versus sngl snr"+\
                       "failed with zeros in a loglog plot\n")


# Plot SNR versus SNR-traceSNR: con-zoomed and zoomed
fig_tag_list = generate_raw_zoom_tags(tag, "trace_diff_vs_snr") #Why was it named the same as the one above? 
xlims_list = [None, [6,20]]
ylims_list = [None, [-5,10]]
inj_y=None
if injFile:
  inj_y = injSNR - injTraceSNR

for fig_tag, xlims, ylims in \
         zip(fig_tag_list, xlims_list, ylims_list):
  
  sbv_plot_handler(trigSNR, trigSNR - trigTraceSNR, injSNR, inj_y, injFile, "Coherent SNR", "SNR - Trace SNR", \
            outdir, fig_tag, use_logs=False,xlims=xlims, ylims=ylims, verbose=verbose)
  

# Plot time versus null stat
fig_tag = '%s_%s' % (tag, "null_snr_vs_time")
sbv_plot_handler(trigTime, trigNullstat, injTime, injNullstat , injFile, \
            "Time since %s" % (grbTime), "Null SNR", outdir, fig_tag, \
            xlims=[start,end], use_logs=False, verbose=verbose)

# Plot SNR versus rel amp 1
try:
  fig_tag_list = generate_raw_zoom_tags(tag, "rel_amp1_vs_snr") 
  xlims_list = [None, [6,30]]
  ylims_list = [None, None]
  for fig_tag, xlims, ylims in \
         zip(fig_tag_list, xlims_list, ylims_list):
  

    sbv_plot_handler(trigSNR, trigRelAmp1, injSNR, injRelAmp1, injFile, "Coherent SNR", "Relative amplitude 1", \
              outdir, fig_tag,xlims=xlims, ylims=ylims,  verbose=verbose)  

except (OverflowError,ValueError):
  sys.stderr.write("WARNING: Relative amplitude 1 versus coherent SNR "+\
                   "failed.\n")

# Plot SNR versus rel amp 2 TODO: empty!
try:
  fig_tag_list = generate_raw_zoom_tags(tag, "rel_amp2_vs_snr")
  xlims_list = [None, [6,30]]
  ylims_list = [None, None]
  for fig_tag, xlims, ylims in \
         zip(fig_tag_list, xlims_list, ylims_list):
  
    sbv_plot_handler(trigSNR, trigRelAmp2, injSNR, injRelAmp2, injFile, "Coherent SNR", "Relative amplitude 2", \
               outdir, fig_tag,xlims=xlims, ylims=ylims,  verbose=verbose)
except (OverflowError,ValueError):
  sys.stderr.write("WARNING: Relative amplitude 2 versus coherent SNR "+\
                   "failed with zeros in a loglog plot\n")

# Plot SNR versus norm 3: TODO empty
try:
  fig_tag_list = generate_raw_zoom_tags(tag, "norm3_vs_snr")
  xlims_list = [None, [6,30]]
  ylims_list = [None, None]
  for fig_tag, xlims, ylims in \
         zip(fig_tag_list, xlims_list, ylims_list):
   
    sbv_plot_handler(trigSNR, trigNorm3, injSNR, injNorm3, injFile, "Coherent SNR", "Amplitude factor", \
              outdir, fig_tag,xlims=xlims, ylims=ylims, verbose=True)
except (OverflowError,ValueError):
  sys.stderr.write("WARNING: Amplitude factor versus coherent SNR "+\
                   "failed with zeros in a loglog plot\n")

# Plot SNR versus inclination: TODO: empty
try:
  fig_tag_list = generate_raw_zoom_tags(tag, "inclination_vs_snr")
  xlims_list = [None, [6,30]]
  ylims_list = [None, None]
  for fig_tag, xlims, ylims in \
         zip(fig_tag_list, xlims_list, ylims_list):
   
    sbv_plot_handler(trigSNR, trigInclination, injSNR, injInclination, injFile, "Coherent SNR", "|cos inclination|", \
              outdir, fig_tag,xlims=xlims, ylims=ylims, verbose=verbose)

except (OverflowError,ValueError):
  sys.stderr.write("WARNING: cos(inclination) versus coherent SNR "+\
                   "failed with zeros in a loglog plot\n")

# TODO: plot sky grid
fig = plt.figure()
ax  = fig.gca()
ax.set_title("coh\_PTF %s Sky Grid" % tag, fontsize=18)
ax.set_xlabel("Longitude (Degrees)", fontsize=16)
ax.set_ylabel("Latitude (Degrees)", fontsize=16)
ax.plot(trigLongitude, trigLatitude, 'ko', markerfacecolor='blue')
fig.savefig("%s/%s_sky_grid.png" % (outdir, tag))
plt.close()
#sbv_plot_handler(trigSNR, trigInclination, injSNR, injInclination, injFile, "Longitude (Degrees)", "Latitude (Degrees)", \
#            outdir, fig_tag, verbose=True)

if verbose: sys.stdout.write("Done at %d.\n" % (elapsed_time()))
