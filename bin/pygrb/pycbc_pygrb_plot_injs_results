#!/usr/bin/env python

# Copyright (C) 2011 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import sys
import os
import logging
import itertools
# USE THIS TO CHECK NOTHING IS BREAKING
# REMOVE ONCE DONE CODING UP THIS SCRIPT
import cPickle as pickle
import matplotlib.pyplot as plt
from matplotlib import rc
import numpy as np
import pycbc.version
from pycbc.results import save_fig_with_metadata
from pycbc.results.pygrb_postprocessing_utils import extract_ifos_and_vetoes
from pycbc.results.pygrb_postprocessing_utils import load_xml_table
from pycbc.results.pygrb_postprocessing_utils import load_segment_dict
from pycbc.results.pygrb_postprocessing_utils import load_time_slides
from pycbc.results.pygrb_postprocessing_utils import pygrb_plot_opts_parser
from pycbc.results.pygrb_postprocessing_utils import construct_trials
from pycbc.results.pygrb_postprocessing_utils import sort_trigs
from pycbc.results.pygrb_postprocessing_utils import max_median_stat
from glue.ligolw import lsctables

# Deprecated
from pylal import SimInspiralUtils, MultiInspiralUtils
from pylal.coh_PTF_pyutils import readSegFiles, get_bestnr

plt.switch_backend('Agg')
rc("image")

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_efficiency"

# =============================================================================
# Main script starts here
# =============================================================================
description = 'Efficiency calculator for the triggered search (PyGRB).'
usage = __program__ + ' [--options]'
opts = pygrb_plot_opts_parser(usage=usage, description=description, version=__version__)

if opts.verbose:
    level = logging.INFO
else:
    level = logging.WARNING
logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=level)

# Check options
if opts.offsource_file is None:
    err_msg = "Please specify a path to the offsource trigger file."
    logging.error(err_msg)

if opts.veto_directory and (opts.veto_category is None):
    err_msg = "Must supply veto category if applying vetoes."
    logging.error(err_msg)

if (opts.found_file is None) and (opts.missed_file is None):
    do_injections = False
elif (opts.found_file) and opts.missed_file:
    do_injections = True
else:
    err_msg = "Must provide both found and missed file if running injections."
    logging.error(err_msg)

if not opts.newsnr_threshold:
    opts.newsnr_threshold = opts.snr_threshold

# Store options used multiple times in local variables
outdir = opts.output_path
trig_file = opts.offsource_file
found_file = opts.found_file
missed_file = opts.missed_file
chisq_index = opts.chisq_index
chisq_nhigh = opts.chisq_nhigh
snr_thresh = opts.snr_threshold
sngl_snr_thresh = opts.sngl_snr_threshold
new_snr_thresh = opts.newsnr_threshold
null_grad_thresh = opts.null_grad_thresh
null_grad_val = opts.null_grad_val
null_thresh = map(float, opts.null_snr_threshold.split(','))
# Initialize random number generator
np.random.seed(opts.seed)
logging.info("Setting random seed to %d.", opts.seed)

# Set output directory
logging.info("Setting output directory.")
if not os.path.isdir(outdir):
    os.makedirs(outdir)

# Extract IFOs and vetoes
logging.info("Extracting IFOs and vetoes.")
ifos, vetoes = extract_ifos_and_vetoes(trig_file, opts.veto_directory, \
                                       opts.veto_category)

# Load triggers, time-slides, and segment dictionary
logging.info("Loading triggers.")
trigs = load_xml_table(trig_file, lsctables.MultiInspiralTable.tableName)
logging.info("%d triggers loaded.", len(trigs))
logging.info("Loading timeslides.")
slide_dict = load_time_slides(trig_file)
logging.info("Loading segments.")
segment_dict = load_segment_dict(trig_file)

# Identify the number of slides
num_slides = len(slide_dict)

# Get segments
segs = readSegFiles(opts.segment_dir)

# Construct trials
logging.info("Constructing trials.")
trial_dict = construct_trials(num_slides, segs, segment_dict, ifos, slide_dict, vetoes)

# Sort the triggers into each slide
sorted_trigs = sort_trigs(trial_dict, trigs, num_slides, segment_dict)

total_trials = sum([len(trial_dict[slide_id]) for slide_id in range(num_slides)])

msg = "Segments loaded, triggers sorted, and %d trials generated." % (total_trials)
logging.info(msg)

# Extract basic trigger properties and store as dictionaries
trig_time = {}
trig_bestnr = {}
for slide_id in range(num_slides):
    slide_trigs = sorted_trigs[slide_id]
    trig_time[slide_id] = np.asarray(slide_trigs.get_end()).astype(float)
    trig_bestnr[slide_id] = [get_bestnr(t, q=chisq_index, n=chisq_nhigh,\
                                        null_thresh=null_thresh,\
                                        snr_threshold=snr_thresh,\
                                        sngl_snr_threshold=sngl_snr_thresh,\
                                        chisq_threshold=new_snr_thresh,\
                                        null_grad_thresh=null_grad_thresh,\
                                        null_grad_val=null_grad_val) \
                             for t in slide_trigs]
    trig_bestnr[slide_id] = np.array(trig_bestnr[slide_id])
logging.info("Time and BestNR of triggers extracted.")

# Calculate SNR and BestNR values and maxima
time_veto_max_bestnr = {}
for slide_id in range(num_slides):
    num_slide_segs = len(trial_dict[slide_id])
    time_veto_max_bestnr[slide_id] = np.zeros(num_slide_segs)

for slide_id in range(num_slides):
    for j, trial in enumerate(trial_dict[slide_id]):
        trial_cut = (trial[0] <= trig_time[slide_id])\
                          & (trig_time[slide_id] < trial[1])
        if not trial_cut.any():
            continue
        # Max BestNR
        time_veto_max_bestnr[slide_id][j] = \
                        max(trig_bestnr[slide_id][trial_cut])

logging.info("BestNR maxima calculated.")

max_bestnr, _, full_time_veto_max_bestnr = max_median_stat(num_slides,
                                                           time_veto_max_bestnr,\
                                                           trig_bestnr,
                                                           total_trials)


# =======================
# Post-process injections
# =======================
if do_injections:

    sites = [ifo[0] for ifo in ifos]

    # Triggers and injections recovered in some form
    found_trigs_nveto = MultiInspiralUtils.ReadMultiInspiralFromFiles([found_file])
    found_injs_no_veto = SimInspiralUtils.ReadSimInspiralFromFiles([found_file])

    found_trigs = lsctables.New(lsctables.MultiInspiralTable)
    found_injs = lsctables.New(lsctables.SimInspiralTable)

    for trig, sim in zip(found_trigs_nveto, found_injs_no_veto):
        if sim.get_end() not in vetoes.union(vetoes.keys()):
            found_injs.append(sim)
            found_trigs.append(trig)

    logging.info("Missed/found injections/triggers loaded.")

    # Extract columns of found injections and triggers
    found_inj_time = np.asarray(found_injs.get_column('geocent_end_time')) +\
                     np.asarray(found_injs.get_column('geocent_end_time_ns')*\
                                10**-9)
    found_inj_mchirp = np.asarray(found_injs.get_column('mchirp'))
    found_inj_mtot = np.asarray(found_injs.get_column('mtotal'))
    found_inj_m1 = np.asarray(found_injs.get_column('mass1'))
    found_inj_m2 = np.asarray(found_injs.get_column('mass2'))
    found_inj_eff_site_dist =\
        dict((ifo, found_injs.get_column('eff_dist_%s' % ifo.lower()))\
             for ifo in sites)
    found_inj_eff_dist = np.power(np.power(\
                                  np.asarray(found_inj_eff_site_dist.\
                                  values()), -1).sum(0), -1)
    found_inj_ra = np.asarray(found_injs.get_column('longitude'))
    found_inj_dec = np.asarray(found_injs.get_column('latitude'))
    found_inj_dist = np.asarray(found_injs.get_column('distance'))
    found_inj_inc = np.asarray(found_injs.get_column('inclination'))
    found_inj_spin1x = np.asarray(found_injs.get_column('spin1x'))
    found_inj_spin1y = np.asarray(found_injs.get_column('spin1y'))
    found_inj_spin1z = np.asarray(found_injs.get_column('spin1z'))
    found_inj_spin2x = np.asarray(found_injs.get_column('spin2x'))
    found_inj_spin2y = np.asarray(found_injs.get_column('spin2y'))
    found_inj_spin2z = np.asarray(found_injs.get_column('spin2z'))

    # TODO: a lot of this is identical to all the stuff above
    found_trig_mchirp = np.asarray(found_trigs.get_column('mchirp'))
    found_trig_ra = np.asarray(found_trigs.get_column('ra'))
    found_trig_dec = np.asarray(found_trigs.get_column('dec'))
    found_sky_angle = np.arccos(np.cos(found_inj_dec - found_trig_dec) -\
                                np.cos(found_inj_dec)* np.cos(found_trig_dec) *\
                                (1 - np.cos(found_inj_ra - found_trig_ra)))

    # Grab values of detection statistic
    found_trig_bestnr = [get_bestnr(t, q=chisq_index, n=chisq_nhigh,\
                             null_thresh=null_thresh,\
                             snr_threshold=snr_thresh,\
                             sngl_snr_threshold=sngl_snr_thresh,\
                             chisq_threshold=new_snr_thresh,\
                             null_grad_thresh=null_grad_thresh,\
                             null_grad_val=null_grad_val) for t in found_trigs]
    found_trig_bestnr = np.asarray(found_trig_bestnr)

    # Construct conditions for injection:
    # 1) found louder than background,
    zero_fap = np.zeros(len(found_injs)).astype(np.bool)
    zero_fap_cut = found_trig_bestnr > max_bestnr
    zero_fap = zero_fap | (zero_fap_cut)

    # 2) found (bestnr > 0) but not louder than background (non-zero FAP)
    nonzero_fap = ~zero_fap & (found_trig_bestnr != 0)

    # 3) missed after being recovered (i.e., vetoed)
    missed = (~zero_fap) & (~nonzero_fap)

    # Separate triggers into:
    # 1) zero_fap 'g_found'
    # 2) nonzero_fap 'g_ifar'
    # 3) missed because of vetoes 'g_missed2'

    # Zero FAP
    g_found_mchirp = found_inj_mchirp[zero_fap]
    g_found_m1 = found_inj_m1[zero_fap]
    g_found_m2 = found_inj_m2[zero_fap]
    g_found_eff_site_dist = dict((ifo, found_inj_eff_site_dist[ifo][zero_fap])\
                             for ifo in sites)
    g_found_eff_dist = found_inj_eff_dist[zero_fap]
    g_found_det_stat = found_trig_bestnr[zero_fap]
    g_found_dist = found_inj_dist[zero_fap]
    g_found_time = found_inj_time[zero_fap]
    g_found_sky_angle = found_sky_angle[zero_fap]
    g_found_inc = found_inj_inc[zero_fap]
    g_found_spin1x = found_inj_spin1x[zero_fap]
    g_found_spin1y = found_inj_spin1y[zero_fap]
    g_found_spin1z = found_inj_spin1z[zero_fap]
    g_found_spin2x = found_inj_spin2x[zero_fap]
    g_found_spin2y = found_inj_spin2y[zero_fap]
    g_found_spin2z = found_inj_spin2z[zero_fap]

    # Non-zero FAP
    g_ifar_mchirp = found_inj_mchirp[nonzero_fap]
    g_ifar_m1 = found_inj_m1[nonzero_fap]
    g_ifar_m2 = found_inj_m2[nonzero_fap]
    g_ifar_eff_site_dist = dict((ifo, found_inj_eff_site_dist[ifo][nonzero_fap])\
                              for ifo in sites)
    g_ifar_eff_dist = found_inj_eff_dist[nonzero_fap]
    g_ifar_det_stat = found_trig_bestnr[nonzero_fap]
    g_ifar_dist = found_inj_dist[nonzero_fap]
    g_ifar_time = found_inj_time[nonzero_fap]
    g_ifar_sky_angle = found_sky_angle[nonzero_fap]
    g_ifar_inc = found_inj_inc[nonzero_fap]
    g_ifar_spin1x = found_inj_spin1x[nonzero_fap]
    g_ifar_spin1y = found_inj_spin1y[nonzero_fap]
    g_ifar_spin1z = found_inj_spin1z[nonzero_fap]
    g_ifar_spin2x = found_inj_spin2x[nonzero_fap]
    g_ifar_spin2y = found_inj_spin2y[nonzero_fap]
    g_ifar_spin2z = found_inj_spin2z[nonzero_fap]

    g_ifar_stat = np.zeros([len(g_ifar_det_stat)])
    for ix, (mc, bestnr) in \
                enumerate(zip(found_trig_mchirp[nonzero_fap], g_ifar_det_stat)):
        g_ifar_stat[ix] = (full_time_veto_max_bestnr > bestnr).sum()
    g_ifar_stat = g_ifar_stat / total_trials
    # Statistics: missed-found
    MF = np.argsort(g_ifar_stat)
    # Statistics: found-missed
    FM = MF[::-1]

    # Missed due to vetoes
    g_missed2_mchirp = found_inj_mchirp[missed]
    g_missed2_m1 = found_inj_m1[missed]
    g_missed2_m2 = found_inj_m2[missed]
    g_missed2_eff_site_dist = dict((ifo, found_inj_eff_site_dist[ifo][missed])\
                                   for ifo in sites)
    g_missed2_eff_dist = found_inj_eff_dist[missed]
    g_missed2_det_stat = found_trig_bestnr[missed]
    g_missed2_dist = found_inj_dist[missed]
    g_missed2_time = found_inj_time[missed]
    g_missed2_sky_angle = found_sky_angle[missed]
    g_missed2_inc = found_inj_inc[missed]
    g_missed2_spin1x = found_inj_spin1x[missed]
    g_missed2_spin1y = found_inj_spin1y[missed]
    g_missed2_spin1z = found_inj_spin1z[missed]
    g_missed2_spin2x = found_inj_spin2x[missed]
    g_missed2_spin2y = found_inj_spin2y[missed]
    g_missed2_spin2z = found_inj_spin2z[missed]

    logging.info("%d found injections analysed.", len(found_injs))

    # Missed injections (ones not recovered at all)
    missed_injs = SimInspiralUtils.ReadSimInspiralFromFiles([missed_file])\
            .veto(vetoes.union(vetoes.keys()))

    # Process missed injections 'missed_inj'
    missed_inj_mchirp = np.asarray(missed_injs.get_column('mchirp'))
    missed_inj_eff_site_dist =\
        dict((ifo, missed_injs.get_column('eff_dist_%s' % ifo.lower()))\
             for ifo in sites)
    missed_inj_eff_dist = np.power(np.power(\
                                   np.asarray(missed_inj_eff_site_dist.\
                                   values()), -1)\
                                   .sum(0), -1)
    missed_inj_dist = np.asarray(missed_injs.get_column('distance'))
    missed_inj_time = np.asarray(missed_injs.get_column('geocent_end_time') +\
                                 missed_injs.get_column('geocent_end_time_ns') *\
                                 10**-9)
    missed_inj_m1 = np.asarray(missed_injs.get_column('mass1'))
    missed_inj_m2 = np.asarray(missed_injs.get_column('mass2'))
    missed_inj_inc = np.asarray(missed_injs.get_column('inclination'))
    missed_inj_ra = np.asarray(missed_injs.get_column('longitude'))
    missed_inj_dec = np.asarray(missed_injs.get_column('latitude'))

    missed_inj_spin1x = np.asarray(missed_injs.get_column('spin1x'))
    missed_inj_spin1y = np.asarray(missed_injs.get_column('spin1y'))
    missed_inj_spin1z = np.asarray(missed_injs.get_column('spin1z'))
    missed_inj_spin2x = np.asarray(missed_injs.get_column('spin2x'))
    missed_inj_spin2y = np.asarray(missed_injs.get_column('spin2y'))
    missed_inj_spin2z = np.asarray(missed_injs.get_column('spin2z'))

    if missed_inj_spin1x.size:
        missed_inj_spin1 = np.sqrt(missed_inj_spin1x**2 + missed_inj_spin1y**2 + \
                                   missed_inj_spin1z**2)
        missed_inj_spin2 = np.sqrt(missed_inj_spin2x**2 + missed_inj_spin2y**2 + \
                                   missed_inj_spin2z**2)
        max_missed_inj_spin1 = missed_inj_spin1.max()
        max_missed_inj_spin2 = missed_inj_spin2.max()
    else:
        max_missed_inj_spin1 = 0
        max_missed_inj_spin2 = 0

    logging.info("%d missed injections analysed.", len(missed_injs))

    # Write inclination recovery to file
    # GRB start time
    grb_time = segs['on'][1] - 1
    f_incl_txt = open('%s/found_inclinations.txt' % outdir, 'w')
    f_incl_txt.write('GPS time\tTime since %d\tInclination\n\n' % grb_time)
    stacked = np.column_stack([g_found_time,
                               g_found_time - grb_time,
                               g_found_inc])
    np.savetxt(f_incl_txt, stacked, delimiter='\t')
    f_incl_txt.close()
    t_incl_txt = open('%s/total_inclinations.txt' % outdir, 'w')
    t_incl_txt.write('GPS time\tTime since %d\tInclination\n\n' % grb_time)
    stacked = np.column_stack([np.concatenate((found_inj_time, missed_inj_time)),
                               np.concatenate((found_inj_time - grb_time,
                                               missed_inj_time - grb_time)),
                               np.concatenate((found_inj_inc, missed_inj_inc))])
    np.savetxt(t_incl_txt, stacked, delimiter='\t')
    t_incl_txt.close()

    # Get start and end times
    start = int(min(np.concatenate((found_inj_time, missed_inj_time))))
    end = int(max(np.concatenate((found_inj_time, missed_inj_time))))
    duration = end - start
    # Pad times and reset to centre on zero
    start = start - duration*0.05 - grb_time
    end = end + duration*0.05 - grb_time
    missed_inj_time = missed_inj_time - grb_time
    g_missed2_time -= grb_time
    g_found_time -= grb_time
    g_ifar_time -= grb_time

# Post-processing of injections ends here

# ==========
# Make plots
# ==========

# TODO: turn the following into an executable and loop at workflow level
# Plot results of injection campaign with found ones on top of missed ones
# (found-missed) or vice-versa (missed-found)
if do_injections:
    inj_plots = list(itertools.product([["found_missed"], ["missed_found"]],\
                                       [["mchirp"], ["time"]],\
                                       [["eff_dist"], ["dist"],\
                                        ["eff_site_dist"], ["sky_error"]]))
    inj_plots.extend(list(itertools.product([["found_missed"], ["missed_found"]],\
                                            [["spin1", "spin2"], ["q", "mtot"],\
                                             ["incl", "mchirp"], ["cosincl", "dist"],
                                             ["dist", "sky_error"]])))
    inj_plots = list(itertools.chain(*inj_plots))
    inj_plots = list(itertools.chain(*inj_plots))
    inj_plots = [inj_plots[i:i+3] for i in range(0, len(inj_plots), 3)]

    # Info for site-specific plots
    sitename = {'G':'GEO', 'H':'Hanford', 'L':'Livingston', 'V':'Virgo',\
                'K':'KAGRA'}

    # Dictionary of labels for the horizontal axis
    axis_labels = {'mchirp': "Chirp Mass (solar masses)",
                   'time': "Time since %d" % grb_time,
                   'eff_dist': "Inverse sum of effective distances (Mpc)",
                   'dist': "Distance (Mpc)",
                   'eff_site_dist': "",
                   'incl': "Inclination (iota)",
                   'cosincl': "cos(iota)",
                   'q': "Mass ratio q",
                   'mtot': "Total mass M (solar masses)",
                   'spin1': "Spin on 1st binary component",
                   'spin2': "Spin on 2nd binary component",
                   'sky_error': "Rec. sky error (radians)"}

    # Dictionaries of data to plot
    g_found_dict = {'mchirp': g_found_mchirp, 'time': g_found_time,
                    'eff_dist': g_found_eff_dist, 'dist': g_found_dist,
                    'eff_site_dist': [],
                    'incl': np.rad2deg(g_found_inc), 'cosincl': np.cos(g_found_inc),
                    'q': g_found_m2 / g_found_m1, 'mtot': g_found_m1 + g_found_m2,
                    'spin1': np.sqrt(g_found_spin1x**2 + \
                                     g_found_spin1y**2 + \
                                     g_found_spin1z**2),
                    'spin2': np.sqrt(g_found_spin2x**2 + \
                                     g_found_spin2y**2 + \
                                     g_found_spin2z**2),
                    'sky_error': g_found_sky_angle}
    g_ifar_dict = {'mchirp': g_ifar_mchirp, 'time': g_ifar_time,
                   'eff_dist': g_ifar_eff_dist, 'dist': g_ifar_dist,
                   'eff_site_dist': [],
                   'incl': np.rad2deg(g_ifar_inc), 'cosincl': np.cos(g_ifar_inc),
                   'q': g_ifar_m2 / g_ifar_m1, 'mtot': g_ifar_m1 + g_ifar_m2,
                   'spin1': np.sqrt(g_ifar_spin1x**2 + \
                                    g_ifar_spin1y**2 + \
                                    g_ifar_spin1z**2),
                   'spin2': np.sqrt(g_ifar_spin2x**2 + \
                                    g_ifar_spin2y**2 + \
                                    g_ifar_spin2z**2),
                   'sky_error': g_ifar_sky_angle}
    g_missed2_dict = {'mchirp': g_missed2_mchirp, 'time': g_missed2_time,
                      'eff_dist': g_missed2_eff_dist, 'dist': g_missed2_dist,
                      'eff_site_dist': [],
                      'incl': np.rad2deg(g_missed2_inc), 'cosincl': np.cos(g_missed2_inc),
                      'q': g_missed2_m2 / g_missed2_m1, 'mtot': g_missed2_m1 + g_missed2_m2,
                      'spin1': np.sqrt(g_missed2_spin1x**2 + \
                                       g_missed2_spin1y**2 + \
                                       g_missed2_spin1z**2),
                      'spin2': np.sqrt(g_missed2_spin2x**2 + \
                                       g_missed2_spin2y**2 + \
                                       g_missed2_spin2z**2),
                      'sky_error': g_missed2_sky_angle}
    missed_inj_dict = {'mchirp': missed_inj_mchirp, 'time': missed_inj_time,
                       'eff_dist': missed_inj_eff_dist, 'dist': missed_inj_dist,
                       'eff_site_dist': [],
                       'incl': np.rad2deg(missed_inj_inc), 'cosincl': np.cos(missed_inj_inc),
                       'q': missed_inj_m2 / missed_inj_m1, 'mtot': missed_inj_m1 + missed_inj_m2,
                       'spin1': np.sqrt(missed_inj_spin1x**2 + \
                                        missed_inj_spin1y**2 + \
                                        missed_inj_spin1z**2),
                       'spin2': np.sqrt(missed_inj_spin2x**2 + \
                                        missed_inj_spin2y**2 + \
                                        missed_inj_spin2z**2),
                       'sky_error': []}
    # USE THIS TO CHECK NOTHING IS BREAKING
    # REMOVE ONCE DONE CODING UP THIS SCRIPT
    for filename, dictionary in [['g_found_dict', g_found_dict],\
                                 ['g_ifar_dict', g_ifar_dict],\
                                 ['g_missed2_dict', g_missed2_dict],\
                                 ['missed_inj_dict', missed_inj_dict]]:
        with open(('%s/%s_vals.txt' % (outdir, filename)), 'w') as dump_file:
            dump_file.write(pickle.dumps(dictionary))

    # Generate scatter plots
    for inj_plot in inj_plots:
        #print(inj_plot)
        fm_or_mf = inj_plot[0]
        x_qty = inj_plot[1]
        y_qty = inj_plot[2]
        g_found_x = np.array(g_found_dict[x_qty])
        g_found_y = np.array(g_found_dict[y_qty])
        g_ifar_x = np.array(g_ifar_dict[x_qty])
        g_ifar_y = np.array(g_ifar_dict[y_qty])
        g_missed2_x = np.array(g_missed2_dict[x_qty])
        g_missed2_y = np.array(g_missed2_dict[y_qty])
        missed_inj_x = np.array(missed_inj_dict[x_qty])
        missed_inj_y = np.array(missed_inj_dict[y_qty])
        x_label = axis_labels[x_qty]
        y_label = axis_labels[y_qty]
        if x_qty == "spin1":
            found_inj_x = np.sqrt(found_inj_spin1x**2 + \
                                  found_inj_spin1y**2 + \
                                  found_inj_spin1z**2)
        elif x_qty == "q":
            missed_inj_x = np.where(missed_inj_x > 1, 1. / missed_inj_x, missed_inj_x)
            g_missed2_x = np.where(g_missed2_x > 1, 1. / g_missed2_x, g_missed2_x)
            g_ifar_x = np.where(g_ifar_x > 1, 1. / g_ifar_x, g_ifar_x)
            g_found_x = np.where(g_found_x > 1, 1. / g_found_x, g_found_x)
        #elif x_qty == "incl":
        #    #x_label = "Magnitude of inclination | iota |"
        #elif x_qty == "cosincl":
        #     x_label = "cos(|iota|)"
        #     g_found_x = 0.5 * np.pi - abs(g_found_inc - 0.5 * np.pi)
        #     g_ifar_x = 0.5 * np.pi - abs(g_ifar_inc - 0.5 * np.pi)
        #     g_missed2_x = 0.5 * np.pi - abs(g_missed2_inc - 0.5 * np.pi)
        #     missed_inj_x = 0.5 * np.pi - abs(missed_inj_inc - 0.5 * np.pi)
        elif "incl" in x_qty:
            max_inc = np.pi
            #max_inc = max(np.concatenate((g_found_x, g_ifar_x, g_missed2_x, missed_inj_x)))
            max_inc_deg = np.rad2deg(max_inc)
            max_inc_deg = np.ceil(max_inc_deg/10.0)*10
            max_inc = np.deg2rad(max_inc_deg)
        # The square brackets are for a one-iteration loop below
        plot_loop = [None]
        if y_qty == "eff_site_dist":
            plot_loop = sites
        elif y_qty == "spin2":
            found_inj_y = np.sqrt(found_inj_spin2x**2 + \
                                  found_inj_spin2y**2 + \
                                  found_inj_spin2z**2)
        for site in plot_loop:
            if site is not None:
                if x_qty == "eff_site_dist":
                    x_label = "%s effective distance (Mpc)" % sitename[site]
                if y_qty == "eff_site_dist":
                    y_label = "%s effective distance (Mpc)" % sitename[site]
                missed_inj_y = np.array(missed_inj_eff_site_dist[site])
                g_missed2_y = np.array(g_missed2_eff_site_dist[site])
                g_ifar_y = np.array(g_ifar_eff_site_dist[site])
                g_found_y = np.array(g_found_eff_site_dist[site])
            fig = plt.figure()
            if y_qty in ["mtot", "spin2", "mchirp"]:
                ax = fig.gca()
            elif y_qty == "sky_error":
                if x_qty == "dist":
                    ax = fig.gca(xscale="log")
                else:
                    ax = fig.gca()
            else:
                ax = fig.gca(yscale="log")
            # Define p-value colour
            cmap = plt.get_cmap('cividis_r')
            #cmap. set_over('g')
            # Define the 'found' injection colour
            fnd_col = cmap(0)
            if fm_or_mf == "found_missed":
                if missed_inj_x.size and missed_inj_y.size:
                    ax.scatter(missed_inj_x, missed_inj_y, c="k", marker="x", s=10)
                if g_missed2_x.size:
                    ax.scatter(g_missed2_x, g_missed2_y, c="r", marker="x", s=10)
                if g_ifar_x.size:
                    p = ax.scatter(g_ifar_x[FM], g_ifar_y[FM], c=g_ifar_stat[FM],
                                   cmap=cmap, vmin=0, vmax=1, s=40,
                                   edgecolor="w", linewidths=2.0)
                    cb = plt.colorbar(p, label="p-value")
                if g_found_x.size:
                    ax.scatter(g_found_x, g_found_y, c=fnd_col, marker="+", s=30)
            elif fm_or_mf == "missed_found":
                if g_found_x.size:
                    ax.scatter(g_found_x, g_found_y, c=fnd_col, marker="+", s=15)
                if g_ifar_x.size:
                    p = ax.scatter(g_ifar_x[MF], g_ifar_y[MF], c=g_ifar_stat[MF],
                                   cmap=cmap, vmin=0, vmax=1, s=40,
                                   edgecolor="w", linewidths=2.0)
                    cb = plt.colorbar(p, label="p-value")
                if g_missed2_x.size:
                    ax.scatter(g_missed2_x, g_missed2_y, c="r", marker="x", s=40)
                if missed_inj_x.size and missed_inj_y.size:
                    ax.scatter(missed_inj_x, missed_inj_y, c="k", marker="x", s=40)
            ax.grid()
            ax.set_xlabel(x_label)
            ax.set_ylabel(y_label)
            plot_path = "%s/%s_injections_%s_%s" % (outdir, fm_or_mf, y_qty, x_qty)
            if x_qty == "spin1":
                plot_title = "Injection recovery with respect to component spins"
                ax.set_xlim([0, np.ceil(10 * max(max_missed_inj_spin1,
                                                 found_inj_x.max())) / 10])
                ax.set_ylim([0, np.ceil(10 * max(max_missed_inj_spin2,
                                                 found_inj_y.max())) / 10])
            elif x_qty == "incl":
                plot_title = "Injection recovery with respect to inclination angle"
                ax.set_xlim(0, max_inc_deg)
            elif x_qty == "cosincl":
                plot_title = "Injection recovery with respect to inclination angle"
                tt = np.arange(0, max_inc_deg + 10, 10)
                #tt = np.arange(0, 190, 10)
                tks = np.cos(np.deg2rad(tt))
                tk_labs = ['cos(%d deg)' % tk for tk in tt]
                plt.xticks(tks, tk_labs, fontsize=10)
                fig.autofmt_xdate()
                ax.set_xlim(np.cos(max_inc), 1)
                #ax.set_xlim(-1, 1)
            elif y_qty == "mtot":
                plot_title = "Injection recovery with respect to component masses"
            elif site is not None:
                plot_title = "Injection recovery vs background"
                plot_path += "_%s" % site.lower()
            else:
                plot_title = "Injection recovery vs background"
            ax.set_title(plot_title)
            plt.tight_layout()
            plot_path += ".png"
            plot_caption = "Black cross indicates no trigger was found "
            plot_caption += "coincident with the injection.\n"
            plot_caption += "Red cross indicates a trigger was found "
            plot_caption += "coincident with the injection but it was vetoed.\n"
            plot_caption += "Yellow plus indicates that a trigger was found "
            plot_caption += "coincident with the injection and it was louder "
            plot_caption += "than all events in the offsource.\n"
            plot_caption += "Coloured circle indicates that a trigger was "
            plot_caption += "found coincident with the injection but it was "
            plot_caption += "not louder than all offsource events. The colour "
            plot_caption += "bar gives the p-value of the trigger."
            save_fig_with_metadata(fig, plot_path, cmd=' '.join(sys.argv),
                                   title=plot_title, caption=plot_caption)
            plt.close()

logging.info("Plots complete.")
