#!/usr/bin/env python

# Copyright (C) 2021 Francesco Pannarale, Viviana Caceres
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
Plot found/missed injection properties for the triggered search (PyGRB).'
"""

import h5py, numpy, logging, os.path, argparse, sys
import matplotlib.pyplot as plt
import matplotlib
import pycbc.results.followup, pycbc.pnutils, pycbc.results, pycbc.version
import pycbc.pnutils
from pycbc import init_logging
from pycbc.detector import Detector
from pycbc.results import pygrb_postprocessing_utils as ppu

plt.switch_backend('Agg')
matplotlib.rc("image")

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_plot_injs_results"


# =============================================================================
# Functions
# =============================================================================
def load_incl_data(injs, qty):
    """Extract data related to inclination from raw trigger/injection data"""

    local_dict = {}

    # Whether the user requests incl, |incl|, cos(incl), or cos(|incl|)
    # the following information is needed
    local_dict['incl'] = injs['injections/inclination'][:]

    # Requesting |incl| or cos(|incl|)
    if 'abs_' in qty:
        local_dict['abs_incl'] = 0.5*numpy.pi - abs(local_dict['incl'] - 0.5*numpy.pi)

    # Requesting cos(incl) or cos(|incl|): take cosine
    if 'cos_' in qty:
        angle = qty.replace('cos_', '')
        angle_data = local_dict[angle]
        data = numpy.cos(angle_data)
    # Requesting incl or abs_incl: convert to degrees
    else:
        data = numpy.rad2deg(local_dict[qty])

    return data

# Function to extract mass ratio or total mass data from a trigger/injection file
def load_mass_data(injs, qty):
    """Extract data related to mass ratio or total mass from raw
    trigger/injection data"""

    local_dict = {}

    # Grab individual mass components
    for mi in ['mass1', 'mass2']:
        local_dict[mi] = injs['injections/%s' % mi][:]

    if qty == 'mtotal':
        data = local_dict['mass1'] + local_dict['mass2']
    elif qty == 'mchirp':
        data, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(
            local_dict['mass1'], local_dict['mass2'])
    else:
        data = local_dict['mass2']/local_dict['mass1']
        data = numpy.where(data > 1, 1./data, data)

    return data


# Function to extract mass ratio or total mass data from a trigger/injection file
def load_effdist_data(injs, qty, opts, ifos):
    """Extract data related to effective distances from raw trigger/injection data"""

    local_dict = {}

    if qty == 'eff_site_dist':
        data = injs['injections/eff_dist_%s' % opts.ifo[0].lower()][:]
    else:
        local_dict['eff_site_dist'] =\
            dict((ifo, injs['injections/eff_dist_%s' % ifo[0].lower()][:])
                 for ifo in ifos)
        # Effective distance (inverse sum of inverse effective distances)
        data = numpy.power(numpy.power(numpy.asarray(
            list(local_dict['eff_site_dist'].values())), -1).sum(0), -1)

    return data

# Function to extract spin related data from a trigger/injection file
def load_spin_data(injs, qty):
    """Extract data related to spin from raw trigger/injection data"""

    local_dict = {}

    # Grab the components
    for component in ['x', 'y', 'z']:
        key = qty+component
        local_dict[key] = injs['injections/%s' % key][:]

    # Calculate the modulus
    data = numpy.sqrt(local_dict[qty+'x']**2 +
                   local_dict[qty+'y']**2 +
                   local_dict[qty+'z']**2)

    return data


# Function to extract desired data from a trigger/injection file
def load_data(input_file, keys, opts, ifos):
    """Create a dictionary containing the data specified by the
    list of keys extracted from a trigger/injection file"""

    injs = h5py.File(input_file, 'r')
    data_dict = {}

    easy_keys = ['coa_phase', 'distance', 'latitude',
                 'longitude','mass1', 'mass2', 'polarization',
                 'spin1x', 'spin1y', 'spin1z', 'spin2x',
                 'spin2y', 'spin2z']

    for qty in keys:
        if qty in easy_keys:
            data_dict[qty] = injs['injections/%s' % qty][:]
        elif qty == 'end_time':
            data_dict[qty] = injs['injections/end_time'][:]
            grb_time = ppu.get_grb_time(opts.seg_files)
            data_dict[qty] -= grb_time
        elif qty in ['mtotal', 'q', 'mchirp']:
            data_dict[qty] = load_mass_data(injs, qty)
        elif qty in ['eff_site_dist', 'eff_dist']:
            data_dict[qty] = load_effdist_data(injs, qty, opts, ifos)
        elif 'incl' in qty:
            data_dict[qty] = load_incl_data(injs, qty)
        # This handles spin1 and spin2, i.e. spin magnitudes, as components
        # are dealt with in easy_keys (first if)
        elif 'spin' in qty:
            data_dict[qty] = load_spin_data(injs, qty)

    return data_dict


def load_trig_data(input_file, vetoes):
    """Load data from a trigger file"""

    logging.info("Loading triggers...")
    trigs = ppu.load_triggers(input_file, vetoes)

    return trigs


# =============================================================================
# Main script starts here
# =============================================================================
parser = ppu.pygrb_initialize_plot_parser(description=__doc__,
                                          version=__version__)
parser.add_argument('--injection-file',
                    help="The hdf injection file to plot", required=True)
parser.add_argument('--trigger-file',
                    help="The hdf file with found triggers", required=True)            
admitted_vars = ['coa_phase', 'distance', 'latitude', 'longitude','mass1',
                 'mass2', 'polarization', 'spin1x', 'spin1y', 'spin1z',
                 'spin2x', 'spin2y', 'spin2z', 'end_time', 'mtotal', 'q',
                 'mchirp', 'eff_site_dist', 'eff_dist', 'incl', 'cos_incl',
                 'abs_incl', 'cos_abs_incl', 'spin1', 'spin2']
parser.add_argument("-x", "--x-variable", default=None, required=True,
                    choices=admitted_vars,
                    help="Quantity to plot on the horizontal axis. ")
parser.add_argument("--x-log", action="store_true",
                    help="Use log horizontal axis")
parser.add_argument("-y", "--y-variable", default=None, required=True,
                    choices=admitted_vars,
                    help="Quantity to plot on the vertical axis.")
parser.add_argument("--y-log", action="store_true",
                    help="Use log vertical axis")
parser.add_argument('--colormap',default='cividis_r',
                   help="Type of colormap to be used for the plots.")
parser.add_argument('--gradient-far', action='store_true',
                    help="Show far of found injections as a gradient")
parser.add_argument('--far-type', choices=('inclusive', 'exclusive'),
                    default='inclusive',
                    help="Type of far to plot for the color. Choices are "
                         "'inclusive' or 'exclusive'. Default = 'inclusive'")
parser.add_argument('--missed-on-top', action='store_true',
                    help="Plot missed injections on top of found ones and "
                         "high FAR on top of low FAR")
opts = parser.parse_args()

init_logging(opts.verbose, format="%(asctime)s: %(levelname)s: %(message)s")

# Check options
if opts.injection_file is None:
    err_msg = "Must provide injection file."
    raise RuntimeError(err_msg)

x_qty = opts.x_variable
y_qty = opts.y_variable

if 'eff_site_dist' in [x_qty, y_qty] and opts.ifo is None:
    err_msg = "A value for --ifo must be provided for "
    err_msg += "site specific effective distance"
    parser.error(err_msg)

# Store options used multiple times in local variables
outfile = opts.output_file
trig_file = os.path.abspath(opts.offsource_file)
f = h5py.File(opts.injection_file, 'r')
grb_time = ppu.get_grb_time(opts.seg_files)

# Set output directory
logging.info("Setting output directory.")
outdir = os.path.split(os.path.abspath(outfile))[0]
if not os.path.isdir(outdir):
    os.makedirs(outdir)

# Load indices containing found and missed injections
found = f['found_after_vetoes/injection_index'][:]
missed = f['missed/after_vetoes'][:]

# Load inclusive and exclusive IFARs
if opts.far_type == 'inclusive':
    ifar_found = f['found_after_vetoes/ifar'][:]
    far_title = 'Inclusive'
elif opts.far_type == 'exclusive':
    ifar_found = f['found_after_vetoes/ifar_exc'][:]
    far_title = 'Exclusive'

# Extract IFOs and vetoes
ifos, vetoes = ppu.extract_ifos_and_vetoes(trig_file, opts.veto_files,
                                           opts.veto_category)

# Load data
x_qty = opts.x_variable
y_qty = opts.y_variable

if 'eff_site_dist' in [x_qty, y_qty] and opts.ifo is None:
    err_msg = "A value for --ifo must be provided for "
    err_msg += "site specific effective distance"
    parser.error(err_msg)
    
inj_data = load_data(opts.injection_file, [x_qty, y_qty], opts, ifos)
trig_data = load_trig_data(trig_file, vetoes)

# Specify indices for found and missed injections
fxvals = inj_data[x_qty][found]
mxvals = inj_data[x_qty][missed] 
fyvals = inj_data[y_qty][found]
myvals = inj_data[y_qty][missed]

logging.info('Data loaded.')

sitename = {'G1':'GEO', 'H1':'Hanford', 'L1':'Livingston', 'V1':'Virgo',
            'K1':'KAGRA'}
labels={'mchirp': "Chirp Mass (solar masses)",
        'mtotal': "Total mass (solar masses)",
        'q': "Mass ratio",
        'distance': "Distance (Mpc)",
        'eff_site_dist': "%s effective distance (Mpc)" % sitename.get(opts.ifo),
        'eff_dist': "Inverse sum of effective distances (Mpc)",
        'end_time': "Time since %d (s)" % grb_time,
        'coa_phase': "Phase of complex SNR (radians)",
        'latitude': "Latitude (radians)",
        'longitude': "Longitude (radians)",
        'incl': "Inclination (iota)",
        'abs_incl': 'Magnitude of inclination (|iota|)',
        'cos_incl': "cos(iota)",
        'cos_abs_incl': "cos(|iota|)",
        'mass1': "Mass of 1st binary component (solar masses)",
        'mass2': "Mass of 2nd binary component (solar masses)",
        'polarization': "Polarization phase (radians)",
        'spin1': "Spin on 1st binary component",
        'spin1x': "Spin x-component of 1st binary component",
        'spin1y': "Spin y-component of 1st binary component",
        'spin1z': "Spin z-component of 1st binary component",
        'spin2': "Spin on 2nd binary component",
        'spin2x': "Spin x-component of 2nd binary component",
        'spin2y': "Spin y-component of 2nd binary component",
        'spin2z': "Spin z-component of 2nd binary component"}

logging.info('Plotting...')
if opts.missed_on_top:
  fig_title = 'Missed and Found Injections'
else:
  fig_title = 'Found and Missed Injections'

fig = plt.figure()
zmissed = opts.missed_on_top
zfound = not opts.missed_on_top

# Plot missed injections
mpoints = plt.scatter(mxvals, myvals, s=10,
                      marker='x', color='black',
                      label='missed', zorder=zmissed)

ifsort = numpy.argsort(ifar_found)
if opts.missed_on_top:
    ifsort = ifsort[::-1]

fxvals_sorted = fxvals[ifsort]
fyvals_sorted = fyvals[ifsort]
ifsorted = ifar_found[ifsort]

if not opts.gradient_far:
    color = numpy.ones(len(found))
    ten = numpy.where(ifsorted > 10)[0]
    hundred = numpy.where(ifsorted > 100)[0]
    thousand = numpy.where(ifsorted > 1000)[0]
    color[hundred] = 0.5
    color[thousand] = 0

    norm = matplotlib.colors.Normalize()
    caption = (fig_title + ": Black x's are missed injections. "
              "Blue circles are found with IFAR < 100 years, gray are < "
              "1000 years, and yellow are found with IFAR >=1000 years. ")
else:
    color = 1.0 / ifsorted
    if len(color) < 2:
        color=None

    norm = matplotlib.colors.LogNorm()
    caption = (fig_title + ": Black x's are missed injections. "
               "Circles are found injections. The color indicates the value "
               "of the false alarm rate." )

# Plot found injections
points = plt.scatter(fxvals_sorted, fyvals_sorted, c=color, linewidth=0, s=30, norm=norm,
                      marker='o', label='found', zorder=zfound,
                      cmap=opts.colormap)
if opts.gradient_far:
    try:
        c = plt.colorbar()
        c.set_label('False Alarm Rate $(yr^{-1})$, %s' % far_title)

        # Set up tick labels - there will always be 5
        min_tick = numpy.ceil(min(numpy.log10(color)))
        max_tick = numpy.floor(max(numpy.log10(color)))
        tick_step = numpy.floor((max_tick - min_tick) / 5)
        ticks = numpy.arange(min_tick, max_tick, tick_step)
        c.set_ticks(numpy.power(10, ticks))
    except (TypeError, ZeroDivisionError):
        # Can't make colorbar if no quiet found injections
        if len(fxvals_sorted):
            raise

if opts.missed_on_top:
  caption += "Missed injections are shown on top of found injections."
else:
  caption += "Found injections are shown on top of missed injections."

ax = plt.gca()
plt.xlabel(labels[x_qty])
plt.ylabel(labels[y_qty])
plt.grid()

if opts.x_log:
    # log x axis may fail for some choices, eg effective spin
    ax.set_xscale('log')
    tmpxvals = list(mxvals)
    tmpxvals += list(fxvals)
    xmax = 1.4 * max(tmpxvals)
    xmin = 0.7 * min(tmpxvals)
    plt.xlim(xmin, xmax)
if opts.y_log:
    ax.set_yscale('log')

tmpyvals = list(fyvals) + list(myvals)
ymax = 1.2 * max(tmpyvals)
ymin = 0.9 * min(tmpyvals)

# note: ymin=0 will clash with opts.y_log
# in that case it *should* throw an error!
plt.ylim(ymin, ymax)

if opts.y_variable == 'redshift':
    # default y limit: min redshift 0
    plt.ylim(ymin=0, ymax=ymax)
else:
    # arbitrary limit of 1 distance-unit or snr-unit
    plt.ylim(ymin=1, ymax=ymax)

# Handle axis limits when plotting spins
max_missed_inj = {}
for key in ['spin1', 'spin2']:
    if key in y_qty:
        max_missed_inj[y_qty] = myvals.max()
    if key in x_qty:
        max_missed_inj[x_qty] = mxvals.max()
if "spin" in x_qty:
    ax.set_xlim([0, numpy.ceil(10 * max(max_missed_inj[x_qty],
                                     fxvals.max())) / 10])
if "spin" in y_qty:
    ax.set_ylim([0, numpy.ceil(10 * max(max_missed_inj[y_qty],
                                     fyvals.max())) / 10])

# Handle axis limits when plotting inclination
if "incl" in x_qty or "incl" in y_qty:
    max_inc = numpy.pi
    #max_inc = max(numpy.concatenate((g_found[qty], g_ifar[qty], g_missed2[qty], missed_inj[qty])))
    max_inc_deg = numpy.rad2deg(max_inc)
    max_inc_deg = numpy.ceil(max_inc_deg/10.0)*10
    max_inc = numpy.deg2rad(max_inc_deg)
    if x_qty == "incl":
        ax.set_xlim(0, max_inc_deg)
    elif x_qty == "abs_incl":
        ax.set_xlim(0, max_inc_deg*0.5)
    if y_qty == "incl":
        ax.set_ylim(0, max_inc_deg)
    elif y_qty == "abs_incl":
        ax.set_ylim(0, max_inc_deg*0.5)
    #if "cos_incl" in [x_qty, y_qty]:
    if "cos_" in [x_qty, y_qty]:
        #tt = numpy.arange(0, max_inc_deg + 10, 10)
        tt = numpy.asarray([0, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 180])
        tks = numpy.cos(numpy.deg2rad(tt))
        tk_labs = ['cos(%d deg)' % tk for tk in tt]
        #if x_qty == "cos_incl":
        if "cos_" in x_qty:
            plt.xticks(tks, tk_labs, fontsize=10)
            fig.autofmt_xdate()
            ax.set_xlim(numpy.cos(max_inc), 1)
            #ax.set_xlim(-1, 1)
        #if y_qty == "cos_incl":
        if "cos_" in y_qty:
            plt.yticks(tks, tk_labs, fontsize=10)
            fig.autofmt_xdate()
            ax.set_ylim(numpy.cos(max_inc), 1)
            #ax.set_ylim(-1, 1)
                                  
fig_kwds = {}
if '.png' in opts.output_file:
    fig_kwds['dpi'] = 200

if ('.html' in opts.output_file):
    plt.subplots_adjust(left=0.1, right=0.8, top=0.9, bottom=0.1)
    import mpld3, mpld3.plugins, mpld3.utils
    mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
    legend =  mpld3.plugins.InteractiveLegendPlugin([mpoints, points],
                                                    ['missed', 'found'],
                                                    alpha_unsel=0.1)
    mpld3.plugins.connect(fig, legend)

title = '%s: %s vs %s' % (fig_title, x_qty, y_qty)
cmd = ' '.join(sys.argv)
pycbc.results.save_fig_with_metadata(fig, opts.output_file, fig_kwds=fig_kwds,
                                     title=title, cmd=cmd, caption=caption)