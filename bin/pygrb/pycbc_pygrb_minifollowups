#!/bin/env python

# Copyright (C) 2021 Francesco Pannarale
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

"""
Temporary script to produce qscans of loudest triggers/missed injections
"""

import os
import argparse
import logging
import h5py
#from lal import GPSToUTC
import numpy as np
import pycbc.workflow.minifollowups as mini
import pycbc.version
import pycbc.workflow as wf
import pycbc.events
from pycbc.results import layout
from pycbc.results.pygrb_postprocessing_utils import get_grb_time
from pycbc.workflow.plotting import PlotExecutable

#def to_file(path, ifo=None):
#    """
#    Builds File class object from file path
#    """
#    fil = wdax.File(os.path.basename(path))
#    fil.ifo = ifo
#    path = os.path.abspath(path)
#    fil.PFN(path, 'local')
#    return fil

def add_wiki_row(outfile, cols):
    """
    Adds a wiki-formatted row to an output file from a list or a numpy array.
    """
    with open(outfile, 'a') as f:
        f.write('||%s||\n' % '||'.join(map(str, cols)))

def make_timeseries_plot(workflow, snr_type, central_time, shift_time, out_dir,
                         ifo=None, tags=[]):
    """Adds a node for a timeseries of PyGRB results to the workflow"""

    logging.info("Executable name: pycbc_pygrb_plot_snr_timeseries")
    # Initialize job node with its tags
    grb_name = workflow.cp.get('workflow', 'trigger-name')
    extra_tags = ['GRB'+grb_name]
    extra_tags += [snr_type]
    if ifo is not None:
        extra_tags += [ifo]
    node = PlotExecutable(workflow.cp, 'pygrb_plot_snr_timeseries',
                          ifos=workflow.ifos, out_dir=out_dir,
                          tags=tags+extra_tags).create_node()
    trig_file_path = workflow.cp.get('workflow', 'trig-file')
    node.add_opt('--trig-file', trig_file_path)
    # Veto directory and segments directory
    node.add_opt('--veto-directory', workflow.cp.get('workflow', 'veto-directory'))
    node.add_opt('--segment-dir', workflow.cp.get('workflow', 'segment-dir'))
    # Other shared tuning values
    for opt in ['chisq-index', 'chisq-nhigh', 'null-snr-threshold',
                'veto-category', 'snr-threshold', 'newsnr-threshold',
                'sngl-snr-threshold', 'null-grad-thresh', 'null-grad-val']:
        node.add_opt('--'+opt, workflow.cp.get('workflow', opt))
    node.new_output_file_opt(workflow.analysis_time, '.png',
                             '--output-file', tags=extra_tags)
    # Quantity to be displayed on the y-axis of the plot
    node.add_opt('--y-variable', snr_type)
    if ifo is not None:
        node.add_opt('--ifo', ifo)
    reset_central_time = shift_time - central_time
    # Horizontal axis range the = prevents errors with negative times
    x_lims = str(-5.+reset_central_time)+','+str(reset_central_time+5.)
    node.add_opt('--x-lims='+x_lims)
    # Plot title
    if ifo is not None:
        title_str = "'%s SNR at %.3f (s)'" %(ifo, central_time)
        node.add_opt('--central-time', central_time)
    else:
        title_str = "'%s SNR at %.3f (s)'" %(snr_type.capitalize(), central_time)
        node.add_opt('--central-time', central_time)
    node.add_opt('--plot-title', title_str)

    # Add job node to workflow
    workflow += node

    return node.output_files


__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_minifollowupss"

# =============================================================================
# Main script starts here
# =============================================================================
description = 'Temporary script to produce qscans of loudest triggers/missed injections.'
usage = __program__ + ' [--options]'

parser = argparse.ArgumentParser(description=__doc__[1:])
parser.add_argument('--version', action='version', version=pycbc.version.git_verbose_msg)
parser.add_argument('--workflow-name', default='my_unamed_run')
parser.add_argument("-d", "--output-dir", default=None,
                    help="Path to output directory.")
parser.add_argument('--followups-file',
                    help="HDF format file containing trigger/injections to follow up")
#parser.add_argument('--instrument', help="Name of interferometer e.g. H1")
parser.add_argument('--wiki-file',
                    help="Name of file to save wiki-formatted table in")
parser.add_argument('--output-map')
parser.add_argument('--transformation-catalog')
parser.add_argument('--output-file')
parser.add_argument('--tags', nargs='+', default=[])
wf.add_workflow_command_line_group(parser)
args = parser.parse_args()
# args.statistic_files might be a list of lists. This will flatten this to a single list.
#args.statistic_files = sum(args.statistic_files, [])

logging.basicConfig(format='%(asctime)s: %(levelname)s: %(message)s',
                    level=logging.INFO)

workflow = wf.Workflow(args, args.workflow_name)
#workflow.ifos = [args.instrument]
#workflow.ifo_string = args.instrument

wf.makedir(args.output_dir)

# create a FileList that will contain all output files
layouts = []

# Read the file with the triggers/injections to follow up
logging.info('Reading list of triggers/injections to followup')
#followups_file = to_file(args.followups_file)
#fp = h5py.File(followups_file, "r")
fp = h5py.File(args.followups_file, "r")
#followups_data = fp[list(fp.keys())[0]]
if args.wiki_file:
    # initialize a wiki table and add the column headers
    wiki_file = os.path.join(args.output_dir, args.wiki_file)
    add_wiki_row(wiki_file, fp.keys())

# Trigger time
seg_dir = workflow.cp.get('workflow', 'segment-dir')
trig_time = get_grb_time(seg_dir)

# Establish the number of follow-ups to perform
num_events = int(workflow.cp.get_opt_tags('workflow-minifollowups',
                                          'num-events', ''))
num_events = min(num_events, len(fp['BestNR'][:]))

# TODO: get ifos in a better way
ifos = args.followups_file.split('/')[-1].split('-PYGRB')[0]
ifos = [ifo+'1' for ifo in ifos.split('1')[:-1]]
num_ifos = len(ifos)

# Loop over triggers/injections to be folloed up
for num_event in range(num_events):
    files = wf.FileList([])
    logging.info('Processing event: %s', num_event)
    gps_time = fp['GPS time'][num_event]
    gps_time = gps_time.astype(np.float)
    if wiki_file:
        row = []
        for key in fp.keys():
            row.append(fp[key][num_event])
        add_wiki_row(wiki_file, row)
    # TODO: the following makes sense if injections are on unslid data.
    #       [Loudest offsource events are on time-slid data.]
    try:
        for ifo in ifos:
            time_shift = fp[ifo+' time shift (s)'][num_event]
            ifo_time = gps_time - time_shift
            files += make_timeseries_plot(workflow, 'single', gps_time, ifo_time,
                                          args.output_dir, ifo=ifo,
                                          tags=args.tags + [str(num_event)])
            files += mini.make_qscan_plot(workflow, ifo, ifo_time,
                                          args.output_dir,
                                          tags=args.tags + [str(num_event)])
    except:
        for snr_type in ['reweighted', 'coherent']:
            files += make_timeseries_plot(workflow, snr_type, gps_time, gps_time,
                                          args.output_dir, ifo=None,
                                          tags=args.tags + [str(num_event)])
        for ifo in ifos:
            files += mini.make_qscan_plot(workflow, ifo, gps_time,
                                          args.output_dir,
                                          tags=args.tags + [str(num_event)])

    layouts += list(layout.grouper(files, 2))

workflow.save(filename=args.output_file, output_map_path=args.output_map,
              transformation_catalog_path=args.transformation_catalog)
layout.two_column_layout(args.output_dir, layouts)
