#!/usr/bin/env python

# Copyright (C) 2011 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import sys
import glob
import os
import copy
import logging
from glue.ligolw import lsctables
import pycbc.version
from pycbc.results.pygrb_postprocessing_utils import extract_vetoes, extract_ifos, load_xml_file, load_xml_table, load_segment_dict, load_time_slides, load_triggers, pygrb_plot_opts_parser
## check if the following are needed 
import matplotlib,re,optparse
import numpy as np
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib import rc,cm,colors
import scipy
from scipy import stats
from ligo import segments
from glue import markup
from glue.ligolw import table,utils,ligolw
from pycbc.detector import Detector
import pycbc.results

# Deprecated
from pylal.coh_PTF_pyutils import get_bestnr,readSegFiles,get_f_resp
# import MultiInspiralUtils
from pylal import plotutils
# from pylal.dq import dqHTMLUtils

__author__  = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_efficiency"

# =============================================================================
# Main script starts here
# =============================================================================
description = 'Efficiency calculator for the triggered search (PyGRB).'
usage = __program__ + ' [--options]'
opts = pygrb_plot_opts_parser(usage=usage, description=description, version=__version__)

if opts.verbose:
    level = logging.INFO
else:
    level = logging.WARNING
logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=level)

# Check options
if opts.offsource_file == None:
    err_msg = "Please specify a path to the offsource trigger file."
    logging.error(err_msg)

if opts.veto_directory and (opts.veto_category == None):
    err_msg = "Must supply veto category if applying vetoes."
    logging.error(err_msg)
    
if (opts.found_file == None) and (opts.missed_file == None):
    opts.do_injections = False
elif (opts.found_file) and opts.missed_file:
    # TODO: do we need this option?! Should be enough to (not) provide inj_file
    opts.do_injections = True
else:
    err_msg = "Must provide both found and missed file if running injections."
    logging.error(err_msg)

if not opts.newsnr_threshold:
    opts.newsnr_threshold = opts.snr_threshold

# Store options used multiple times in local variables
outdir       = opts.output_path
trig_file    = opts.offsource_file
onsource_file = opts.onsource_file
doinj        = opts.do_injections
chisq_index = opts.chisq_index
chisq_nhigh = opts.chisq_nhigh
wf_err       = opts.waveform_error
cal_errs      = {}
cal_errs['H1']= opts.h1_cal_error
cal_errs['K1']= opts.k1_cal_error
cal_errs['L1']= opts.l1_cal_error
cal_errs['V1']= opts.v1_cal_error
cal_dc_errs       = {}
cal_dc_errs['H1'] = opts.h1_dc_cal_error
cal_dc_errs['K1'] = opts.k1_dc_cal_error
cal_dc_errs['L1'] = opts.l1_dc_cal_error
cal_dc_errs['V1'] = opts.v1_dc_cal_error
snr_thresh = opts.snr_threshold
sngl_snr_thresh = opts.sngl_snr_threshold
new_snr_thresh = opts.newsnr_threshold
null_grad_thresh = opts.null_grad_thresh
null_grad_val    = opts.null_grad_val
null_thresh        = map(float, opts.null_snr_threshold.split(','))
upper_dist = opts.upper_inj_dist
lower_dist = opts.lower_inj_dist
num_bins = opts.num_bins
# TODO: appears in other executables. Make it a function
veto_files = []
if opts.veto_directory:
    veto_string = ','.join([str(i) for i in range(2,opts.veto_category+1)])
    veto_files = glob.glob(opts.veto_directory +'/*CAT[%s]*.xml' %(veto_string))
# TODO: superseded
mass_bins = map(lambda p: map(float, p.split('-')), opts.mass_bins.split(','))
num_mc_injs = opts.num_mc_injections
    
# TODO. Random seed: eventually allow user to specify this
np.random.seed(1234)
logging.info("Setting random seed to 1234")

# Set output directory
logging.info("Setting output directory")
if not os.path.isdir(outdir):
    os.makedirs(outdir)

# Extract IFOs
# FIXME: This is nasty, we actually read the file twice, can we fix this?
# In general we may be opening re-reading things (segments too?).
logging.info("Extracting ifos") 
ifos = extract_ifos(trig_file)
# This is in PygrbFilterOutput
ifo_att = {'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t'}

# Extract vetoes
logging.info("Extracting vetoes")
vetoes = extract_vetoes(veto_files, ifos)

# Load triggers, time-slides, and segment dictionary
logging.info("Loading triggers")
trigs = load_xml_table(trig_file, lsctables.MultiInspiralTable.tableName)
#trigs = load_xml_table(trig_file, "multi_inspiral")
logging.info("Loading timeslides")
slide_dict = load_time_slides(trig_file)
logging.info("Loading segments")
segment_dict = load_segment_dict(trig_file)

# Identify the zero-lag slide
# TODO: turn most/all into a single function with load_time_slides?
#       load_triggers does a lot of this
num_slides = len(slide_dict)
zero_lag_count = [np.count_nonzero(slide_dict[i].values()) for i in range(num_slides)]
zero_lag_slide_id = zero_lag_count.index(0)
if np.count_nonzero(np.array(zero_lag_count)==0) != 1:
    err_msg = "slide_dict should contain exactly one zero lag slide."
    logging.err(err_msg)
    sys.exit()

logging.info("%d triggers loaded." % len(trigs))

# Get segments
segs = readSegFiles(opts.segment_dir)

# Separate segments
trial_time = abs(segs['on'])

# Construct trials
logging.info("Constructing trials")
trials = segments.segmentlist()
trial_dict = {}
sorted_trigs = {}

# Loop over the various slides
sorted_trig_count = 0
tmp_table = lsctables.New(lsctables.MultiInspiralTable)
for slide_id in range(num_slides):
    # Begin by sorting the triggers into each slide
    # It seems that New is pretty slow, so run it once and then use deepcopy
    sorted_trigs[slide_id] = copy.deepcopy(tmp_table)

for trig in trigs:
    sorted_trigs[int(trig.time_slide_id)].append(trig)

for slide_id in range(num_slides):
    sorted_trig_count += len(sorted_trigs[slide_id])

    # These can only *reduce* the analysis time
    curr_seg_list = segment_dict[slide_id]

    ###### TODO:below is a check we can possibly remove #####
    # Check the triggers are all in the analysed segment lists
    for trig in sorted_trigs[slide_id]:
        if trig.end_time not in curr_seg_list:
            # This can be raised if the trigger is on the segment boundary, so
            # check if the trigger is within 1/100 of a second within the list
            if (trig.get_end() + 0.01) in curr_seg_list:
                continue
            if (trig.get_end() - 0.01) in curr_seg_list:
                continue
            err_msg = "Triggers found in input files not in the list of "
            err_msg += "analysed segments. This should not happen."
            logging.err(err_msg)
            sys.exit()
    ###### end of check #####

    # Construct the buffer segment list
    buffer = segments.segmentlist()
    for ifo in ifos:
        slide_offset = slide_dict[slide_id][ifo]
        buffer.append(segments.segment(segs['buffer'][0] - slide_offset,\
                                       segs['buffer'][1] - slide_offset))
    buffer.coalesce() 

    # Construct the ifo list
    slid_vetoes = copy.deepcopy(vetoes)
    for ifo in ifos:
        slid_vetoes[ifo].shift(-slide_dict[slide_id][ifo])
            
        #### load_triggers uses the timeslide vetoes to veto trigs
        #### but the below will veto an entire offtrial if there is a
        #### veto that intersects with it. Could use the load_trigs function
        #### to first discard trigs that are vetoes and then additionally do the veto
        #### of entire segments below. 
        #### The below will for each timeslide, check how many 6s trials 
        #### can be constructed that don't intersect with the buffer or 
        #### vetoes. It will also throw away triggers if they fall into the 
        #### last bin that has a trial <6s. This might explain why a 
        #### really loud trigger that appears in offsource doesn't appear
        #### in the bestNRs list, or affect FAP.
        #### this is the only time the segment_dict and curr_seg_list is used
    
        # Construct trial list and check against buffer      
        trial_dict[slide_id] = segments.segmentlist()
        for curr_seg in curr_seg_list:
            iter_int = 0
            while 1:
                if (curr_seg[0] + trial_time*(iter_int+1)) > curr_seg[1]:
                    break
                curr_trial = segments.segment(curr_seg[0] + trial_time*iter_int,\
                                            curr_seg[0] + trial_time*(iter_int+1))
                if not buffer.intersects_segment(curr_trial):
                    for ifo in ifos:
                        if slid_vetoes[ifo].intersects_segment(curr_trial):
                            break
                    else:
                        trial_dict[slide_id].append(curr_trial)
                iter_int += 1
        # The below line works like the inverse of .veto and only returns trigs 
        # that are within the segment specified by trial_dict[slide_id]
        sorted_trigs[slide_id] = sorted_trigs[slide_id].vetoed(trial_dict[slide_id])

total_trials = sum([len(trial_dict[slide_id]) for slide_id in range(num_slides)]) 

msg = "Segments loaded and %d trials generated." % (total_trials)
logging.info(msg)

# Extract variables
# TODO: do something along the lines of PygrbFilterOutput
trig_all_time = {}
trig_all_snr = {}
trig_all_bestnr = {}
# TODO: get rid of this?
trig_all_mchirp = {}
    
for slide_id in range(num_slides):
    # Get basics
    slide_trigs = sorted_trigs[slide_id]
    trig_all_time[slide_id]   = np.asarray(slide_trigs.get_end()).astype(float)
    trig_all_snr[slide_id]    = np.asarray(slide_trigs.get_column('snr'))
    trig_all_bestnr[slide_id] = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
                                            null_thresh=null_thresh,\
                                            snr_threshold=snr_thresh,\
                                            sngl_snr_threshold=sngl_snr_thresh,\
                                            chisq_threshold=new_snr_thresh,\
                                            null_grad_thresh=null_grad_thresh,\
                                            null_grad_val=null_grad_val) \
                                 for t in slide_trigs]
    trig_all_bestnr[slide_id] = np.array(trig_all_bestnr[slide_id])
    trig_all_mchirp[slide_id] = np.asarray(slide_trigs.get_column('mchirp'))

logging.info("Basic columns extracted.")
trig_time   = {}
trig_snr    = {}
trig_bestnr = {}
time_bin_veto_max_snr = {}
time_bin_veto_max_bestnr = {}
time_bin_veto_max_snr_uncut = {}

# Define mass bins
# TODO: superseded
mass_bin = lambda mc: [i for i,b in enumerate(mass_bins) if b[0]<=mc<b[1]][0]

for slide_id in range(num_slides):
    num_slide_segs = len(trial_dict[slide_id]) 
    # Define arrays for mass bins
    trig_time[slide_id]   = {}
    trig_snr[slide_id]    = {}
    trig_bestnr[slide_id] = {}
    time_bin_veto_max_snr[slide_id] = np.zeros([len(mass_bins)+1, num_slide_segs])
    time_bin_veto_max_bestnr[slide_id] = np.zeros([len(mass_bins)+1, num_slide_segs])
    time_bin_veto_max_snr_uncut[slide_id] = np.zeros([len(mass_bins)+1, num_slide_segs])

# Check for triggers outside of mass bins if verbose
# TODO: superseded
#if verbose:
#    num_cut = 0
#    for slide_id in range(num_slides):
#        in_mass_bins = np.zeros(len(sorted_trigs[slide_id])).astype(np.bool) 
#        for i,bin in enumerate(mass_bins):
#            mass_cut = (bin[0] <= trig_all_mchirp[slide_id])\
#                            & (trig_all_mchirp[slide_id] < bin[1])
#            in_mass_bins = in_mass_bins | mass_cut
#        in_mass_bins = ~in_mass_bins
#        if in_mass_bins.any():
#            num_cut += len(in_mass_bins[in_mass_bins])
#    if num_cut:
#        msg = "Triggers outside of the given mass bins are present.\n"
#        msg += "These %d triggers will be vetoed.\n" %(num_cut)
#        logging.info(msg)

for slide_id in range(num_slides):
    # Separate triggers by mass bin and record maxima for each trial
    for i,bin in enumerate(mass_bins):
        # Construct mass_cut
        mass_cut = (bin[0] <= trig_all_mchirp[slide_id]\
                    ) & (trig_all_mchirp[slide_id] < bin[1])
        # Apply cut
        trig_time[slide_id][bin[0]]   = trig_all_time[slide_id][mass_cut]
        trig_snr[slide_id][bin[0]]    = trig_all_snr[slide_id][mass_cut]
        trig_bestnr[slide_id][bin[0]] = trig_all_bestnr[slide_id][mass_cut]

        k = 0
        for j,trial in enumerate(trial_dict[slide_id]):
            trial_cut = (trial[0] <= trig_time[slide_id][bin[0]])\
                              & (trig_time[slide_id][bin[0]] < trial[1])
            if not trial_cut.any():  continue
            # Max SNR in this mass bin and all mass bins
            time_bin_veto_max_snr[slide_id][i,j] = \
                            max(trig_snr[slide_id][bin[0]][trial_cut])
            time_bin_veto_max_snr[slide_id][-1,j] = \
                            max(time_bin_veto_max_snr[slide_id][-1,j],\
                                    time_bin_veto_max_snr[slide_id][i,j])
            # Max BestNR in this mass bin and all mass bins
            time_bin_veto_max_bestnr[slide_id][i,j]  = \
                            max(trig_bestnr[slide_id][bin[0]][trial_cut])
            time_bin_veto_max_bestnr[slide_id][-1,j] = \
                            max(time_bin_veto_max_bestnr[slide_id][-1,j],\
                                    time_bin_veto_max_bestnr[slide_id][i,j])

            # Max SNR for triggers passing SBVs in this mass bin and all mass bins
            sbv_cut = trig_bestnr[slide_id][bin[0]]!=0
            if not (trial_cut&sbv_cut).any():  continue
            time_bin_veto_max_snr_uncut[slide_id][i,j] =\
                              max(trig_snr[slide_id][bin[0]][trial_cut & sbv_cut])
            time_bin_veto_max_snr_uncut[slide_id][-1,j] =\
                              max(time_bin_veto_max_snr_uncut[slide_id][-1,j],\
                                      time_bin_veto_max_snr_uncut[slide_id][i,j])

msg = "%d mass bins seeded and SNR/bestNR maxima calculated." % (len(mass_bins))
logging.info(msg)

# Calculate and print how many bins have "No event"
quietest_fap = []
for bin_num in range(len(mass_bins)):
    num_events = 0
    for slide_id in range(num_slides):
        for trial in range(len(trial_dict[slide_id])):
            if time_bin_veto_max_bestnr[slide_id][bin_num,trial] > 0:
                num_events += 1
    quietest_fap.append(num_events/total_trials)

quietest_file=open('%s/quiet_fap_vals.txt' % outdir,'w')
for val in quietest_fap:
    print >> quietest_file, val
quietest_file.close()

# Output details of (at most) 30 loudest offsouce triggers
# TODO: Do we really want this hard-coded 30?
offsource_trigs = []
for slide_id in range(num_slides):
    trial_endtimes = [s[1] for s in trial_dict[slide_id]]
    trig_endtimes = [trig.get_end() for trig in sorted_trigs[slide_id]]
    trial_ids = np.searchsorted(trial_endtimes, trig_endtimes)
    offsource_trigs.extend(zip(trig_all_bestnr[slide_id],sorted_trigs[slide_id], trial_ids))
    # offsource_trigs.extend(zip(trig_all_bestnr[slide_id],sorted_trigs[slide_id]))
offsource_trigs.sort(key = lambda element:element[0])
offsource_trigs.reverse()

#TODO: we also want the templates spin1z and spin2z. Do this after switch to hdf5
# th: table header
th = [ 'Mass Bin', 'Trial', 'Slide Num', 'FAP', 'GPS',\
       'Rec. m1', 'Rec. m2', 'Rec. Mc',\
       'Rec. RA','Rec. Dec', 'SNR', 'Chi^2', 'Bank veto', 'Auto veto',\
       'Null SNR' ]
th.extend([ '%s SNR' % ifo for ifo in ifos ])
th.extend([ '%s time shift (s)' % ifo for ifo in ifos ])
th.append('BestNR')
# td: table data
td = []

for i in range(min(len(offsource_trigs), 30)):
    # TODO: leave this as bestNR or rename it?
    bestNR = offsource_trigs[i][0]
    trig = offsource_trigs[i][1]
    trig_slide_id = int(trig.time_slide_id)

    # Get mass bin of trigger
    # TODO: superseded
    trig_bin = None
    bin_num = 0
    for bin in mass_bins:
        if bin[0] <= trig.mchirp < bin[1]:
            if not trig_bin:
                trig_bin = bin
                trig_bin_num = bin_num
            else:
                err_msg = "Mass bins appear to overlap."
                logging.error(err_msg)
        bin_num += 1
    if not trig_bin:
        continue

    # Get trial of trigger, triggers with 'No trial' should have been removed!
    # TODO: never used again?
    end_time = trig.get_end()
    for j,trial in enumerate(trial_dict[trig_slide_id]):
        if trig.get_end() in trial:
            chunk_num = j
            break
    else:
        chunk_num = 'No trial'

    # Get FAP of trigger
    num_trials_louder = 0
    for slide_id in range(num_slides):
        for val in time_bin_veto_max_bestnr[slide_id][trig_bin_num]:
            if val > bestNR:
                num_trials_louder += 1
    FAP = num_trials_louder/total_trials
    pval = '< %.3g' % (1./total_trials) if FAP==0 else '%.3g' % FAP

    # Get null SNR of trigger
    null_snr = trig.get_null_snr()

    # TODO: trigger spin1z and spin2z wanted
    d = [ '%s-%s' % tuple(trig_bin), chunk_num, trig_slide_id, pval,\
          '%.4f' % trig.get_end(),\
          '%.2f' % trig.mass1, '%.2f' % trig.mass2, '%.2f' % trig.mchirp,\
          '%.2f' % (np.degrees(trig.ra)), '%.2f'% (np.degrees(trig.dec)),\
          '%.2f' % trig.snr, '%.2f' % trig.chisq, '%.2f' % trig.bank_chisq,\
          '%.2f' % trig.cont_chisq, '%.2f' % null_snr ]
    d.extend([ '%.2f' % getattr(trig,'snr_%s' % ifo_att[ifo])\
                          for ifo in ifos ])
    d.extend([ slide_dict[trig_slide_id][ifo] for ifo in ifos])
    d.append('%.2f' % bestNR)
    td.append(d)

# Write to html file 
# TODO (holds for most htmls below too): make this table sortable by column and not static
html = pycbc.results.dq.redirect_javascript + str(pycbc.results.static_table(td, th))
# TODO (hold for most htmls below too): Should pass output_file arg on command line and put this in a seperate executable
title = 'Parameters of loudest offsource triggers'
caption = ('Parameters of 30 loudest offsource triggers.')
pycbc.results.save_fig_with_metadata(html, "%s/loudest_offsource_trigs.html" % outdir, 
                                           {},
                                           cmd=' '.join(sys.argv),
                                           title=title,
                                           caption=caption)

# ==========================
# print loudest SNRs to file
# THIS OUTPUT FILE IS CURRENTLY UNUSED - MAYBE DELETE? 
# note: the only new info from above is the median SNR, bestNR
# and loudest SNR, so could just add this to the above's caption.
# ==========================
# Also: very similar lines of code are repeated 3-4 times
max_snr       = {}
max_bestnr    = {}
median_snr    = {}
median_bestnr = {}
    
th = ['','SNR','BestNR']
td = []

full_time_bin_veto_max_snr = {}
full_time_bin_veto_max_snr_uncut = {}
full_time_bin_veto_max_bestnr = {}
for bin_num in range(len(mass_bins)+1):
    full_time_bin_veto_max_snr[bin_num] = []
    full_time_bin_veto_max_snr_uncut[bin_num] = []
    full_time_bin_veto_max_bestnr[bin_num] = []
    for slide_id in range(num_slides):
        full_time_bin_veto_max_snr[bin_num].extend(time_bin_veto_max_snr[slide_id][bin_num])
        full_time_bin_veto_max_snr_uncut[bin_num].extend(\
                        time_bin_veto_max_snr_uncut[slide_id][bin_num])
        full_time_bin_veto_max_bestnr[bin_num].extend(\
                        time_bin_veto_max_bestnr[slide_id][bin_num])
    full_time_bin_veto_max_snr[bin_num].sort()
    full_time_bin_veto_max_snr_uncut[bin_num].sort()
    full_time_bin_veto_max_bestnr[bin_num].sort()
    
bin_num = 0
for bin in mass_bins:
    max_snr[bin[0]]    = max([trig_snr[slide_id][bin[0]].max() if len(trig_snr[slide_id][bin[0]]) else 0 for slide_id in range(num_slides)])
    max_bestnr[bin[0]] = max([trig_bestnr[slide_id][bin[0]].max() if len(trig_snr[slide_id][bin[0]]) else 0 for slide_id in range(num_slides)])

    if (total_trials % 2):
        median_snr[bin[0]] = (full_time_bin_veto_max_snr[bin_num])\
                        [(total_trials - 1) // 2]
        median_bestnr[bin[0]] = (full_time_bin_veto_max_bestnr[bin_num])\
                        [(total_trials - 1) // 2]
    else:
        median_snr[bin[0]] = np.mean( (full_time_bin_veto_max_snr[bin_num])\
                                                        [total_trials//2 - 1 : total_trials//2 + 1])
        median_bestnr[bin[0]] = np.mean( (full_time_bin_veto_max_bestnr[bin_num])\
                                                        [total_trials//2 - 1 : total_trials//2 + 1])

    bin_num += 1

    d = [ 'Loudest in Mchirp bin %s - %s' % tuple(bin), max_snr[bin[0]],\
                max_bestnr[bin[0]] ]
    td.append(d)
    d = [ 'Median in Mchirp bin %s - %s' % tuple(bin), median_snr[bin[0]],\
                  median_bestnr[bin[0]] ]
    td.append(d)
    td.append([]) 
  
# Work out all mass bins
max_snr['all'] = np.array(max_snr.values()).max()
max_bestnr['all'] = np.array(max_bestnr.values()).max()
median_snr['all'] = (full_time_bin_veto_max_snr[bin_num])\
                [total_trials //2]
median_bestnr['all'] = (full_time_bin_veto_max_bestnr[bin_num])\
                [total_trials//2]

# Print to html table
d = [ "Loudest in all bins", max_snr['all'], max_bestnr['all'] ]
td.append(d)
d = [ "Median in all bins", median_snr['all'], median_bestnr['all'] ]
td.append(d)

# Write html table with results
html = pycbc.results.dq.redirect_javascript + str(pycbc.results.static_table(td, th))
title = 'Re-weighted SNR and SNR of the loudest and median offsource trigger'
caption = ('Re-weighted SNR and SNR of the loudest and median offsource trigger')
pycbc.results.save_fig_with_metadata(html, "%s/loudest_median_offsource.html" % outdir, 
                                           {},
                                           cmd=' '.join(sys.argv),
                                           title=title,
                                           caption=caption)

# TODO: turn into a function; see if pygrb_postprocessing_utils.load_triggers will do
# =======================
# Load on source triggers
# ======================= 
if onsource_file:

    # Get trigs
    on_trigs = load_xml_table(onsource_file, "multi_inspiral")
    msg = "%d onsource triggers loaded." % (len(on_trigs))

    # Separate off chirp mass column
    on_mchirp = on_trigs.get_column('mchirp')

    # Set loudest event arrays
    loud_on_bestnr_trigs = dict((bin[0], None) for bin in mass_bins)
    loud_on_snr_trigs    = dict((bin[0], None) for bin in mass_bins)
    loud_on_bestnr      = dict((bin[0], 0) for bin in mass_bins)
    loud_on_fap         = dict((bin[0], 1) for bin in mass_bins)
    loud_on_snr         = dict((bin[0], 0) for bin in mass_bins)

    # Loop over mass bins recording loudest trig by SNR and BestNR
    for i,bin in enumerate(mass_bins):
        mass_cut = (bin[0] <= on_mchirp) & (on_mchirp < bin[1])
        if not mass_cut.any():
            loud_on_bestnr_trigs[bin[0]] = None
            loud_on_bestnr[bin[0]] = 0
        else:
            binTrigs = sorted(np.asarray(on_trigs)[mass_cut],\
                                                key=lambda t: t.snr, reverse=True)
            loud_on_snr_trigs[bin[0]] = binTrigs[0]
            loud_on_snr[bin[0]]      = binTrigs[0].snr
            binTrigs.sort(key=lambda t: get_bestnr(t, q=chisq_index, n=chisq_nhigh,\
                                                      null_thresh=null_thresh,snr_threshold=snr_thresh,\
                                                      sngl_snr_threshold = sngl_snr_thresh,\
                                                      chisq_threshold = new_snr_thresh,\
                                                      null_grad_thresh = null_grad_thresh,\
                                                      null_grad_val = null_grad_val),   reverse=True)
            loud_on_bestnr_trigs[bin[0]] = binTrigs[0]
            loud_on_bestnr[bin[0]] = get_bestnr(binTrigs[0], q=chisq_index,\
                                                      null_thresh=null_thresh,snr_threshold=snr_thresh,\
                                                      sngl_snr_threshold = sngl_snr_thresh,\
                                                      chisq_threshold = new_snr_thresh,n=chisq_nhigh,\
                                                      null_grad_thresh = null_grad_thresh,\
                                                      null_grad_val = null_grad_val)
            # If the loudest event has bestNR = 0, there is no event at all!
            if loud_on_bestnr[bin[0]] == 0:
                loud_on_bestnr_trigs[bin[0]] = None
                loud_on_bestnr[bin[0]] = 0 

    logging.info("Onsource analysed.")

    # Table header and table data
    # TODO we will want the spins too (easier to deal with after move to hdf5)
    th = ['Bin', 'FAP', 'GPS', 'Rec. m1', 'Rec. m2', 'Rec. Mc', 'Rec. RA',\
          'Rec. Dec', 'SNR', 'Chi^2', 'Bank veto', 'Auto veto', 'Null SNR'] +\
         ['%s SNR' % ifo for ifo in ifos ] + ['BestNR']
    td = [] 

    for i,bin in enumerate(mass_bins):
        if loud_on_bestnr_trigs[bin[0]]:
            trig = loud_on_bestnr_trigs[bin[0]]
            num_trials_louder = 0
            for slide_id in range(num_slides):
                num_trials_louder += sum(time_bin_veto_max_bestnr[slide_id][i] > \
                                                              loud_on_bestnr[bin[0]])
            FAP = num_trials_louder/total_trials
            pval = '< %.3g' % (1./total_trials) if FAP==0 else '%.3g' % FAP
            loud_on_fap[bin[0]] = FAP
            # TODO: spins of template
            d = ['%s-%s' % tuple(bin), pval, trig.get_end(),\
                 trig.mass1, trig.mass2, trig.mchirp,\
                 np.degrees(trig.ra), np.degrees(trig.dec),\
                 trig.snr, trig.chisq, trig.bank_chisq,\
                 trig.cont_chisq, null_snr] + \
                 [trig.get_sngl_snr(ifo) for ifo in ifos] + [loud_on_bestnr[bin[0]]]
            # TODO: Would be good to rename or remove the below output file
            with open('%s/loud_numbers.txt' % outdir, 'w') as file2:
                file2.write('%s\n' % pval.replace('<', '&lt'))
            td.append(d)

        else:
            td.append(["In mass bin %s to %s there are no events" % tuple(bin)])
            with open('%s/loud_numbers.txt' % outdir, 'w') as file2:
                file2.write('-2\n')
        bin_num += 1


    # Write to html file 
    html = pycbc.results.dq.redirect_javascript + str(pycbc.results.static_table(td, th))
    title = 'Loudest event'
    caption = ('Recovered parameters and statistic values of the loudest trigger')
    pycbc.results.save_fig_with_metadata(html, "%s/loudest_events.html" % outdir, 
                                               {},
                                               cmd=' '.join(sys.argv),
                                               title=title,
                                               caption=caption)
else:
    for i,bin in enumerate(massBins):
        totOffSNR = np.array([])
        for slideID in range(numSlides):
            totOffSNR = np.concatenate([totOffSNR,timeBinVetoMaxBestNR[slideID][i]])
        medSNR = np.median(totOffSNR)
        FAP = sum(totOffSNR>medSNR)/totalTrials


# Make the cumulative histogram FAP plots
# TODO: all plots should be calls to function(s)
# pygrb_shared_plot_setups()

# FIXME: Quick shot still using pylal. Use PyCBC and move to pygrb_postprocessing_utils.py
def pygrb_histogram(data, xlabel, ylabel, fig_path, title=None, ymax=1.2, num_bins=50):
    fig = plt.figure()
    ax = fig.gca()
    cumplot = plotutils.CumulativeHistogramPlot(xlabel, ylabel, title)
    cumplot.add_background([item] for item in data)
    cumplot.finalize(num_bins=num_bins)
    cumplot.ax.set_ylim(ymax=ymax)
    cumplot.savefig(fig_path)
    plt.close()

# Plot cumulative histograms
for i,bin in enumerate(mass_bins):
    np.savetxt('%s/bestnr_vs_fap_%s_%s_numbers.txt' %(outdir, bin[0], bin[1]),
                          full_time_bin_veto_max_bestnr[i], delimiter='/t')
    # Histo 1
    fig_path = '%s/bestnr_vs_fap_%s_%s.png' % (outdir, bin[0], bin[1])
    pygrb_histogram(full_time_bin_veto_max_bestnr[i],
                    "BestNR", "False alarm probability",
                    fig_path)

    # Histo 2
    fig_path = '%s/snr_vs_fap_%s_%s.png' % (outdir, bin[0], bin[1])
    pygrb_histogram(full_time_bin_veto_max_snr[i],
                    "SNR", "False alarm probability",
                    fig_path)

    # Histo 3 
    fig_path = '%s/snruncut_vs_fap_%s_%s.png' % (outdir, bin[0], bin[1])
    pygrb_histogram(full_time_bin_veto_max_snr_uncut[i],
                    "SNR after signal based vetoes", "False alarm probability",
                    fig_path)

# FP: HERE
    #
    # Now we can start dealing with the injections
    #
# TODO: turn most/all into a single function with load_time_slides?
#       load_triggers does a lot of this
# I don't think the following was indented originally. We have to check.

    if doinj:

        sites = [ifo[0] for ifo in ifos]

        missedInjs = load_xml_table(opts.missed_file, "sim_inspiral").veto(vetoes.union(vetoes.keys()))

        foundInjsNoVeto = load_xml_table(opts.found_file, "sim_inspiral")
        foundTrigsNVeto = load_xml_table(opts.found_file, "multi_inspiral")

        foundInjs = lsctables.New(lsctables.SimInspiralTable)
        foundTrigs = lsctables.New(lsctables.MultiInspiralTable)

        for trig,sim in zip(foundTrigsNVeto,foundInjsNoVeto):
            if sim.get_end() not in vetoes.union(vetoes.keys()):
                foundInjs.append(sim)
                foundTrigs.append(trig)
    
        logging.info("Missed/found injections/triggers loaded")

        # extract columns
        foundInjTime   = np.asarray(foundInjs.get_column('geocent_end_time')) +\
                                          np.asarray(foundInjs.get_column('geocent_end_time_ns')*\
                                                                      10**-9)

        foundInjMchirp   = np.asarray(foundInjs.get_column('mchirp'))
        foundInjMtot     = np.asarray(foundInjs.get_column('mtotal'))
        foundInjEffSiteDist =\
                dict((ifo, foundInjs.get_column('eff_dist_%s' % ifo.lower()))\
                          for ifo in sites)
        foundInjEffDist  = np.power(np.power(\
                                                                    np.asarray(foundInjEffSiteDist.values()),-1)\
                                                                .sum(0),-1)
        foundInjRA       = np.asarray(foundInjs.get_column('longitude'))
        foundInjDec      = np.asarray(foundInjs.get_column('latitude'))
        foundInjDist     = np.asarray(foundInjs.get_column('distance'))

        foundTrigMchirp  = np.asarray(foundTrigs.get_column('mchirp'))
        foundTrigBestNR  = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
                                                          null_thresh=null_thresh,snr_threshold=snr_thresh,\
                                                          sngl_snr_threshold = sngl_snr_thresh,\
                                                          chisq_threshold = new_snr_thresh,\
                                                          null_grad_thresh = null_grad_thresh,\
                                                          null_grad_val = null_grad_val) for t in foundTrigs]
        foundTrigBestNR  = np.asarray(foundTrigBestNR)
        foundTrigRA      = np.asarray(foundTrigs.get_column('ra'))
        foundTrigDec     = np.asarray(foundTrigs.get_column('dec'))

        foundSkyAngle    = np.arccos(np.cos(foundInjDec - foundTrigDec) -\
                                                            np.cos(foundInjDec)* np.cos(foundTrigDec) *\
                                                            (1 - np.cos(foundInjRA - foundTrigRA)))
        foundInjm1       = np.asarray(foundInjs.get_column('mass1'))
        foundInjm2       = np.asarray(foundInjs.get_column('mass2'))
        foundTrigm1      = np.asarray(foundTrigs.get_column('mass1'))
        foundTrigm2      = np.asarray(foundTrigs.get_column('mass2'))

        foundInjInc      = np.asarray(foundInjs.get_column('inclination'))
        foundTrigSNR     = np.asarray(foundTrigs.get_column('snr'))
        foundTrig_chisq   = np.asarray(foundTrigs.get_column('chisq'))
        foundTrigBank    = np.asarray(foundTrigs.get_column('bank_chisq'))
        foundTrigAuto    = np.asarray(foundTrigs.get_column('cont_chisq'))
        foundTrigNullSNR = np.asarray(foundTrigs.get_null_snr())
        foundTrigSnglSNR = dict((ifo, np.asarray(foundTrigs.get_sngl_snr(ifo)))\
                                                        for ifo in ifos)
        
        foundInjSpin1x   = np.asarray(foundInjs.get_column('spin1x'))
        foundInjSpin1y   = np.asarray(foundInjs.get_column('spin1y'))
        foundInjSpin1z   = np.asarray(foundInjs.get_column('spin1z'))
        foundInjSpin2x   = np.asarray(foundInjs.get_column('spin2x'))
        foundInjSpin2y   = np.asarray(foundInjs.get_column('spin2y'))
        foundInjSpin2z   = np.asarray(foundInjs.get_column('spin2z'))
        
        # construct conditions for found louder than background, found not louder
        # than background, and missed
        zeroFAP = np.zeros(len(foundInjs)).astype(np.bool)
        for i,bin in enumerate(mass_bins):
            mass_cut    = (bin[0] <= foundTrigMchirp) & (foundTrigMchirp < bin[1])
            zeroFAPCut = foundTrigBestNR > max_bestnr[bin[0]]
            zeroFAP    = zeroFAP | (mass_cut & zeroFAPCut)

        # non-zero FAP but bestNR > 0
        nonzeroFAP = ~zeroFAP & (foundTrigBestNR!=0)

        # missed
        missed = (~zeroFAP) & (~nonzeroFAP)

        # separate triggers into zeroFAP 'gFound', nonzeroFAP 'gIFAR', and missed
        # 'missedInj'
            
        # zero FAP
        gFoundMchirp      = foundInjMchirp[zeroFAP]
        gFoundMtot        = foundInjMtot[zeroFAP]
        gFoundm1          = foundInjm1[zeroFAP]
        gFoundm2          = foundInjm2[zeroFAP]
        gFoundEffSiteDist = dict((ifo, foundInjEffSiteDist[ifo][zeroFAP])\
                                                          for ifo in sites)
        gFoundEffDist     = foundInjEffDist[zeroFAP]
        gFoundDetStat     = foundTrigBestNR[zeroFAP]
        gFoundDist        = foundInjDist[zeroFAP]
        gFoundTime        = foundInjTime[zeroFAP]
        gFoundSkyAngle    = foundSkyAngle[zeroFAP]
        gFoundInc         = foundInjInc[zeroFAP]

        gFoundSpin1x      = foundInjSpin1x[zeroFAP]
        gFoundSpin1y      = foundInjSpin1y[zeroFAP]
        gFoundSpin1z      = foundInjSpin1z[zeroFAP]
        gFoundSpin2x      = foundInjSpin2x[zeroFAP]
        gFoundSpin2y      = foundInjSpin2y[zeroFAP]
        gFoundSpin2z      = foundInjSpin2z[zeroFAP]

        # nonzero FAP
        gIFARMchirp       = foundInjMchirp[nonzeroFAP]
        gIFARMtot         = foundInjMtot[nonzeroFAP]
        gIFAREffSiteDist  = dict((ifo, foundInjEffSiteDist[ifo][nonzeroFAP])\
                                                            for ifo in sites)
        gIFAREffDist      = foundInjEffDist[nonzeroFAP]
        gIFARDetStat      = foundTrigBestNR[nonzeroFAP]
        gIFARDist         = foundInjDist[nonzeroFAP]
        gIFARTime         = foundInjTime[nonzeroFAP]
        gIFARSkyAngle     = foundSkyAngle[nonzeroFAP]

        gIFARTrig         = np.asarray(foundTrigs)[nonzeroFAP]
        gIFARInj          = np.asarray(foundInjs)[nonzeroFAP]

        gIFARStat         = np.zeros([len(gIFARDetStat)])
        for ix, ( mc, bestNR ) in \
                                enumerate(zip(foundTrigMchirp[nonzeroFAP], gIFARDetStat)):
            try:
                gIFARStat[ix] = (full_time_bin_veto_max_bestnr[mass_bin(mc)] > bestNR).sum()
            except IndexError:
                # Trigger is outside of mass bin
                gIFARStat[ix] = total_trials
        gIFARStat = gIFARStat / total_trials
                    
        gIFARm1           = foundInjm1[nonzeroFAP]
        gIFARm2           = foundInjm2[nonzeroFAP]
        gIFARRecm1        = foundTrigm1[nonzeroFAP]
        gIFARRecm2        = foundTrigm2[nonzeroFAP]
        gIFARRecMchirp    = foundTrigMchirp[nonzeroFAP]

        gIFARInc          = foundInjInc[nonzeroFAP]
        gIFARRA           = foundInjRA[nonzeroFAP]
        gIFARDec          = foundInjDec[nonzeroFAP]
        gIFARRecRA        = foundTrigRA[nonzeroFAP]
        gIFARRecDec       = foundTrigDec[nonzeroFAP]

        gIFARSNR          = foundTrigSNR[nonzeroFAP]
        gIFARChisq        = foundTrig_chisq[nonzeroFAP]
        gIFARBank         = foundTrigBank[nonzeroFAP]
        gIFARAuto         = foundTrigAuto[nonzeroFAP]
        gIFARNull         = foundTrigNullSNR[nonzeroFAP]
        gIFARSnglSNR      = dict((ifo, foundTrigSnglSNR[ifo][nonzeroFAP])\
                                                for ifo in ifos)

        gIFARSpin1x       = foundInjSpin1x[nonzeroFAP]
        gIFARSpin1y       = foundInjSpin1y[nonzeroFAP]
        gIFARSpin1z       = foundInjSpin1z[nonzeroFAP]
        gIFARSpin2x       = foundInjSpin2x[nonzeroFAP]
        gIFARSpin2y       = foundInjSpin2y[nonzeroFAP]
        gIFARSpin2z       = foundInjSpin2z[nonzeroFAP]

        # missed
        gMissed2Mchirp    = foundInjMchirp[missed]
        gMissed2Mtot      = foundInjMtot[missed]
        gMissed2EffSiteDist = dict((ifo, foundInjEffSiteDist[ifo][missed])\
                                                          for ifo in sites)
        gMissed2EffDist   = foundInjEffDist[missed]
        gMissed2DetStat   = foundTrigBestNR[missed]
        gMissed2Dist      = foundInjDist[missed]
        gMissed2Time      = foundInjTime[missed]
        gMissed2Trig      = np.asarray(foundTrigs)[missed]
        gMissed2Inj       = np.asarray(foundInjs)[missed]
        gMissed2m1        = foundInjm1[missed]
        gMissed2m2        = foundInjm2[missed]
        gMissed2Recm1     = foundTrigm1[missed]
        gMissed2Recm2     = foundTrigm2[missed]
        gMissed2RecMchirp = foundTrigMchirp[missed]

        gMissed2RA        = foundInjRA[missed]
        gMissed2Dec       = foundInjDec[missed]
        gMissed2RecRA     = foundTrigRA[missed]
        gMissed2RecDec    = foundTrigDec[missed]
        gMissed2Inc       = foundInjInc[missed]

        gMissed2SNR       = foundTrigSNR[missed]
        gMissed2Chisq     = foundTrig_chisq[missed]
        gMissed2Bank      = foundTrigBank[missed]
        gMissed2Auto      = foundTrigAuto[missed]
        gMissed2Null      = foundTrigNullSNR[missed]
        gMissed2SnglSNR   = dict((ifo, foundTrigSnglSNR[ifo][missed])\
                                                for ifo in ifos)

        gMissed2Spin1x    = foundInjSpin1x[missed]
        gMissed2Spin1y    = foundInjSpin1y[missed]
        gMissed2Spin1z    = foundInjSpin1z[missed]
        gMissed2Spin2x    = foundInjSpin2x[missed]
        gMissed2Spin2y    = foundInjSpin2y[missed]
        gMissed2Spin2z    = foundInjSpin2z[missed]

        # set the sigma values
        injSigma     = foundTrigs.get_sigmasqs()
        # if the sigmasqs aren't populated, we can still do calibration errors,
        # but only in the 1-detector case
        for ifo in ifos:
                if sum(injSigma[ifo] == 0):
                    msg = "%s: sigmasq not set for at least one trigger." % (ifo)
                    logging.info(msg)
                if sum(injSigma[ifo] != 0) == 0: 
                    msg = "%s: sigmasq not set for any trigger." % (ifo)
                    logging.info(msg)
                    if len(ifos) == 1:
                        msg = "This is a single ifo analysis. "
                        msg += "Setting sigmasq to unity for all triggers."
                        logging.info(msg)
                        injSigma[ifo][:] = 1.


        fResp        = dict((ifo, np.asarray([get_f_resp(inj)[ifo] \
                                                for inj in foundInjs]))  for ifo in ifos)
        # fResp        = {
        #   ifo: get_antenna_response(
        #     foundInjRA, foundInjDec, foundInjTime, ifo
        #     ) 
        #     for ifo in ifos
        #   }
        # the above should work with pycbc, but for now it fails due to old version of
        # astropy. (but would work in current pycbc environment). 
        # for now lets use the "process pyGRB filter output class in utils which naturally save f_resp"
        # the old way. 

        injSigmaMult  = (np.asarray(injSigma.values()) *\
                                        np.asarray(fResp.values()))

        injSigmaTot = injSigmaMult[0,:]
        for i in range(1,len(ifos)):
            injSigmaTot += injSigmaMult[i,:]

        injSigmaMean = {}
        for ifo in ifos:
            injSigmaMean[ifo] = ((injSigma[ifo]*fResp[ifo])/injSigmaTot).mean()

        msg = "%d found injections analysed." % (len(foundInjs))
        logging.info(msg)

        #
        # process missed injections
        #

        missedInjMchirp = np.asarray(missedInjs.get_column('mchirp'))
        missedInjEffSiteDist =\
                dict((ifo, missedInjs.get_column('eff_dist_%s' % ifo.lower()))\
                          for ifo in sites)
        missedInjEffDist  = np.power(np.power(\
                                                                    np.asarray(missedInjEffSiteDist.values()),-1)\
                                                                .sum(0),-1)
        missedInjDist    = np.asarray(missedInjs.get_column('distance'))
        missedInjTime  = np.asarray(missedInjs.get_column('geocent_end_time') +\
                                                                  missedInjs.get_column('geocent_end_time_ns') *\
                                                                  10**-9)
        missedInjm1      = np.asarray(missedInjs.get_column('mass1'))
        missedInjm2      = np.asarray(missedInjs.get_column('mass2'))
        missedInjInc     = np.asarray(missedInjs.get_column('inclination'))
        missedInjRA      = np.asarray(missedInjs.get_column('longitude'))
        missedInjDec     = np.asarray(missedInjs.get_column('latitude'))

        missedInjSpin1x   = np.asarray(missedInjs.get_column('spin1x'))
        missedInjSpin1y   = np.asarray(missedInjs.get_column('spin1y'))
        missedInjSpin1z   = np.asarray(missedInjs.get_column('spin1z'))
        missedInjSpin2x   = np.asarray(missedInjs.get_column('spin2x'))
        missedInjSpin2y   = np.asarray(missedInjs.get_column('spin2y'))
        missedInjSpin2z   = np.asarray(missedInjs.get_column('spin2z'))

        missedNA         = ['N/A'] * len(missedInjs)

        if len(missedInjm1):
                minMissedInjm1 = missedInjm1.min()
                maxMissedInjm1 = missedInjm1.max()
                minMissedInjm2 = missedInjm2.min()
                maxMissedInjm2 = missedInjm2.max()
        else:
                minMissedInjm1 = 1e3
                maxMissedInjm1 = 0
                minMissedInjm2 = 1e3
                maxMissedInjm2 = 0

        if len(missedInjSpin1x):
                missedInjSpin1 = np.sqrt(missedInjSpin1x**2 + missedInjSpin1y**2 + \
                                                                  missedInjSpin1z**2)
                missedInjSpin2 = np.sqrt(missedInjSpin2x**2 + missedInjSpin2y**2 + \
                                                                  missedInjSpin2z**2)
                minMissedInjSpin1 = missedInjSpin1.min()
                maxMissedInjSpin1 = missedInjSpin1.max()
                minMissedInjSpin2 = missedInjSpin2.min()
                maxMissedInjSpin2 = missedInjSpin2.max()
        else:
                minMissedInjSpin1 = 1
                maxMissedInjSpin1 = 0
                minMissedInjSpin2 = 1
                maxMissedInjSpin2 = 0
        
        msg = "%d missed injections analysed." % (len(missedInjs))
        logging.info(msg)

        #
        # create new set of injections for efficiency calculations
        #

        totalInjs = len(foundInjs) + len(missedInjs)
        longInjDist = stats.uniform.rvs(size=totalInjs) * (upper_dist-lower_dist) +\
                                    upper_dist

        msg = "%d long distance injections created." % (totalInjs)
        logging.info(msg)

        #
        # set distance bins and data arrays 
        #

        distBins = zip(np.arange(lower_dist, upper_dist + (upper_dist-lower_dist) ,\
                                                          (upper_dist-lower_dist)/num_bins),\
                                      np.arange(lower_dist,upper_dist + (upper_dist-lower_dist),\
                                                          (upper_dist-lower_dist)/num_bins) +\
                                                          (upper_dist-lower_dist)/num_bins)
    
        numInjections      = np.zeros([len(mass_bins), len(distBins)+1])
        found_max_bestnr     = np.zeros([len(mass_bins), len(distBins)+1])
        foundOnBestNR      = np.zeros([len(mass_bins), len(distBins)+1])
        numInjections_no_mc  = np.zeros([len(mass_bins), len(distBins)+1])
        found_max_bestnr_no_mc = np.zeros([len(mass_bins), len(distBins)+1])
        foundOnBestNR_no_mc  = np.zeros([len(mass_bins), len(distBins)+1])
        
        #
        # Construct FAP list for all found injections
        #

        injFAP = np.zeros(len(foundInjs))
        injFAP[nonzeroFAP] = gIFARStat

        #
        # Calculate the amplitude error
        #

        # Begin by calculating the components from each detector
        cal_error = 0
        for ifo in ifos:
            cal_error += cal_errs[ifo]**2 * injSigmaMean[ifo]**2
        cal_error = cal_error**0.5

        maxDCCalError = max(cal_dc_errs.values())

        # Calibration phase uncertainties are neglected

        logging.info("Calibration amplitude uncertainty calculated.")

        #
        # Now create the numbers for the efficiency plots, these include calibration
        # and waveform errors. These are incorporated by running over each injection
        # 100 times, where each time we draw a random value of distance
        #

        # distribute injections
        foundInjDistMC       = np.ndarray((num_mc_injs+1, len(foundInjs)))
        foundInjDistMC[0,:]  = foundInjDist
        missedInjDistMC      = np.ndarray((num_mc_injs+1, len(missedInjs)))
        missedInjDistMC[0,:] = missedInjDist
        longInjDistMC        = np.ndarray((num_mc_injs+1, totalInjs))
        longInjDistMC[0,:]   = longInjDist
        for i in range(num_mc_injs):
            calDistRed = stats.norm.rvs(size=len(foundInjs)) * cal_error
            wavDistRed = np.abs(stats.norm.rvs(size=len(foundInjs)) * wf_err)
            foundInjDistMC[i+1,:] = foundInjDist / (maxDCCalError * \
                (1 + calDistRed) * (1 + wavDistRed))
            calDistRed = stats.norm.rvs(size=len(missedInjs)) * cal_error
            wavDistRed = np.abs(stats.norm.rvs(size=len(missedInjs)) * wf_err)
            missedInjDistMC[i+1,:] = missedInjDist / (maxDCCalError *\
                                                              (1 + calDistRed) * (1 + wavDistRed))
            calDistRed = stats.norm.rvs(size=totalInjs) * cal_error
            wavDistRed = np.abs(stats.norm.rvs(size=totalInjs) * wf_err)
            longInjDistMC[i+1,:] = longInjDist / (maxDCCalError *\
                                                          (1 + calDistRed) * (1 + wavDistRed))

        msg = "MC injection set distributed with %d iterations." % num_mc_injs
        logging.info(msg)

        # check injections against on source
        if onsource_file:
            moreSigThanOnSource = np.ndarray((len(mass_bins), len(foundInjs)))
            for i,bin in enumerate(mass_bins):
                moreSigThanOnSource[i,:] = (injFAP <= loud_on_fap[bin[0]])
            moreSigThanOnSource = moreSigThanOnSource.all(0)

        # loop over mass bins
        distance_count = np.zeros(len(distBins))
        for i,bin in enumerate(mass_bins):
            # construct mass_cut
            foundInjMassCut  = (bin[0] <= foundInjMchirp)  &(foundInjMchirp < bin[1])
            foundTrigMassCut = (bin[0] <= foundTrigMchirp) &(foundTrigMchirp < bin[1])
            missedInjMassCut = (bin[0] <= missedInjMchirp) &(missedInjMchirp < bin[1])

            foundTrigMaxBestNR = np.zeros([len(foundTrigMchirp)])
            for ix, mc in \
                                    enumerate(foundTrigMchirp):
                try:
                    foundTrigMaxBestNR[ix] = max_bestnr[mass_bins[mass_bin(mc)][0]]
                except IndexError:
                    # Trigger is outside of mass bin
                    foundTrigMaxBestNR[ix] = 0

            max_bestnrCut = (foundTrigBestNR > foundTrigMaxBestNR)

            # check louder than on source in this bin
            if onsource_file:
                foundTrigLoudOnBestNR = np.zeros([len(foundTrigMchirp)])
                for ix, mc in enumerate(foundTrigMchirp):
                    try:
                        foundTrigLoudOnBestNR[ix] = loud_on_bestnr[mass_bins[mass_bin(mc)][0]]
                    except IndexError:
                        # Trigger is outside of mass bin
                        foundTrigLoudOnBestNR[ix] = 0

                onBestNRCut  = foundTrigBestNR > foundTrigLoudOnBestNR

                #
                # check whether injection is found for the purposes of exclusion
                # distance calculation
                #
                # found if louder than all on source, or louder than
                # missed if not louder than loudest on source,
                foundExcl = onBestNRCut & (moreSigThanOnSource) & \
                                        (foundTrigBestNR != 0)
                # if not missed, doublecheck bestNR against nearby triggers
                nearTest = np.zeros((foundExcl).sum()).astype(bool)
                for j,(t,bestNR) in enumerate(zip(foundInjTime[foundExcl],foundTrigBestNR[foundExcl])):
                    if j==0:
                        print(zero_lag_slide_id)
                        print(len(trig_all_bestnr[zero_lag_slide_id]))
                        print(np.shape(np.array(trig_all_bestnr)))
                    nearBestNR  = trig_all_bestnr[zero_lag_slide_id]\
                                                [np.abs(trig_all_time[zero_lag_slide_id]-t) < opts.cluster_window]
                    nearTest[j] = ~((nearBestNR * opts.glitch_check_factor > bestNR).any())
                # apply the local test, putmask doesn't seem to work...
                #np.putmask(foundExcl, foundExcl==True, nearTest)
                c = 0
                for z,b in enumerate(foundExcl):
                    if foundExcl[z]:
                        foundExcl[z] = nearTest[c]
                        c += 1

            # loop over each random instance of the injection set
            for k in range(num_mc_injs+1): 
                # loop over the distance bins
                for j,distBin in enumerate(distBins):
                    # construct distance cut
                    foundDistCut  = (distBin[0] <= foundInjDistMC[k,:]) &\
                                                    (foundInjDistMC[k,:] < distBin[1])
                    missedDistCut = (distBin[0] <= missedInjDistMC[k,:]) &\
                                                    (missedInjDistMC[k,:] < distBin[1])
                    longDistCut   = (distBin[0] <= longInjDistMC[k,:]) &\
                                                    (longInjDistMC[k,:] < distBin[1])

                    # count all injections in this (mass, distance) bin
                    numFoundPass  = (foundInjMassCut  & foundDistCut).sum()
                    numMissedPass = (missedInjMassCut & missedDistCut).sum()
                    # apply long injections only to first mass bin
                    numLongPass   = i==0 and longDistCut.sum() or 0
                    # count only zero FAR injections
                    numZeroFAR = (foundInjMassCut & foundDistCut & max_bestnrCut).sum()
                    # count number found for exclusion
                    numExcl = (foundInjMassCut & foundDistCut & (foundExcl)).sum()

                    # record number of injections, number found for exclusion
                    # and number of zero FAR
                    if k == 0:
                        numInjections_no_mc[i,j]   += numFoundPass + numMissedPass +\
                                                                                numLongPass
                        numInjections_no_mc[i,-1]  += numFoundPass + numMissedPass +\
                                                                                numLongPass
                        found_max_bestnr_no_mc[i,j]  += numZeroFAR
                        found_max_bestnr_no_mc[i,-1] += numZeroFAR
                        foundOnBestNR_no_mc[i,j]   += numExcl
                        foundOnBestNR_no_mc[i,-1]  += numExcl
                    else:
                        numInjections[i,j]       += numFoundPass + numMissedPass +\
                                                                                numLongPass
                        numInjections[i,-1]      += numFoundPass + numMissedPass +\
                                                                                numLongPass
                        found_max_bestnr[i,j]      += numZeroFAR
                        found_max_bestnr[i,-1]     += numZeroFAR
                        foundOnBestNR[i,j]       += numExcl
                        foundOnBestNR[i,-1]      += numExcl
      
        np.savetxt('%s/foundmaxbestnr.txt' % outdir, found_max_bestnr.T)
        np.savetxt('%s/foundmaxbestnrnomc.txt' % outdir, found_max_bestnr_no_mc.T)
        np.savetxt('%s/foundonbestnr.txt' % outdir, foundOnBestNR.T)
        np.savetxt('%s/foundonbestnrnomc.txt' % outdir, foundOnBestNR_no_mc.T)
        np.savetxt('%s/numinjections.txt' % outdir, numInjections.T)
        np.savetxt('%s/numinjectionsnomc.txt' % outdir, numInjections_no_mc.T)

        logging.info("Found/missed injection efficiency calculations completed.")

        # 
        # write data to files
        #
  

  #
  # Next we make the cumulative histogram FAP plots
  #

        html = pycbc.results.dq.redirect_javascript + str(pycbc.results.static_table(td, th))
        title = 'Close injections with FAP>0.'
        caption = ('Missed injections and found injections with FAP>0.')
        pycbc.results.save_fig_with_metadata(html, "%s/quiet_found_triggers.html" % outdir, 
                                                   {},
                                                   cmd=' '.join(sys.argv),
                                                   title=title,
                                                   caption=caption)
        msg = "%d triggers written to file." % (len(td))
        logging.info(msg)

    fig = plt.figure()
    ax = fig.gca()
    cumplot = plotutils.CumulativeHistogramPlot("SNR",
                                                 "False alarm probability",
                                                 "")
    cumplot.add_background([item] for item in fullTimeBinVetoMaxSNR[i])
    cumplot.finalize(num_bins=50)
    cumplot.ax.set_ylim(ymax=1.2)
    cumplot.savefig('%s/snr_vs_fap_%s_%s.png' % (outdir, bin[0], bin[1]))
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    cumplot = plotutils.CumulativeHistogramPlot("SNR after signal based vetoes",
                                                 "False alarm probability",
                                                 "")
    cumplot.add_background([item] for item in fullTimeBinVetoMaxSNRUncut[i])
    cumplot.finalize(num_bins=50)
    cumplot.ax.set_ylim(ymax=1.2)
    cumplot.savefig('%s/snruncut_vs_fap_%s_%s.png' % (outdir, bin[0], bin[1]))
    plt.close()

  #
  # Now we can start dealing with the injections
  #

  if doinj:

    sites = [ifo[0] for ifo in ifos]

    missedInjs = load_xml_table(missedFile, "sim_inspiral").veto(vetoes.union(vetoes.keys()))

    foundInjsNoVeto = load_xml_table(foundFile, "sim_inspiral")
    foundTrigsNVeto = load_xml_table(foundFile, "multi_inspiral")

    foundInjs = lsctables.New(lsctables.SimInspiralTable)
    foundTrigs = lsctables.New(lsctables.MultiInspiralTable)

    for trig,sim in zip(foundTrigsNVeto,foundInjsNoVeto):
      if sim.get_end() not in vetoes.union(vetoes.keys()):
        foundInjs.append(sim)
        foundTrigs.append(trig)
  
    vprint("Missed/found injections/triggers loaded at "+\
                                 "%d.\n" % elapsed_time())

    # extract columns
    foundInjTime   = np.asarray(foundInjs.get_column('geocent_end_time')) +\
                     np.asarray(foundInjs.get_column('geocent_end_time_ns')*\
                                   10**-9)

    foundInjMchirp   = np.asarray(foundInjs.get_column('mchirp'))
    foundInjMtot     = np.asarray(foundInjs.get_column('mtotal'))
    foundInjEffSiteDist =\
        dict((ifo, foundInjs.get_column('eff_dist_%s' % ifo.lower()))\
             for ifo in sites)
    foundInjEffDist  = np.power(np.power(\
                                  np.asarray(foundInjEffSiteDist.values()),-1)\
                                .sum(0),-1)
    foundInjRA       = np.asarray(foundInjs.get_column('longitude'))
    foundInjDec      = np.asarray(foundInjs.get_column('latitude'))
    foundInjDist     = np.asarray(foundInjs.get_column('distance'))

    foundTrigMchirp  = np.asarray(foundTrigs.get_column('mchirp'))
    foundTrigBestNR  = [get_bestnr(t,q=chisq_index, n=chisq_nhigh,\
                             null_thresh=null_thresh,snr_threshold=snrThresh,\
                             sngl_snr_threshold = snglSnrThresh,\
                             chisq_threshold = newSnrThresh,\
                             null_grad_thresh = nullGradThresh,\
                             null_grad_val = nullGradVal) for t in foundTrigs]
    foundTrigBestNR  = np.asarray(foundTrigBestNR)
    foundTrigRA      = np.asarray(foundTrigs.get_column('ra'))
    foundTrigDec     = np.asarray(foundTrigs.get_column('dec'))

    foundSkyAngle    = np.arccos(np.cos(foundInjDec - foundTrigDec) -\
                              np.cos(foundInjDec)* np.cos(foundTrigDec) *\
                              (1 - np.cos(foundInjRA - foundTrigRA)))
    foundInjm1       = np.asarray(foundInjs.get_column('mass1'))
    foundInjm2       = np.asarray(foundInjs.get_column('mass2'))
    foundTrigm1      = np.asarray(foundTrigs.get_column('mass1'))
    foundTrigm2      = np.asarray(foundTrigs.get_column('mass2'))

    foundInjInc      = np.asarray(foundInjs.get_column('inclination'))
    foundTrigSNR     = np.asarray(foundTrigs.get_column('snr'))
    foundTrigChisq   = np.asarray(foundTrigs.get_column('chisq'))
    foundTrigBank    = np.asarray(foundTrigs.get_column('bank_chisq'))
    foundTrigAuto    = np.asarray(foundTrigs.get_column('cont_chisq'))
    foundTrigNullSNR = np.asarray(foundTrigs.get_null_snr())
    foundTrigSnglSNR = dict((ifo, np.asarray(foundTrigs.get_sngl_snr(ifo)))\
                            for ifo in ifos)
    
    foundInjSpin1x   = np.asarray(foundInjs.get_column('spin1x'))
    foundInjSpin1y   = np.asarray(foundInjs.get_column('spin1y'))
    foundInjSpin1z   = np.asarray(foundInjs.get_column('spin1z'))
    foundInjSpin2x   = np.asarray(foundInjs.get_column('spin2x'))
    foundInjSpin2y   = np.asarray(foundInjs.get_column('spin2y'))
    foundInjSpin2z   = np.asarray(foundInjs.get_column('spin2z'))
    
    # construct conditions for found louder than background, found not louder
    # than background, and missed
    zeroFAP = np.zeros(len(foundInjs)).astype(np.bool)
    for i,bin in enumerate(massBins):
      massCut    = (bin[0] <= foundTrigMchirp) & (foundTrigMchirp < bin[1])
      zeroFAPCut = foundTrigBestNR > maxBestNR[bin[0]]
      zeroFAP    = zeroFAP | (massCut & zeroFAPCut)

        file = open("%s/injection_recovery.html" % outdir, "w")
        
        finjs         = found_max_bestnr.sum(0)[:-1] / num_mc_injs
        totalinjs     = numInjections.sum(0)[:-1] / num_mc_injs
        finjs_no_mc     = found_max_bestnr_no_mc.sum(0)[:-1]
        totalinjs_no_mc = numInjections_no_mc.sum(0)[:-1]
        file.write('\n'.join(["Total injections found in bin mchirp %s to %s "\
                                                    "louder than all background in that bin using %s "\
                                                    "is: %s<br>"\
                                                    % (bin[0], bin[1], 'BestNR', found_max_bestnr[i,-1])\
                                                    for i,bin in enumerate(mass_bins)])) 

    # missed
    missed = (~zeroFAP) & (~nonzeroFAP)

        yerr_common   = totalinjs_no_mc * (2 * finjs_no_mc + 1)
        yerr_denom    = 2*totalinjs_no_mc*(totalinjs_no_mc + 1)
        yerr_vary     = (4 * totalinjs_no_mc * finjs_no_mc * (totalinjs_no_mc-finjs_no_mc)\
                                          + totalinjs_no_mc**2)**0.5
        yerr_low      = (yerr_common - yerr_vary)/yerr_denom
        yerr_low_no_mc  = (finjs_no_mc/totalinjs_no_mc) - yerr_low
        yerr_high     = (yerr_common + yerr_vary)/yerr_denom
        yerr_high_no_mc = yerr_high - (finjs_no_mc/totalinjs_no_mc)

    gFoundSpin1x      = foundInjSpin1x[zeroFAP]
    gFoundSpin1y      = foundInjSpin1y[zeroFAP]
    gFoundSpin1z      = foundInjSpin1z[zeroFAP]
    gFoundSpin2x      = foundInjSpin2x[zeroFAP]
    gFoundSpin2y      = foundInjSpin2y[zeroFAP]
    gFoundSpin2z      = foundInjSpin2z[zeroFAP]




###### Lots of plots start here --> funciton(s)!!!
        # plot efficiency
        fig = plt.figure()
        ax = fig.gca()
        ax.plot(distPlotVals, (finjs_no_mc/totalinjs_no_mc), 'g-',
                        label='No marginalisation')
        ax.errorbar(distPlotVals, (finjs_no_mc/totalinjs_no_mc),
                                yerr=[yerr_low_no_mc,yerr_high_no_mc], c = 'g')
        marg_eff = finjs / totalinjs
        if not np.isnan(marg_eff.sum()):
                ax.plot(distPlotVals, marg_eff, 'r-', label='Marginalised')
                ax.errorbar(distPlotVals, marg_eff, yerr=[yerr_lowMC,yerr_highMC],
                                        c = 'r')
        ax.legend()
        ax.grid()
        ax.set_ylim([0,1])
        ax.set_xlim(0, 2.*upper_dist - lower_dist)
        ax.set_title("Efficiency of injection finding using "+\
                                    "BestNR as detection statistic")
        ax.set_ylabel("Fraction of injections found louder than loudest background")
        ax.set_xlabel("Distance (Mpc)")
        fig.savefig('%s/BestNR_max_efficiency.png' % (outdir))
        plt.close()

        # Calculate 50% sensitive distance to file
        eff_low = finjs_no_mc/totalinjs_no_mc
        eff_idx = np.where(eff_low<0.5)[0]
        if len(eff_idx)==0:
            sens_dist = -1
            sys.stderr.write("Efficiency does not drop below 50%!\n")
        elif eff_idx[0]==0:
            sens_dist = 0
            sys.stderr.write("Efficiency below 90% in first bin!\n")
        else:
            excl_efficiency = redEfficiency
        if len(eff_idx) and eff_idx[0]!=0:
            i = eff_idx[0]
            d = distPlotVals[i]
            d_low = distPlotVals[i-1]
            e     = eff_low[i]
            e_low = eff_low[i-1]

            sens_dist = d + (e - 0.5) * (d - d_low) / (e_low - e)

        finjs     = foundOnBestNR.sum(0)[:-1] / num_mc_injs
        finjs_no_mc = foundOnBestNR_no_mc.sum(0)[:-1]

        file.write('\n'.join(["Total injections found in bin mchirp %s to %s "\
                                                    "louder than all background in that bin (and nearby "\
                                                    "triggers in the offsource) using %s is: %s<br>"\
                                                    % (bin[0], bin[1], 'BestNR', foundOnBestNR[i,-1])\
                                                    for i,bin in enumerate(mass_bins)])) 
        fig = plt.figure()
        ax = fig.gca()
        ax.grid()

        yerr_common   = totalinjs_no_mc * (2 * finjs_no_mc + 1)
        yerr_denom    = 2*totalinjs_no_mc*(totalinjs_no_mc + 1)
        yerr_vary     = (4 * totalinjs_no_mc * finjs_no_mc *\
                                          (totalinjs_no_mc - finjs_no_mc) + totalinjs_no_mc**2) ** 0.5
        yerr_low_no_mc  = (finjs_no_mc/totalinjs_no_mc) - \
                                        (yerr_common - yerr_vary)/yerr_denom
        yerr_high_no_mc = (yerr_common + yerr_vary)/yerr_denom -\
                                        (finjs_no_mc/totalinjs_no_mc)

        yerr_common   = totalinjs * (2 * finjs + 1)
        yerr_denom    = 2*totalinjs*(totalinjs + 1)
        yerr_vary     = 4 * totalinjs * finjs * (totalinjs - finjs) + totalinjs**2
        yerr_vary     = yerr_vary**0.5
        yerr_low      = (yerr_common - yerr_vary)/yerr_denom
        yerr_low      = (finjs/totalinjs) - yerr_low
        yerr_high     = (yerr_common + yerr_vary)/yerr_denom
        yerr_high     = yerr_high - (finjs/totalinjs)

        redEfficiency = (finjs/totalinjs) - (yerr_low) * scipy.stats.norm.isf(0.1)
        ax.plot(distPlotVals, (finjs_no_mc/totalinjs_no_mc), 'g-',
                        label='No marginalisation')
        ax.errorbar(distPlotVals, (finjs_no_mc/totalinjs_no_mc),
                                yerr=[yerr_low_no_mc,yerr_high_no_mc], c = 'g')
        marg_eff = finjs / totalinjs
        if not np.isnan(marg_eff.sum()):
                ax.plot(distPlotVals, marg_eff ,'r-', label='Marginalised')
                ax.errorbar(distPlotVals, marg_eff, yerr=[yerr_low,yerr_high], c = 'r')
        if not np.isnan(redEfficiency.sum()):
                ax.plot(distPlotVals, redEfficiency, 'm-',
                                label='Inc. counting errors')

        # Print efficiency curve to file
        file = open( "%s/efficiency_curve.txt" % outdir, "w" )
        for i in range(len(distPlotVals)):
                print >>file, distPlotVals[i],redEfficiency[i]
        file.close()

        ax.set_ylim([0,1])
        ax.grid()
        ax.legend()
        ax.get_legend().get_frame().set_alpha(0.5)
        ax.grid()
        ax.set_ylim([0,1])
        ax.set_xlim(0, 2.*upper_dist - lower_dist)
        ax.set_title("Efficiency of injection finding using "+\
                                  "BestNR as detection statistic")
        ax.set_ylabel("Fraction of injections found louder than "+\
                                    "loudest foreground")
        ax.set_xlabel("Distance (Mpc)")

        # Print 90% and 50% exclusion distance to file and calculate MC error
        for percentile in [50, 90]:
                eff_idx = np.where(redEfficiency < (percentile / 100.))[0]
                if len(eff_idx) == 0:
                        greenEfficiency = (finjs_no_mc / totalinjs_no_mc)
                        excl_efficiency = greenEfficiency
                        eff_idx = np.where(greenEfficiency < (percentile / 100.))[0]
                else:
                        excl_efficiency = redEfficiency
                if len(eff_idx) and eff_idx[0]!=0:
                        i = eff_idx[0]
                        d = distPlotVals[i]
                        d_low = distPlotVals[i-1]
                        e = excl_efficiency[i]
                        e_low = excl_efficiency[i-1]
                        excl_dist = d + (e - (percentile / 100.)) * (d - d_low) /\
                                        (e_low - e)
                else:
                        excl_dist = 0
                        sys.stderr.write("Efficiency below %d%% in first bin!\n"
                                                          % percentile)
                open("%s/exclusion_distance_%d.txt" % (outdir, percentile), "w")\
                                .write('%s\n' % excl_dist)
        
        open("%s/sensitive_distance.txt" % outdir, "w").write('%s\n' % sens_dist)

        ax.plot([excl_dist],[0.9],'gx')
        ax.set_ylim([0,1])
        ax.set_xlim(0, 2.*upper_dist - lower_dist)
        fig.savefig('%s/BestNR_on_efficiency.png' % (outdir))
        plt.close()

        # plot found/missed injections
        fig = plt.figure()
        ax = fig.gca()
        if len(gFoundMchirp):
            ax.scatter(gFoundMchirp, gFoundEffDist, c="g", marker='x',\
                                  edgecolors='g')
        if len(gIFARMchirp):
            p = ax.scatter(gIFARMchirp, gIFAREffDist, c=gIFARStat,\
                                          norm=colors.Normalize(0,1,clip=False), marker='o',\
                                          edgecolors='none', cmap=cm.plasma)
        if len(gMissed2Mchirp):
            ax.scatter(gMissed2Mchirp, gMissed2EffDist, c="r", marker='x',\
                                  edgecolors='r')
        if len(missedInjMchirp):
            ax.scatter(missedInjMchirp, missedInjEffDist, c="k", marker='x',\
                                  edgecolors='k')
        ax.grid()
        ax.semilogy()
        if len(gIFARMchirp):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Mchirp")
        ax.set_ylabel("Inverse sum of effective distances")
        ax.set_title("Injections found louder than loudest background event")
        #ax.set_ylim([ 0.5, 1000 ])
        fig.savefig('%s/found_missed_injections_effdist.png' % outdir)
        plt.close()

        fig = plt.figure()
        ax = fig.gca()
        if len(missedInjMchirp):
            ax.scatter(missedInjMchirp, missedInjEffDist, c="k", marker='x',\
                                  edgecolors='k')
        if len(gMissed2Mchirp):
            ax.scatter(gMissed2Mchirp, gMissed2EffDist, c="r", marker='x',\
                                  edgecolors='r')
        if len(gIFARMchirp):
            p = ax.scatter(gIFARMchirp, gIFAREffDist, c=gIFARStat,\
                                          norm=colors.Normalize(0,1,clip=False), marker='o',\
                                          edgecolors='none', cmap=cm.plasma)
        if len(gFoundMchirp):
            ax.scatter(gFoundMchirp, gFoundEffDist, c="b", marker='x',\
                                  edgecolors='g')
        ax.grid()
        ax.semilogy()
        if len(gIFARMchirp):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Mchirp")
        ax.set_ylabel("Inverse sum of effective distances")
        ax.set_title("Injections found louder than loudest background event")
        #ax.set_ylim([ 0.5, 1000 ])
        fig.savefig('%s/missed_found_injections_effdist.png' % outdir)
        plt.close()

        fig = plt.figure()
        ax = fig.gca()
        if len(gFoundTime):
            ax.scatter(gFoundTime, gFoundEffDist, c="b", marker='x', edgecolors='g')
        if len(gIFARTime):
            p = ax.scatter(gIFARTime, gIFAREffDist, c=gIFARStat,\
                                          norm=colors.Normalize(0,1,clip=False), marker='o',\
                                          edgecolors='none', cmap=cm.plasma)
        if len(gMissed2Time):
            ax.scatter(gMissed2Time, gMissed2EffDist, c="r", marker='x',\
                                  edgecolors='r')
        if len(missedInjTime):
            ax.scatter(missedInjTime, missedInjEffDist, c="k", marker='x',\
                                  edgecolors='k')
        ax.grid()
        ax.semilogy()
        if len(gIFARTime):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Time since %d" % grbTime)
        ax.set_ylabel("Inverse sum of effective distances")
        ax.set_title("Injections found louder than loudest background event")
        ax.set_xlim([ start, end ])
        #ax.set_ylim([ 0.5, 1000 ])
        fig.savefig("%s/found_missed_injections_effdist_time.png" % outdir)
        plt.close()

        fig = plt.figure()
        ax = fig.gca()
        if len(missedInjTime):
            ax.scatter(missedInjTime, missedInjEffDist, c="k", marker='x',\
                                  edgecolors='k')
        if len(gMissed2Time):
            ax.scatter(gMissed2Time, gMissed2EffDist, c="r", marker='x',\
                                  edgecolors='r')
        if len(gIFARTime):
            p = ax.scatter(gIFARTime, gIFAREffDist, c=gIFARStat,\
                                          norm=colors.Normalize(0,1,clip=False), marker='o',\
                                          edgecolors='none', cmap=cm.plasma)
        if len(gFoundTime):
            ax.scatter(gFoundTime, gFoundEffDist, c="b", marker='x', edgecolors='g')
        ax.grid()
        ax.semilogy()
        if len(gIFARTime):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Time since %d" % grbTime)
        ax.set_ylabel("Inverse sum of effective distances")
        ax.set_title("Injections found louder than loudest background event")
        ax.set_xlim([ start, end ])
        #ax.set_ylim([ 0.5, 1000 ])
        fig.savefig("%s/missed_found_injections_effdist_time.png" % outdir)
        plt.close()

        # Injections vs. spins plot
        fig = plt.figure()
        ax = fig.gca()
        ax.grid()
        foundInjSpin1 = np.sqrt(foundInjSpin1x**2 + foundInjSpin1y**2 + \
                                                        foundInjSpin1z**2)
        foundInjSpin2 = np.sqrt(foundInjSpin2x**2 + foundInjSpin2y**2 + \
                                                        foundInjSpin2z**2)
        if len(gFoundSpin1x):
            gFoundSpin1 = np.sqrt(gFoundSpin1x**2 + gFoundSpin1y**2 + \
                                                        gFoundSpin1z**2)
            gFoundSpin2 = np.sqrt(gFoundSpin2x**2 + gFoundSpin2y**2 + \
                                                        gFoundSpin2z**2)
            ax.scatter(gFoundSpin1, gFoundSpin2, c="g", marker="x",
                                  edgecolors="g")
        if len(gIFARSpin1x):
            gIFARSpin1 = np.sqrt(gIFARSpin1x**2 + gIFARSpin1y**2 + gIFARSpin1z**2)
            gIFARSpin2 = np.sqrt(gIFARSpin2x**2 + gIFARSpin2y**2 + gIFARSpin2z**2)
            p = ax.scatter(gIFARSpin1, gIFARSpin2, c=gIFARStat,
                                          norm=colors.Normalize(0, 1, clip=False), marker="o",
                                          edgecolors="none", cmap=cm.plasma)
        if len(missedInjSpin1x):
            ax.scatter(missedInjSpin1, missedInjSpin2, c="k", marker="x",
                                  edgecolors="k")
        if len(gMissed2Spin1x):
            gMissed2Spin1 = np.sqrt(gMissed2Spin1x**2 + gMissed2Spin1y**2 + \
                                                            gMissed2Spin1z**2)
            gMissed2Spin2 = np.sqrt(gMissed2Spin2x**2 + gMissed2Spin2y**2 + \
                                                            gMissed2Spin2z**2)
            ax.scatter(gMissed2Spin1, gMissed2Spin2, c="r", marker="x",
                                  edgecolors="r")
        if len(gIFARSpin1x):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Spin on 1st binary component")
        ax.set_ylabel("Spin on 2nd binary component")
        ax.set_title("Injection recovery with respect to component spins")
        ax.set_xlim([0, np.ceil(10 * max(maxMissedInjSpin1,
                                                                          foundInjSpin1.max())) / 10])
        ax.set_ylim([0, np.ceil(10 * max(maxMissedInjSpin2,
                                                                          foundInjSpin2.max())) / 10])
        fig.savefig("%s/found_missed_injections_spins.png" % outdir)
        plt.close()

        # Injections vs. masses plot
        fig = plt.figure()
        ax = fig.gca()
        ax.grid()
        if len(gFoundm1):
            ax.scatter(gFoundm1, gFoundm2, c="g", marker="x", edgecolors="g")
        if len(gIFARm1):
            p = ax.scatter(gIFARm1, gIFARm2, c=gIFARStat, edgecolors="none",
                                          norm=colors.Normalize(0, 1, clip=False), marker="o",
                                          cmap=cm.plasma)
        if len(missedInjm1):
            ax.scatter(missedInjm1, missedInjm2, c="k", marker="x", edgecolors="k")
        if len(gMissed2m1):
            ax.scatter(gMissed2m1, gMissed2m2, c="r", marker="x", edgecolors="r")
        if len(gIFARm1):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Mass of 1st binary component")
        ax.set_ylabel("Mass of 2nd binary component")
        ax.set_title("Injection recovery with respect to component masses")
        ax.set_xlim([np.floor(10 * min(minMissedInjm1, foundInjm1.min())) / 10,
                                  np.ceil(10 * max(maxMissedInjm1, foundInjm1.max())) / 10])
        ax.set_ylim([np.floor(10 * max(minMissedInjm2, foundInjm2.min())) / 10,
                                  np.ceil(10 * max(maxMissedInjm2, foundInjm2.max())) / 10])
        fig.savefig("%s/found_missed_injections_masses.png" % outdir)
        plt.close()

        # Injections vs. inclinations plot
        fig = plt.figure()
        ax = fig.gca()
        ax.grid()
        if len(gFoundInc):
            ax.scatter(gFoundMchirp, gFoundInc, c="g", marker="x", edgecolors="g")
        if len(gIFARInc):
            p = ax.scatter(gIFARMchirp, gIFARInc, c=gIFARStat, edgecolors="none",
                                          norm=colors.Normalize(0, 1, clip=False), marker="o",
                                          cmap=cm.plasma)
        if len(gMissed2Inc):
            ax.scatter(gMissed2Mchirp, gMissed2Inc, c="r", marker="x",
                                  edgecolors="r")
        if len(missedInjInc):
            ax.scatter(missedInjMchirp, missedInjInc, c="k", marker="x",
                                  edgecolors="k")
        if len(gIFARInc):
            cb = ax.figure.colorbar(p)
            cb.ax.set_ylabel("FAP")
        ax.set_xlabel("Mchirp")
        ax.set_ylabel("Inclination angle of binary")
        ax.set_title("Injection recovery with respect to inclination angle")
        fig.savefig("%s/found_missed_injections_incs.png" % outdir)
        plt.close()

        # Write inclination recovery to file
        np.savetxt("%s/found_inclinations.txt" % outdir, np.c_[gFoundTime + grbTime,
                                                                                                                      gFoundInc])
        np.savetxt("%s/total_inclinations.txt" % outdir,
                              np.c_[np.concatenate((foundInjTime, missedInjTime)),
                                          np.concatenate((foundInjInc, missedInjInc))])

        # Site-specific plots
        sitename = { 'G':'GEO', 'H':'Hanford', 'L':'Livingston', 'V':'Virgo',\
                                  'T':'TAMA' }

        for site in sites:
            fig = plt.figure()
            ax = fig.gca()
            if len(missedInjMchirp):
                ax.scatter(missedInjMchirp, missedInjEffSiteDist[site],\
                                      c="k", marker='x', edgecolors='k')
            if len(gMissed2Mchirp):
                ax.scatter(gMissed2Mchirp, gMissed2EffSiteDist[site],\
                                    c="r", marker='x', edgecolors='r')
            if len(gFoundMchirp):
                ax.scatter(gFoundMchirp, gFoundEffSiteDist[site],\
                                    c="b", marker='x', edgecolors='g')
            ax.grid()
            if len(gIFARMchirp):
                p = ax.scatter(gIFARMchirp, gIFAREffSiteDist[site],\
                                            c=gIFARStat, norm=colors.Normalize(0,1,clip=False),\
                                            marker='o', edgecolors='none', cmap=cm.plasma)
            ax.semilogy()
            if len(gIFARMchirp):
                cb = ax.figure.colorbar(p)
                cb.ax.set_ylabel("FAP")
            ax.set_xlabel("Mchirp")
            ax.set_ylabel("%s effective distance" % sitename[site])
            ax.set_title("Injections found louder than loudest background event")
            #ax.set_ylim([ 0.5, 1000 ])
            fig.savefig("%s/found_missed_injections_effdist_%s.png"\
                                      % (outdir, site.lower()))
            plt.close()

            fig = plt.figure()
            ax  = fig.gca()
            if len(missedInjTime):
                ax.scatter(missedInjTime, missedInjEffSiteDist[site],\
                                    c="k", marker='x', edgecolors='k')
            if len(gMissed2Time):
                ax.scatter(gMissed2Time, gMissed2EffSiteDist[site],\
                                    c="r", marker='x', edgecolors='r')
            if len(gFoundTime):
                ax.scatter(gFoundTime, gFoundEffSiteDist[site],\
                                    c="b", marker='x', edgecolors='g')
            ax.grid()
            if len(gIFARTime):
                p = ax.scatter(gIFARTime ,gIFAREffSiteDist[site],\
                                            c=gIFARStat, norm=colors.Normalize(0,1,clip=False),\
                                            marker='o', edgecolors='none', cmap=cm.plasma)
            ax.semilogy()
            if len(gIFARTime):
                cb = ax.figure.colorbar(p)
                cb.ax.set_ylabel("FAP")
            ax.set_xlabel("Time since %d" % grbTime)
            ax.set_ylabel("%s effective distance" % sitename[site])
            ax.set_title("Injections found louder than loudest background event")
            ax.set_xlim([ start, end ])
            #ax.set_ylim([ 0.5, 1000 ])
            fig.savefig("%s/found_missed_injections_effdist_time_%s.png"\
                                      % (outdir, site.lower()))
            plt.close()
    
    open("%s/sensitive_distance.txt" % outdir, "w").write('%s\n' % sens_dist)

    ax.plot([excl_dist],[0.9],'gx')
    ax.set_ylim([0,1])
    ax.set_xlim(0, 2.*upperDist - lowerDist)
    fig.savefig('%s/BestNR_on_efficiency.png' % (outdir))
    plt.close()

    # plot found/missed injections
    fig = plt.figure()
    ax = fig.gca()
    if len(gFoundMchirp):
      ax.scatter(gFoundMchirp, gFoundEffDist, c="g", marker='x',\
                 edgecolors='g')
    if len(gIFARMchirp):
      p = ax.scatter(gIFARMchirp, gIFAREffDist, c=gIFARStat,\
                     norm=colors.Normalize(0,1,clip=False), marker='o',\
                     edgecolors='none', cmap=cm.plasma)
    if len(gMissed2Mchirp):
      ax.scatter(gMissed2Mchirp, gMissed2EffDist, c="r", marker='x',\
                 edgecolors='r')
    if len(missedInjMchirp):
      ax.scatter(missedInjMchirp, missedInjEffDist, c="k", marker='x',\
                 edgecolors='k')
    ax.grid()
    ax.semilogy()
    if len(gIFARMchirp):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Mchirp")
    ax.set_ylabel("Inverse sum of effective distances")
    ax.set_title("Injections found louder than loudest background event")
    #ax.set_ylim([ 0.5, 1000 ])
    fig.savefig('%s/found_missed_injections_effdist.png' % outdir)
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    if len(missedInjMchirp):
      ax.scatter(missedInjMchirp, missedInjEffDist, c="k", marker='x',\
                 edgecolors='k')
    if len(gMissed2Mchirp):
      ax.scatter(gMissed2Mchirp, gMissed2EffDist, c="r", marker='x',\
                 edgecolors='r')
    if len(gIFARMchirp):
      p = ax.scatter(gIFARMchirp, gIFAREffDist, c=gIFARStat,\
                     norm=colors.Normalize(0,1,clip=False), marker='o',\
                     edgecolors='none', cmap=cm.plasma)
    if len(gFoundMchirp):
      ax.scatter(gFoundMchirp, gFoundEffDist, c="b", marker='x',\
                 edgecolors='g')
    ax.grid()
    ax.semilogy()
    if len(gIFARMchirp):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Mchirp")
    ax.set_ylabel("Inverse sum of effective distances")
    ax.set_title("Injections found louder than loudest background event")
    #ax.set_ylim([ 0.5, 1000 ])
    fig.savefig('%s/missed_found_injections_effdist.png' % outdir)
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    if len(gFoundTime):
      ax.scatter(gFoundTime, gFoundEffDist, c="b", marker='x', edgecolors='g')
    if len(gIFARTime):
      p = ax.scatter(gIFARTime, gIFAREffDist, c=gIFARStat,\
                     norm=colors.Normalize(0,1,clip=False), marker='o',\
                     edgecolors='none', cmap=cm.plasma)
    if len(gMissed2Time):
      ax.scatter(gMissed2Time, gMissed2EffDist, c="r", marker='x',\
                 edgecolors='r')
    if len(missedInjTime):
      ax.scatter(missedInjTime, missedInjEffDist, c="k", marker='x',\
                 edgecolors='k')
    ax.grid()
    ax.semilogy()
    if len(gIFARTime):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Time since %d" % grbTime)
    ax.set_ylabel("Inverse sum of effective distances")
    ax.set_title("Injections found louder than loudest background event")
    ax.set_xlim([ start, end ])
    #ax.set_ylim([ 0.5, 1000 ])
    fig.savefig("%s/found_missed_injections_effdist_time.png" % outdir)
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    if len(missedInjTime):
      ax.scatter(missedInjTime, missedInjEffDist, c="k", marker='x',\
                 edgecolors='k')
    if len(gMissed2Time):
      ax.scatter(gMissed2Time, gMissed2EffDist, c="r", marker='x',\
                 edgecolors='r')
    if len(gIFARTime):
      p = ax.scatter(gIFARTime, gIFAREffDist, c=gIFARStat,\
                     norm=colors.Normalize(0,1,clip=False), marker='o',\
                     edgecolors='none', cmap=cm.plasma)
    if len(gFoundTime):
      ax.scatter(gFoundTime, gFoundEffDist, c="b", marker='x', edgecolors='g')
    ax.grid()
    ax.semilogy()
    if len(gIFARTime):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Time since %d" % grbTime)
    ax.set_ylabel("Inverse sum of effective distances")
    ax.set_title("Injections found louder than loudest background event")
    ax.set_xlim([ start, end ])
    #ax.set_ylim([ 0.5, 1000 ])
    fig.savefig("%s/missed_found_injections_effdist_time.png" % outdir)
    plt.close()

    # Injections vs. spins plot
    fig = plt.figure()
    ax = fig.gca()
    ax.grid()
    foundInjSpin1 = np.sqrt(foundInjSpin1x**2 + foundInjSpin1y**2 + \
                            foundInjSpin1z**2)
    foundInjSpin2 = np.sqrt(foundInjSpin2x**2 + foundInjSpin2y**2 + \
                            foundInjSpin2z**2)
    if len(gFoundSpin1x):
      gFoundSpin1 = np.sqrt(gFoundSpin1x**2 + gFoundSpin1y**2 + \
                            gFoundSpin1z**2)
      gFoundSpin2 = np.sqrt(gFoundSpin2x**2 + gFoundSpin2y**2 + \
                            gFoundSpin2z**2)
      ax.scatter(gFoundSpin1, gFoundSpin2, c="g", marker="x",
                 edgecolors="g")
    if len(gIFARSpin1x):
      gIFARSpin1 = np.sqrt(gIFARSpin1x**2 + gIFARSpin1y**2 + gIFARSpin1z**2)
      gIFARSpin2 = np.sqrt(gIFARSpin2x**2 + gIFARSpin2y**2 + gIFARSpin2z**2)
      p = ax.scatter(gIFARSpin1, gIFARSpin2, c=gIFARStat,
                     norm=colors.Normalize(0, 1, clip=False), marker="o",
                     edgecolors="none", cmap=cm.plasma)
    if len(missedInjSpin1x):
      ax.scatter(missedInjSpin1, missedInjSpin2, c="k", marker="x",
                 edgecolors="k")
    if len(gMissed2Spin1x):
      gMissed2Spin1 = np.sqrt(gMissed2Spin1x**2 + gMissed2Spin1y**2 + \
                              gMissed2Spin1z**2)
      gMissed2Spin2 = np.sqrt(gMissed2Spin2x**2 + gMissed2Spin2y**2 + \
                              gMissed2Spin2z**2)
      ax.scatter(gMissed2Spin1, gMissed2Spin2, c="r", marker="x",
                 edgecolors="r")
    if len(gIFARSpin1x):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Spin on 1st binary component")
    ax.set_ylabel("Spin on 2nd binary component")
    ax.set_title("Injection recovery with respect to component spins")
    ax.set_xlim([0, np.ceil(10 * max(maxMissedInjSpin1,
                                     foundInjSpin1.max())) / 10])
    ax.set_ylim([0, np.ceil(10 * max(maxMissedInjSpin2,
                                     foundInjSpin2.max())) / 10])
    fig.savefig("%s/found_missed_injections_spins.png" % outdir)
    plt.close()

    # Injections vs. masses plot
    fig = plt.figure()
    ax = fig.gca()
    ax.grid()
    if len(gFoundm1):
      ax.scatter(gFoundm1, gFoundm2, c="g", marker="x", edgecolors="g")
    if len(gIFARm1):
      p = ax.scatter(gIFARm1, gIFARm2, c=gIFARStat, edgecolors="none",
                     norm=colors.Normalize(0, 1, clip=False), marker="o",
                     cmap=cm.plasma)
    if len(missedInjm1):
      ax.scatter(missedInjm1, missedInjm2, c="k", marker="x", edgecolors="k")
    if len(gMissed2m1):
      ax.scatter(gMissed2m1, gMissed2m2, c="r", marker="x", edgecolors="r")
    if len(gIFARm1):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Mass of 1st binary component")
    ax.set_ylabel("Mass of 2nd binary component")
    ax.set_title("Injection recovery with respect to component masses")
    ax.set_xlim([np.floor(10 * min(minMissedInjm1, foundInjm1.min())) / 10,
                 np.ceil(10 * max(maxMissedInjm1, foundInjm1.max())) / 10])
    ax.set_ylim([np.floor(10 * max(minMissedInjm2, foundInjm2.min())) / 10,
                 np.ceil(10 * max(maxMissedInjm2, foundInjm2.max())) / 10])
    fig.savefig("%s/found_missed_injections_masses.png" % outdir)
    plt.close()

    # Injections vs. inclinations plot
    fig = plt.figure()
    ax = fig.gca()
    ax.grid()
    if len(gFoundInc):
      ax.scatter(gFoundMchirp, gFoundInc, c="g", marker="x", edgecolors="g")
    if len(gIFARInc):
      p = ax.scatter(gIFARMchirp, gIFARInc, c=gIFARStat, edgecolors="none",
                     norm=colors.Normalize(0, 1, clip=False), marker="o",
                     cmap=cm.plasma)
    if len(gMissed2Inc):
      ax.scatter(gMissed2Mchirp, gMissed2Inc, c="r", marker="x",
                 edgecolors="r")
    if len(missedInjInc):
      ax.scatter(missedInjMchirp, missedInjInc, c="k", marker="x",
                 edgecolors="k")
    if len(gIFARInc):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Mchirp")
    ax.set_ylabel("Inclination angle of binary")
    ax.set_title("Injection recovery with respect to inclination angle")
    fig.savefig("%s/found_missed_injections_incs.png" % outdir)
    plt.close()

    # Write inclination recovery to file
    np.savetxt("%s/found_inclinations.txt" % outdir, np.c_[gFoundTime + grbTime,
                                                           gFoundInc])
    np.savetxt("%s/total_inclinations.txt" % outdir,
               np.c_[np.concatenate((foundInjTime, missedInjTime)),
                     np.concatenate((foundInjInc, missedInjInc))])

    # Site-specific plots
    sitename = { 'G':'GEO', 'H':'Hanford', 'L':'Livingston', 'V':'Virgo',\
                 'T':'TAMA' }

    for site in sites:
      fig = plt.figure()
      ax = fig.gca()
      if len(missedInjMchirp):
        ax.scatter(missedInjMchirp, missedInjEffSiteDist[site],\
                   c="k", marker='x', edgecolors='k')
      if len(gMissed2Mchirp):
        ax.scatter(gMissed2Mchirp, gMissed2EffSiteDist[site],\
                  c="r", marker='x', edgecolors='r')
      if len(gFoundMchirp):
        ax.scatter(gFoundMchirp, gFoundEffSiteDist[site],\
                  c="b", marker='x', edgecolors='g')
      ax.grid()
      if len(gIFARMchirp):
        p = ax.scatter(gIFARMchirp, gIFAREffSiteDist[site],\
                      c=gIFARStat, norm=colors.Normalize(0,1,clip=False),\
                      marker='o', edgecolors='none', cmap=cm.plasma)
      ax.semilogy()
      if len(gIFARMchirp):
        cb = ax.figure.colorbar(p)
        cb.ax.set_ylabel("FAP")
      ax.set_xlabel("Mchirp")
      ax.set_ylabel("%s effective distance" % sitename[site])
      ax.set_title("Injections found louder than loudest background event")
      #ax.set_ylim([ 0.5, 1000 ])
      fig.savefig("%s/found_missed_injections_effdist_%s.png"\
                   % (outdir, site.lower()))
      plt.close()

      fig = plt.figure()
      ax  = fig.gca()
      if len(missedInjTime):
        ax.scatter(missedInjTime, missedInjEffSiteDist[site],\
                  c="k", marker='x', edgecolors='k')
      if len(gMissed2Time):
        ax.scatter(gMissed2Time, gMissed2EffSiteDist[site],\
                  c="r", marker='x', edgecolors='r')
      if len(gFoundTime):
        ax.scatter(gFoundTime, gFoundEffSiteDist[site],\
                  c="b", marker='x', edgecolors='g')
      ax.grid()
      if len(gIFARTime):
        p = ax.scatter(gIFARTime ,gIFAREffSiteDist[site],\
                      c=gIFARStat, norm=colors.Normalize(0,1,clip=False),\
                      marker='o', edgecolors='none', cmap=cm.plasma)
      ax.semilogy()
      if len(gIFARTime):
        cb = ax.figure.colorbar(p)
        cb.ax.set_ylabel("FAP")
      ax.set_xlabel("Time since %d" % grbTime)
      ax.set_ylabel("%s effective distance" % sitename[site])
      ax.set_title("Injections found louder than loudest background event")
      ax.set_xlim([ start, end ])
      #ax.set_ylim([ 0.5, 1000 ])
      fig.savefig("%s/found_missed_injections_effdist_time_%s.png"\
                   % (outdir, site.lower()))
      plt.close()
  
    fig = plt.figure()
    ax = fig.gca()
    if len(missedInjMchirp):
      ax.scatter(missedInjMchirp, missedInjDist,c="k", marker='x', edgecolors='k')
    if len(gMissed2Mchirp):
      ax.scatter(gMissed2Mchirp, gMissed2Dist,c="r", marker='x',\
                  edgecolors='r')
    if len(gFoundMchirp):
      ax.scatter(gFoundMchirp, gFoundDist, c="b", marker='x', edgecolors='g')
    ax.grid()
    if len(gIFARMchirp):
      p = ax.scatter(gIFARMchirp, gIFARDist, c=gIFARStat,\
                    norm=colors.Normalize(0,1,clip=False),\
                    marker='o', edgecolors='none', cmap=cm.plasma)
    ax.semilogy()
    if len(gIFARMchirp):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Mchirp")
    ax.set_ylabel("Distance (Mpc)")
    ax.set_title("Injections found louder than loudest background event")
    #ax.set_ylim([ 0.5, 100 ])
    fig.savefig("%s/found_missed_injections_dist.png" % outdir)
    plt.close()
  
    fig = plt.figure()
    ax = fig.gca()
    if len(missedInjTime):
      ax.scatter(missedInjTime, missedInjDist, c="k", marker='x', edgecolors='k')
    if len(gMissed2Time):
      ax.scatter(gMissed2Time, gMissed2Dist, c="r", marker='x',\
                  edgecolors='r')
    if len(gFoundTime):
      ax.scatter(gFoundTime, gFoundDist, c="b", marker='x', edgecolors='g')
    ax.grid()
    if len(gIFARTime):
      p = ax.scatter(gIFARTime, gIFARDist, c=gIFARStat,\
                    norm=colors.Normalize(0,1,clip=False),\
                    marker='o', edgecolors='none', cmap=cm.plasma)
    ax.semilogy()
    if len(gIFARTime):
      cb = ax.figure.colorbar(p)
      cb.ax.set_ylabel("FAP")
    ax.set_xlabel("Time since %d" % grbTime)
    ax.set_ylabel("Distance (Mpc)")
    ax.set_title("Injections found louder than loudest background event")
    ax.set_xlim([ start, end ])
    #ax.set_ylim([ 0.5, 100 ])
    fig.savefig("%s/found_missed_injections_dist_time.png" % outdir)
    plt.close()

    # plot sky recovery
    fig = plt.figure()
    ax = fig.gca()
    if len(gFoundTime):
      ax.plot(gFoundTime, gFoundSkyAngle, 'b.')
#    if gIFARTime:
#      ax.plot(gIFARTime, gIFARSkyAngle, 'b.')
    ax.grid()
    ax.set_xlabel("Time since %d" % grbTime)
    ax.set_ylabel("Rec. sky error (radians)")
    ax.set_xlim([ start, end ])
    fig.savefig('%s/found_sky_error_time.png' % outdir)
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    if len(gFoundMchirp):
      ax.plot(gFoundMchirp, gFoundSkyAngle, 'b.')
#    if gIFARMchirp:
#      ax.plot(gIFARMchirp, gIFARSkyAngle, 'b.')
    ax.grid()
    ax.set_xlabel("Mchirp")
    ax.set_ylabel("Rec. sky error (radians)")
    fig.savefig('%s/found_sky_error_mchirp.png' % outdir)
    plt.close()

    fig = plt.figure()
    ax = fig.gca()
    if len(gFoundDist):
      ax.plot(gFoundDist, gFoundSkyAngle, 'b.')
#    if gIFARDist:
#      ax.plot(gIFARDist, gIFARSkyAngle, 'b.')
        ax.grid()
        ax.set_xlabel("Distance (Mpc)")
        ax.set_ylabel("Rec. sky error (radians)")
        ax.semilogx()
        ax.set_xlim([ 0.5,100 ])
        fig.savefig('%s/found_sky_error_distance.png' % outdir)
        plt.close()
