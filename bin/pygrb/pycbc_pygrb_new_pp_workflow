#!/usr/bin/env python

# Copyright (C) 2019 Gino Contestabile, Francesco Pannarale
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

"""
Workflow generator to run pygrb offline post-processing.
"""

from __future__ import division

import logging
import argparse
#import sys
#import glob
#import numpy
import os#,matplotlib,copy
#matplotlib.use('Agg')
#from matplotlib import rc
#)import matplotlib.pyplot as plt
#import scipy.stats
#from optparse import OptionParser
#from glue import segments
#from lal import LIGOTimeGPS
#from glue.ligolw import lsctables,table,utils,ligolw
import pycbc.version
import pycbc.workflow as _workflow
from pycbc.workflow.plotting import PlotExecutable, excludestr, requirestr
from pycbc.results import create_versioning_page, layout
#from pycbc.results.pygrb_plotting_utils import sbv_plot_handler
##### TODO: remove these dependencies!
#from pylal import MultiInspiralUtils
#from pylal.dq import dqSegmentUtils
#from pylal.coh_PTF_pyutils import get_bestnr, calculate_contours, readSegFiles, get_det_response
#####

__author__  = "Francesco Pannarale  <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_new_pp_workflow"


logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=logging.INFO)

def make_pygrb_plot_with_two_snrs(workflow, trig_file, inj_file, out_dir, \
            exclude=None, require=None, tags=[]):

    if len(tags) is not 2:
        err_msg = "tags argument of make_pygrb_plot_with_two_snrs specifies"
        err_msg += "the two SNRs to be plotted and must have 2 items."
        err_msg += "E.g. use ['coh', 'coinc'] to plot coherent SNR vs" 
        err_msg += "coincident SNR."
        raise ValueError(err_msg)
    
    #_workflow.makedir(out_dir)
    #secs = requirestr(workflow.cp.get_subsections('plots'), require)
    #secs = excludestr(secs, exclude)
    #for tag in secs:
    
    exec_name = '_'.join(tags)
    exec_name = 'pygrb_plot_'+exec_name
    print("Executable name: %s" % exec_name)
    node = PlotExecutable(workflow.cp, exec_name, \
                ifos=wflow.ifos, out_dir=out_dir, tags=[]).create_node()
                #ifos=wflow.ifos, out_dir=out_dir, tags=tags).create_node()
                #ifos=wflow.ifos, out_dir=out_dir, tags=[tag]).create_node()
    # Trigger file
    node.add_input_opt('--trig-file', trig_file)
    # Injection file: may or may not be passed
    if inj_file:
        node.add_input_opt('--inj-file', inj_file)
    # Veto directory and segments directory
    veto_dir = workflow.cp.get('workflow', 'veto-directory')
    node.add_opt('--veto-directory', veto_dir)
    seg_dir = workflow.cp.get('workflow', 'segment-dir')
    node.add_opt('--segment-dir', seg_dir)
    grb_name = workflow.cp.get('workflow', 'trigger-name')
    if inj_file:
        inj_tag = 'inj'
    else:
        inj_tag = 'noinj'
    node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name, inj_tag])
    node.new_output_file_opt(wflow.analysis_time, '.png', '--zoomed-output-file', tags=['GRB'+grb_name, 'zoom', inj_tag])
    workflow += node
    #for file in files:
    #    print file.storage_path
    #return node.output_files
    layout.two_column_layout(out_dir, [node.output_files]) 
    return node, node.output_files 

# Use the standard workflow command-line parsing routines.
_desc = __doc__[1:]
parser = argparse.ArgumentParser(description=_desc)
#parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version', version=__version__)
parser.add_argument("--workflow-name", type=str, default='pygrb_offline_pp',
                    help="Descriptive name of the analysis.")
parser.add_argument("-d", "--output-dir", default=None,
                    required=True, help="Path to output directory.")
_workflow.add_workflow_command_line_group(parser)
args = parser.parse_args()

# Create the workflow object
logging.info("Generating %s workflow" % args.workflow_name)
wflow = _workflow.Workflow(args, args.workflow_name)

logging.info("Post-processing output will be generated in %s" % args.output_dir)
if not os.path.exists(args.output_dir):
    _workflow.makedir(args.output_dir)
os.chdir(args.output_dir)
args.output_dir = '.'

# Setup results directory
rdir = layout.SectionNumber('pp_results', ['summary_information',
                                           'offsource_triggers_vs_time',
                                           'found_missed_injections',
                                           'signal_consistency',
                                           'workflow'])
_workflow.makedir(rdir.base)
_workflow.makedir(rdir['workflow'])

# Input trigger file
trig_file = wflow.cp.get('workflow', 'trig-file')
trig_file = _workflow.File.from_path(trig_file)
trig_file.tags = []
#trig_file.description='TRIGGER_FILE'
#trig_file.ifo_list=(['H1','L1','V1'])
#trig_file.segment = wflow.analysis_time

# Input injeciton file
inj_file = wflow.cp.get('workflow', 'inj-file')
inj_file = _workflow.File.from_path(inj_file)
inj_file.tags = []
inj_file.ifo_list=(['H1','L1','V1'])

plotting_nodes = []
files = _workflow.FileList([])


# Plot SNR timeseries
out_dir = rdir['offsource_triggers_vs_time']
_workflow.makedir(out_dir)
  # Coherent SNR versus time
  # Reweighted SNR versus time
  # Single IFO SNR versus time

out_dir = rdir['signal_consistency']
_workflow.makedir(out_dir)
out_dir = rdir['signal_consistency/chi_squared_tests']
_workflow.makedir(out_dir)
# Plot coherent SNR versus bank veto
# Plot coherent SNR versus auto veto
# Plot coherent SNR versus chisq veto
out_dir = rdir['signal_consistency/individual_detectors']
_workflow.makedir(out_dir)
# Plot single detector chi-square plots: non-zoomed and zoomed 
  # Bank chi-square
  # Auto chi-square
  # Standard chi-square
out_dir = rdir['signal_consistency/null_snrs']
_workflow.makedir(out_dir)
# Plot time versus null stat

# Coherent SNR versus null stat plots: non-zoomed and zoomed 
# Coherent SNR versus overwhitened null stat plots: non-zoomed and zoomed
# Coherent SNR versus rel amp 1
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'relamp1'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus rel amp 2 TODO: empty!
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'relamp2'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus norm 3: TODO empty
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'norm3'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus inclination: TODO: empty
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'inc'])
plotting_nodes.append(plot_node)
files.append(output_files)

out_dir = rdir['found_missed_injections']
_workflow.makedir(out_dir)

# Coherent SNR versus null stat plots: non-zoomed and zoomed 

#plots = []
#coh_vs_coinc_plots = make_pygrb_plot_coh_coinc(wflow, trig_file, inj_file, out_dir=rdir['signal_consistency_plots/other'], tags=['plots'])
#plots.append((coh_vs_coinc_plots,))
#plots.append(coh_vs_coinc_plots)

out_dir = rdir['signal_consistency/other']
_workflow.makedir(out_dir)

# Coherent SNR vs coincident SNR plots and results page
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'coinc'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs trace SNR plots and results page
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'trace'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coincident SNR vs trace SNR plots and results page
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coinc', 'trace'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs first loudest SNR plots and results page
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'firstloud'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs second loudest SNR plots and results page
# TODO: do something graceful if the IFOs are <2 and the plots will not be generated
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'secondloud'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs third loudest SNR plots and results page
# TODO: do something graceful if the IFOs are <3 and the plots will not be generated
#plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'thirdloud'])
#plotting_nodes.append(plot_node)
#files.append(output_files)

# Coherent SNR vs (SNR - Trace(SNR)) plots and results page
plot_node, output_files = make_pygrb_plot_with_two_snrs(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'snrminustrace'])
plotting_nodes.append(plot_node)
files.append(output_files)

#layout.group_layout(rdir['coincident_triggers'], closed_box_ifars + all_snrifar + [bank_plot[0][0]])

# Create versioning information
create_versioning_page(rdir['workflow/version'], wflow.cp)

print("Path for make_results_web_page: %s" % os.path.join(os.getcwd(), rdir.base))
_workflow.make_results_web_page(wflow, os.path.join(os.getcwd(), rdir.base), explicit_dependencies=plotting_nodes)

wflow.save()

logging.info("Written dax.")

# Read the configuration file
# typecast str from command line to File instances
#cp = configuration.WorkflowConfigParser(opts.pp_config_file)
#cp_file_name = workflow_name + ".ini" 
#with open('inference.ini', 'w') as ff:
#    cp.write(ff)
#config_file = to_file('inference.ini')
