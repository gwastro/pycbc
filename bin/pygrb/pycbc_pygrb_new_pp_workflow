#!/usr/bin/env python

# Copyright (C) 2019 Gino Contestabile, Francesco Pannarale
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

"""
Workflow generator to run pygrb offline post-processing.
"""

from __future__ import division

import logging
import argparse
#import sys
#import glob
#import numpy
import os#,matplotlib,copy
#matplotlib.use('Agg')
#from matplotlib import rc
#)import matplotlib.pyplot as plt
#import scipy.stats
#from optparse import OptionParser
#from glue import segments
#from lal import LIGOTimeGPS
#from glue.ligolw import lsctables,table,utils,ligolw
import pycbc.version
import pycbc.workflow as _workflow
from pycbc.workflow.plotting import PlotExecutable, excludestr, requirestr
from pycbc.results import create_versioning_page, layout #TODO: check usage of layout
#from pycbc.results.pygrb_plotting_utils import sbv_plot_handler
##### TODO: remove these dependencies!
#from pylal import MultiInspiralUtils
#from pylal.dq import dqSegmentUtils
#from pylal.coh_PTF_pyutils import get_bestnr, calculate_contours, readSegFiles, get_det_response
#####

__author__  = "Francesco Pannarale  <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_new_pp_workflow"


logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=logging.INFO)

def make_pygrb_skygrid_plot(workflow, trig_file, out_dir, \
            exclude=None, require=None, tags=[]):

    exec_name = 'pygrb_plot_skygrid'
    print("Executable name: %s" % exec_name)
    grb_name = workflow.cp.get('workflow', 'trigger-name')
    node = PlotExecutable(workflow.cp, exec_name, \
                ifos=wflow.ifos, out_dir=out_dir, tags=['GRB'+grb_name]).create_node()
    # Trigger file
    node.add_input_opt('--trig-file', trig_file)
    # Veto directory and segments directory
    veto_dir = workflow.cp.get('workflow', 'veto-directory')
    node.add_opt('--veto-directory', veto_dir)
    seg_dir = workflow.cp.get('workflow', 'segment-dir')
    node.add_opt('--segment-dir', seg_dir)
    node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name])
    workflow += node
    layout.two_column_layout(out_dir, [node.output_files]) 
    return node, node.output_files 

def make_pygrb_timeseries_plot(workflow, trig_file, inj_file, out_dir, \
            ifo=None, exclude=None, require=None, tags=[]):

    if len(tags) is not 2:
        err_msg = "tags argument of make_pygrb_timeseries_plot must have"
        err_msg += "2 items: the time and the quantity to be plotted."
        err_msg += "E.g., use ['time', 'coh'] for the coherent SNR timeseries."
        raise ValueError(err_msg)
    
    exec_name = '_'.join(tags)
    exec_name = 'pygrb_plot_'+exec_name
    print("Executable name: %s" % exec_name)
    node = PlotExecutable(workflow.cp, exec_name, \
                ifos=wflow.ifos, out_dir=out_dir, tags=[]).create_node()
    # Trigger file
    node.add_input_opt('--trig-file', trig_file)
    # Injection file: may or may not be passed
    if inj_file:
        node.add_input_opt('--inj-file', inj_file)
    # Veto directory and segments directory
    veto_dir = workflow.cp.get('workflow', 'veto-directory')
    node.add_opt('--veto-directory', veto_dir)
    seg_dir = workflow.cp.get('workflow', 'segment-dir')
    node.add_opt('--segment-dir', seg_dir)
    grb_name = workflow.cp.get('workflow', 'trigger-name')
    if inj_file:
        inj_tag = 'inj'
    else:
        inj_tag = 'noinj'
    if ifo is None:
        node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name, inj_tag])
    else:
        node.add_opt('--ifo', ifo)
        node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name, ifo, inj_tag])
    workflow += node
    #for file in files:
    #    print file.storage_path
    #return node.output_files
    layout.two_column_layout(out_dir, [node.output_files]) 
    return node, node.output_files 

# TODO: find better name...
def make_pygrb_signal_consistency_plot(workflow, trig_file, inj_file, out_dir, \
            ifo=None, exclude=None, require=None, tags=[]):

    if len(tags) is not 2:
        err_msg = "tags argument of make_pygrb_signal_consistency_plot specifies"
        err_msg += "the two SNRs to be plotted and must have 2 items."
        err_msg += "E.g. use ['coh', 'coinc'] to plot coherent SNR vs" 
        err_msg += "coincident SNR."
        raise ValueError(err_msg)
    
    #_workflow.makedir(out_dir)
    #secs = requirestr(workflow.cp.get_subsections('plots'), require)
    #secs = excludestr(secs, exclude)
    #for tag in secs:
    
    exec_name = '_'.join(tags)
    exec_name = 'pygrb_plot_'+exec_name
    print("Executable name: %s" % exec_name)
    node = PlotExecutable(workflow.cp, exec_name, \
                ifos=wflow.ifos, out_dir=out_dir, tags=[]).create_node()
                #ifos=wflow.ifos, out_dir=out_dir, tags=tags).create_node()
                #ifos=wflow.ifos, out_dir=out_dir, tags=[tag]).create_node()
    # Trigger file
    node.add_input_opt('--trig-file', trig_file)
    # Injection file: may or may not be passed
    if inj_file:
        node.add_input_opt('--inj-file', inj_file)
    # Veto directory and segments directory
    veto_dir = workflow.cp.get('workflow', 'veto-directory')
    node.add_opt('--veto-directory', veto_dir)
    seg_dir = workflow.cp.get('workflow', 'segment-dir')
    node.add_opt('--segment-dir', seg_dir)
    grb_name = workflow.cp.get('workflow', 'trigger-name')
    if inj_file:
        inj_tag = 'inj'
    else:
        inj_tag = 'noinj'
    if ifo is None:
        node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name, inj_tag])
        node.new_output_file_opt(wflow.analysis_time, '.png', '--zoomed-output-file', tags=['GRB'+grb_name, 'zoom', inj_tag])
    else:
        node.add_opt('--ifo', ifo)
        node.new_output_file_opt(wflow.analysis_time, '.png', '--output-file', tags=['GRB'+grb_name, ifo, inj_tag])
        node.new_output_file_opt(wflow.analysis_time, '.png', '--zoomed-output-file', tags=['GRB'+grb_name, ifo, 'zoom', inj_tag])
    workflow += node
    #for file in files:
    #    print file.storage_path
    #return node.output_files
    layout.two_column_layout(out_dir, [node.output_files]) 
    return node, node.output_files 

# Use the standard workflow command-line parsing routines.
_desc = __doc__[1:]
parser = argparse.ArgumentParser(description=_desc)
#parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version', version=__version__)
parser.add_argument("--workflow-name", type=str, default='pygrb_offline_pp',
                    help="Descriptive name of the analysis.")
parser.add_argument("-d", "--output-dir", default=None,
                    required=True, help="Path to output directory.")
_workflow.add_workflow_command_line_group(parser)
args = parser.parse_args()

# Create the workflow object
logging.info("Generating %s workflow" % args.workflow_name)
wflow = _workflow.Workflow(args, args.workflow_name)

logging.info("Post-processing output will be generated in %s" % args.output_dir)
if not os.path.exists(args.output_dir):
    _workflow.makedir(args.output_dir)
os.chdir(args.output_dir)
args.output_dir = '.'

# Setup results directory
rdir = layout.SectionNumber('pp_results', ['summary_information',
                                           'offsource_triggers_vs_time',
                                           'found_missed_injections',
                                           'signal_consistency',
                                           'workflow'])
_workflow.makedir(rdir.base)
_workflow.makedir(rdir['workflow'])

# Input trigger file
trig_file = wflow.cp.get('workflow', 'trig-file')
trig_file = _workflow.File.from_path(trig_file)
trig_file.tags = []
#trig_file.description='TRIGGER_FILE'
#trig_file.ifo_list=(['H1','L1','V1'])
#trig_file.segment = wflow.analysis_time

# Input injeciton file
inj_file = wflow.cp.get('workflow', 'inj-file')
inj_file = _workflow.File.from_path(inj_file)
inj_file.tags = [] # Cna this be used for inj/no-inj?
#inj_file.ifo_list=(['H1','L1','V1'])
inj_file.ifo_list=wflow.ifos

plotting_nodes = []
files = _workflow.FileList([])

#
# Plot sky grid 
#
out_dir = rdir['summary_information']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_skygrid_plot(wflow, trig_file, out_dir=out_dir, tags=['skygrid'])
plotting_nodes.append(plot_node)
files.append(output_files)

#
# Plot SNR timeseries
#
out_dir = rdir['offsource_triggers_vs_time']
_workflow.makedir(out_dir)
# Coherent SNR versus time
out_dir = rdir['offsource_triggers_vs_time/coh_snr_vs_time']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_timeseries_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['time', 'coh'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Reweighted SNR versus time
out_dir = rdir['offsource_triggers_vs_time/reweighted_snr_vs_time']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_timeseries_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['time', 'reweighted'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Single IFO SNR versus time
out_dir = rdir['offsource_triggers_vs_time/single_ifo_snr_vs_time']
_workflow.makedir(out_dir)
for ifo in wflow.ifos:
  plot_node, output_files = make_pygrb_timeseries_plot(wflow, trig_file, inj_file, out_dir=out_dir, ifo=ifo, tags=['time', 'ifosnr'])
  plotting_nodes.append(plot_node)
  files.append(output_files)
# Time versus null stat
out_dir = rdir['offsource_triggers_vs_time/null_snrs']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_timeseries_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['time', 'nullstat'])
plotting_nodes.append(plot_node)
files.append(output_files)

#
# Found/missed injections plots
#
out_dir = rdir['found_missed_injections']
_workflow.makedir(out_dir)

#
# Signal consistency plots
#
# TODO: repeat all calls but with inj_file set to None
out_dir = rdir['signal_consistency']
_workflow.makedir(out_dir)
# Plot coherent SNR versus bank veto
out_dir = rdir['signal_consistency/chi_squared_tests']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'bankveto'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Plot coherent SNR versus auto veto
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'autoveto'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Plot coherent SNR versus chisq veto
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'chisqveto'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Plot single detector chi-square plots: non-zoomed and zoomed 
out_dir = rdir['signal_consistency/individual_detectors']
_workflow.makedir(out_dir)
#for ifo in ifos:
#  # Bank chi-square
#  plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, ifo=ifo, tags=['coh', 'bankveto'])
#  plotting_nodes.append(plot_node)
#  files.append(output_files)
#  # Auto chi-square
#  plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, ifo=ifo, tags=['coh', 'autoveto'])
#  plotting_nodes.append(plot_node)
#  files.append(output_files)
#  # Standard chi-square
#  plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, ifo=ifo, tags=['coh', 'chisqveto'])
#  plotting_nodes.append(plot_node)
#  files.append(output_files)

# Coherent SNR versus null stat plots: non-zoomed and zoomed 
out_dir = rdir['signal_consistency/null_snrs']
_workflow.makedir(out_dir)
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'nullstat'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus overwhitened null stat plots: non-zoomed and zoomed
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'overwhitenull'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus rel amp 1
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'relamp1'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus rel amp 2 TODO: empty!
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'relamp2'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus norm 3: TODO empty
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'norm3'])
plotting_nodes.append(plot_node)
files.append(output_files)
# Coherent SNR versus inclination: TODO: empty
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'inc'])
plotting_nodes.append(plot_node)
files.append(output_files)

#plots = []
#coh_vs_coinc_plots = make_pygrb_plot_coh_coinc(wflow, trig_file, inj_file, out_dir=rdir['signal_consistency_plots/other'], tags=['plots'])
#plots.append((coh_vs_coinc_plots,))
#plots.append(coh_vs_coinc_plots)

out_dir = rdir['signal_consistency/other']
_workflow.makedir(out_dir)

# Coherent SNR vs coincident SNR plots and results page
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'coinc'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs trace SNR plots and results page
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'trace'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coincident SNR vs trace SNR plots and results page
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coinc', 'trace'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs first loudest SNR plots and results page
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'firstloud'])
plotting_nodes.append(plot_node)
files.append(output_files)

# Coherent SNR vs second loudest SNR plots and results page
if len(wflow.ifos) > 1:
  plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'secondloud'])
  plotting_nodes.append(plot_node)
  files.append(output_files)

# Coherent SNR vs third loudest SNR plots and results page
if len(wflow.ifos) > 2:
  plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'thirdloud'])
  plotting_nodes.append(plot_node)
  files.append(output_files)

# Coherent SNR vs (SNR - Trace(SNR)) plots and results page
plot_node, output_files = make_pygrb_signal_consistency_plot(wflow, trig_file, inj_file, out_dir=out_dir, tags=['coh', 'snrminustrace'])
plotting_nodes.append(plot_node)
files.append(output_files)

#layout.group_layout(rdir['coincident_triggers'], closed_box_ifars + all_snrifar + [bank_plot[0][0]])

# Create versioning information
create_versioning_page(rdir['workflow/version'], wflow.cp)

print("Path for make_results_web_page: %s" % os.path.join(os.getcwd(), rdir.base))
_workflow.make_results_web_page(wflow, os.path.join(os.getcwd(), rdir.base), explicit_dependencies=plotting_nodes)

wflow.save()

logging.info("Written dax.")

# Read the configuration file
# typecast str from command line to File instances
#cp = configuration.WorkflowConfigParser(opts.pp_config_file)
#cp_file_name = workflow_name + ".ini" 
#with open('inference.ini', 'w') as ff:
#    cp.write(ff)
#config_file = to_file('inference.ini')
