#!/usr/bin/env python
#
# Copyright (C) 2019 Gino Contestabile, Francesco Pannarale
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Produce the sky grid plot for the triggered search (PyGRB)."""

# =============================================================================
# Preamble
# =============================================================================

import sys
import os
import logging
import numpy
import h5py
from matplotlib import pyplot as plt
import matplotlib.colors as colors
from matplotlib import rc
import pycbc.version
from pycbc import init_logging
from pycbc.results import save_fig_with_metadata
from pycbc.results import pygrb_postprocessing_utils as ppu
from pycbc.detector import Detector
import pycbc.distributions

plt.switch_backend('Agg')
rc('font', size=14)

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_plot_skygrid"


def define_rows_cols_subplot(nplots):
    cols = int(numpy.sqrt(nplots + 1))
    rows = int(numpy.sqrt(nplots + 1))
    return cols, rows

# =============================================================================
# Main script starts here
# =============================================================================
parser = ppu.pygrb_initialize_plot_parser(description=__doc__)
parser.add_argument("--sky-grid", required=True,
                    help="The location of the sky grid file")
opts = parser.parse_args()

init_logging(opts.verbose, format="%(asctime)s:%(levelname)s : %(message)s")

sky_grid = os.path.abspath(opts.sky_grid)
outfile = opts.output_file
if opts.plot_title is None:
    opts.plot_title = 'PyGRB sky grid'
plot_caption = 'Search sky grid points.'

logging.info("Imported and ready to go.")

# Set output directories
outdirs = [os.path.split(os.path.abspath(outfile))[0]]
for outdir in outdirs:
    if not os.path.isdir(outdir):
        os.makedirs(outdir)

#Extract all informations from sky grid
with h5py.File(f"{sky_grid}","r") as f:
    ra , dec = f['ra'][:], f['dec'][:]
    dist = f.attrs['input_distribution'][0:25]+"../"+f.attrs['input_distribution'][-32:]
    input_dist = eval("pycbc.distributions."+dist)
    samples = input_dist.rvs(100000)
    input_ra, input_dec = samples['ra'], samples['dec'] 
    ifos = f.attrs["detectors"]
    detectors = [Detector(d) for d in ifos]
    gps_time = f.attrs['ref_gps_time']

xlabel = "RA (deg)"
ylabel = "Dec (deg)"

uni_points = pycbc.distributions.UniformSky().rvs(100000)

ant_pat = {}
quad_ant = {}


#Convert ra from [0,2*pi] to [-pi,pi] for the mollweide plot 
uni_ra = numpy.remainder(uni_points['ra'] + 2*numpy.pi, 2*numpy.pi)
uni_ra[uni_ra > numpy.pi] -= 2*numpy.pi

in_ra = numpy.remainder(input_ra+ 2*numpy.pi, 2*numpy.pi)
in_ra[in_ra > numpy.pi] -= 2*numpy.pi

grb_ra = numpy.remainder(ra + 2*numpy.pi, 2*numpy.pi)
grb_ra[grb_ra > numpy.pi] -= 2*numpy.pi

input_density, ra_edge, dec_edge = numpy.histogram2d(in_ra,input_dec, bins=100, range=[[-numpy.pi, numpy.pi], [-numpy.pi/2, numpy.pi/2]])

cols , rows = define_rows_cols_subplot(len(detectors)+1)

fig, ax = plt.subplots(nrows=rows, ncols=cols,subplot_kw=dict(projection="mollweide"), figsize=(20,20))

ax[0,0].pcolormesh(ra_edge,dec_edge,input_density.T,cmap="Greens", shading='auto', label="Input Distribution")
ax[0,0].plot(grb_ra, dec, 'x', c='red', label="Sky Grid")
cb = fig.colorbar(plt.cm.ScalarMappable(colors.Normalize(vmin=input_density.min(), vmax=input_density.max()), cmap="Greens"), location="bottom", ax=ax[0,0], label="Counts")
ax[0,0].set_xlabel("RA (deg)")
ax[0,0].set_ylabel("DEC (deg)")
ax[0,0].legend()
ax[0,0].set_title("Sky Grid over input distribution")
ax[0,0].grid(True)

ax_inset = fig.add_axes([0.6,0.6,0.3,0.3])
ax_inset.set_xlim(numpy.degrees(grb_ra.min())-5, numpy.degrees(grb_ra.max())+5)
ax_inset.set_ylim(numpy.degrees(dec.min())-5, numpy.degrees(dec.max())+5)
ax_inset.pcolormesh(numpy.degrees(ra_edge),numpy.degrees(dec_edge),input_density.T,cmap="Greens", shading='auto', label="Input Distribution")
ax_inset.plot(numpy.degrees(grb_ra), numpy.degrees(dec), 'x', c='red', label="Sky Grid")
ax_inset.grid(True)

idx_col , idx_row = 0, 1 
#Compute the antenna pattern on which we will scatter the sky grid
for det in detectors:
    if idx_col >= cols:
        idx_col = 0
        idx_row += 1
    
    ant_pat[det] = det.antenna_pattern(uni_points['ra'], uni_points['dec'], 0, t_gps=gps_time)
    quad_ant[det] = numpy.sqrt(ant_pat[det][0]**2 + ant_pat[det][1]**2)
    if opts.verbose:
        sys.stdout.write("\nPlotting...\n")
        fig_name = os.path.split(os.path.abspath(outfile))[1]
        sys.stdout.write(" * %s (%s vs %s)...\n" % (fig_name, xlabel, ylabel))
    sc = ax[idx_row,idx_col].scatter((uni_ra), (uni_points["dec"]), c=quad_ant[det], cmap="viridis")
    ax[idx_row,idx_col].scatter((grb_ra), (dec),c='red', marker='.', label="Sky grid")
    ax[idx_row,idx_col].set_title(f"Sky grid over {det.name} antenna pattern")
    plt.colorbar(sc, label="(F+² + Fx²)", location="bottom")
    ax[idx_row,idx_col].grid(True)
    ax[idx_row,idx_col].legend()
    idx_col += 1
    print(idx_col, idx_row)

# Wrap up
#plt.tight_layout()
save_fig_with_metadata(fig, outfile, cmd=' '.join(sys.argv),
                       title=opts.plot_title, caption=plot_caption)
plt.close()


