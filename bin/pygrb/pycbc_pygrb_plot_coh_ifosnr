#!/usr/bin/env python
#
# Copyright (C) 2019 Gino Contestabile, Francesco Pannarale
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

"""
Plot single IFO SNR vs coherent SNR for a PyGRB run.
"""

from __future__ import division

import sys
import glob
import os
import logging
import collections
import operator
from matplotlib import pyplot as plt
import numpy
import scipy
import pycbc.version
from pycbc.detector import Detector
from pycbc.results import save_fig_with_metadata
from pycbc.results.pygrb_postprocessing_utils import pygrb_initialize_plot_parser
from pycbc.results.pygrb_postprocessing_utils import extract_ifos_and_vetoes
from pycbc.results.pygrb_postprocessing_utils import load_injections
from pycbc.results.pygrb_postprocessing_utils import load_triggers
from pycbc.results.pygrb_postprocessing_utils import get_antenna_responses
from pycbc.results.pygrb_plotting_utils import axis_max_value
from pycbc.results.pygrb_plotting_utils import pygrb_shared_plot_setups

plt.switch_backend('Agg')

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_plot_coh_ifosnr"


# Function to load necessary SNR data from a trigger/injection file
def load_data(input_file, vetoes, ifos, injections=False, sim_table=False):
    """Build a dictionary containing SNR and sensitivity data extracted
    from a trigger/injection file"""

    # Inizialize the dictionary
    data = {}
    data['snr'] = numpy.array(None)
    # TODO: no need to have all sngl_snrs, sigmas, etc.
    data['ifo_snr'] = dict((ifo, None) for ifo in ifos)

    # Fill the dictionary in with required data
    if input_file:
        if not injections:
            trigs_or_injs = load_triggers(input_file, vetoes)
            data['f_resp_mean'] = {}
            data['sigma_max'] = {}
            data['sigma_mean'] = {}
            data['sigma_min'] = {}
            time = numpy.asarray(trigs_or_injs.get_end())
            ra = trigs_or_injs.get_column('ra')
            dec = trigs_or_injs.get_column('dec')
            sigma = trigs_or_injs.get_sigmasqs()
            sigma_tot = numpy.zeros(len(trigs_or_injs))
            for ifo in ifos:
                antenna = Detector(ifo)
                ifo_f_resp = get_antenna_responses(antenna, ra, dec, time)
                data['f_resp_mean'][ifo] = ifo_f_resp.mean()
                sigma_tot += (sigma[ifo] * ifo_f_resp)
            for ifo in ifos:
                try:
                    sigma_norm = sigma[ifo]/sigma_tot
                    data['sigma_mean'][ifo] = sigma_norm.mean()
                    data['sigma_max'][ifo] = sigma_norm.max()
                    data['sigma_min'][ifo] = sigma_norm.min()
                except ValueError:
                    data['sigma_mean'][ifo] = 0
                    data['sigma_max'][ifo] = 0
                    data['sigma_min'][ifo] = 0
        else:
            trigs_or_injs = load_injections(input_file, vetoes,
                                            sim_table=sim_table)
        data['snr'] = numpy.asarray(trigs_or_injs.get_column('snr'))
        data['ifo_snr'] = dict((ifo, trigs_or_injs.get_sngl_snr(ifo))
                               for ifo in ifos)

    return data


# =============================================================================
# Main script starts here
# =============================================================================

description = 'Produces coherent SNR versus single IFO SNR plots.'
usage = __program__ + ' [--options]'

parser = pygrb_initialize_plot_parser(usage=usage, description=description,
                                      version=__version__)
parser.add_argument("-t", "--trig-file", action="store",
                    default=None, required=True,
                    help="The location of the trigger file")
# TODO: don't loop on the output files in the executables?
parser.add_argument("-O", "--zoomed-output-file", default=None,
                    required=True, help="Output file for a zoomed in " +
                    "version of the plot.")
opts = parser.parse_args()

if opts.verbose:
    level = logging.INFO
else:
    level = logging.WARNING
logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=level)

# Check options
trig_file = os.path.abspath(opts.trig_file)
inj_file = None
if opts.inj_file:
    inj_file = os.path.abspath(opts.inj_file)
outfile = opts.output_file
zoomedoutfile = opts.zoomed_output_file
veto_files = []
if opts.veto_directory:
    veto_string = ','.join([str(i) for i in range(2, opts.veto_category+1)])
    veto_files = glob.glob(opts.veto_directory +'/*CAT[%s]*.xml' %(veto_string))
ifo = opts.ifo
if ifo is None:
    msg = "Please specify an interferometer"
    logging.error(msg)
    sys.exit()

if opts.plot_title is None:
    opts.plot_title = '%s SNR vs Coherent SNR' % ifo
if opts.plot_caption is None:
    opts.plot_caption = ("Blue crosses: background triggers.  ")
    if inj_file:
        opts.plot_caption += ("Red crosses: injection triggers.  ")
    opts.plot_caption = opts.plot_caption +\
                         "Black line: veto line.  " +\
                         "Gray shaded region: vetoed area - The cut is " +\
                         "applied only to the two most sensitive detectors, " +\
                         "which can vary with mass and sky location.  " +\
                         "Green lines: the expected SNR for optimally " +\
                         "oriented injections (mean, min, and max).  " +\
                         "Magenta lines: 2 sigma errors.  " +\
                         "Cyan lines: 3 sigma errors."

logging.info("Imported and ready to go.")

# Set output directories
outdirs = [os.path.split(os.path.abspath(outfile))[0], \
           os.path.split(os.path.abspath(zoomedoutfile))[0]]
for outdir in outdirs:
    if not os.path.isdir(outdir):
        os.makedirs(outdir)

# Extract IFOs and vetoes
ifos, vetoes = extract_ifos_and_vetoes(trig_file, opts.veto_directory, \
                                       opts.veto_category)

# Extract trigger data
trig_data = load_data(trig_file, vetoes, ifos)

# Extract (or initialize) injection data
inj_data = load_data(inj_file, vetoes, ifos, injections=True, sim_table=False)

# Generate plots
logging.info("Plotting...")

# Order the IFOs by sensitivity
ifo_senstvty = {}
for i_ifo in ifos:
    senstvty = trig_data['f_resp_mean'][i_ifo]*trig_data['sigma_mean'][i_ifo]
    ifo_senstvty.update({i_ifo: senstvty})
ifo_senstvty = collections.OrderedDict(sorted(ifo_senstvty.items(),
                                              key=operator.itemgetter(1),
                                              reverse=True))
loudness_labels = ['Loudest', 'Second loudest', 'Third loudest']

# Determine the maximum coherent SNR value we are dealing with
x_max = axis_max_value(trig_data['snr'], inj_data['snr'], inj_file)
max_snr = None
if x_max < 50.:
    max_snr = 50.
else:
    max_snr = x_max

# Determine the maximum auto veto value we are dealing with
y_max = axis_max_value(trig_data['ifo_snr'][ifo], inj_data['ifo_snr'][ifo], inj_file)

zoom_snr = numpy.arange(0.01, max_snr, 0.01)

# Setup the plots
pygrb_shared_plot_setups()
fig_path_list = [outfile, zoomedoutfile]
x_label = "Coherent SNR"
y_label = "%s sngl SNR" % ifo
fig_path = fig_path_list[0]
fig_name = os.path.split(os.path.abspath(fig_path))[1]
logging.info(" * %s (%s vs %s)...", fig_name, x_label, y_label)
fig = plt.figure()
ax = fig.gca()
# Plot trigger data
ax.plot(trig_data['snr'], trig_data['ifo_snr'][ifo], 'bx')
ax.grid()
# Plot injection data
if inj_file:
    ax.plot(inj_data['snr'], inj_data['ifo_snr'][ifo], 'r+')
# Sigma-mean, min, max
y_data = [trig_data['sigma_mean'][ifo], trig_data['sigma_min'][ifo],
          trig_data['sigma_max'][ifo]]
# Calculate: zoom-snr * sqrt(response * sigma-mean, min, max)
y_data = [zoom_snr*(trig_data['f_resp_mean'][ifo]*x)**0.5 for x in y_data]
for el in y_data:
    ax.plot(zoom_snr, el, 'g-')
# ncx2: non-central chi-squared; ppf: percent point function
# Plot these for sigma_min and sigma_max
# 2 sigma (0.9545)
ax.plot(zoom_snr, scipy.stats.ncx2.ppf(0.02275, 2, y_data[1]*y_data[1])**0.5, 'm-')
ax.plot(zoom_snr, scipy.stats.ncx2.ppf(1.-0.02275, 2, y_data[2]*y_data[2])**0.5, 'm-')
# 3 sigma (0.9973)
ax.plot(zoom_snr, scipy.stats.ncx2.ppf(0.00135, 2, y_data[1]*y_data[1])**0.5, 'c-')
ax.plot(zoom_snr, scipy.stats.ncx2.ppf(1.-0.00135, 2, y_data[2]*y_data[2])**0.5, 'c-')
# Non-zoomed plot
ax.plot([0, max_snr], [4, 4], 'k-')
ax.set_xlabel(x_label)
ax.set_ylabel(y_label)
ax.set_xlim([0, 1.1*x_max])
ax.set_ylim([0, 1.1*y_max])
# Veto applies to the two most sensitive IFOs, so shade them
loudness_index = ifo_senstvty.keys().index(ifo)
if loudness_index < 2:
    limy = ax.get_ylim()[0]
    polyx = [0, max_snr]
    polyy = [4, 4]
    polyx.extend([max_snr, 0])
    polyy.extend([limy, limy])
    ax.fill(polyx, polyy, color='#dddddd')
opts.plot_title = opts.plot_title + " (%s SNR)" % loudness_labels[loudness_index]
# Save non-zoomed plot
save_fig_with_metadata(fig, fig_path, cmd=' '.join(sys.argv),
                       title=opts.plot_title, caption=opts.plot_caption)
# Save zoomed plot
fig_path = fig_path_list[1]
fig_name = os.path.split(os.path.abspath(fig_path))[1]
logging.info(" * %s (%s vs %s)...", fig_name, x_label, y_label)
ax.set_xlim([6, 50])
ax.set_ylim([0, 20])
save_fig_with_metadata(fig, fig_path, cmd=' '.join(sys.argv),
                       title=opts.plot_title, caption=opts.plot_caption)
plt.close()
