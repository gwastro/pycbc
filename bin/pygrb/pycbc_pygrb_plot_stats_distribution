#!/usr/bin/env python

# Copyright (C) 2011 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import os
import logging
import matplotlib.pyplot as plt
from matplotlib import rc
import numpy as np
import pycbc.version
from pycbc.results.pygrb_postprocessing_utils import extract_ifos_and_vetoes
from pycbc.results.pygrb_postprocessing_utils import load_xml_table
from pycbc.results.pygrb_postprocessing_utils import load_segment_dict
from pycbc.results.pygrb_postprocessing_utils import load_time_slides
from pycbc.results.pygrb_postprocessing_utils import pygrb_plot_opts_parser
from pycbc.results.pygrb_postprocessing_utils import construct_trials
from pycbc.results.pygrb_postprocessing_utils import sort_trigs
from pycbc.results.pygrb_postprocessing_utils import sort_stat
from pycbc.results.pygrb_postprocessing_utils import max_median_stat
from glue.ligolw import lsctables

# Deprecated
from pylal import plotutils
from pylal.coh_PTF_pyutils import readSegFiles, get_bestnr

plt.switch_backend('Agg')
rc("image", cmap="cividis_r")

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_plot_stats_distribution"

# =============================================================================
# Main script starts here
# =============================================================================
description = 'Efficiency calculator for the triggered search (PyGRB).'
usage = __program__ + ' [--options]'
opts = pygrb_plot_opts_parser(usage=usage, description=description, version=__version__)

if opts.verbose:
    level = logging.INFO
else:
    level = logging.WARNING
logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=level)

# Check options
if opts.offsource_file is None:
    err_msg = "Please specify a path to the offsource trigger file."
    logging.error(err_msg)

if opts.veto_directory and (opts.veto_category is None):
    err_msg = "Must supply veto category if applying vetoes."
    logging.error(err_msg)

if not opts.newsnr_threshold:
    opts.newsnr_threshold = opts.snr_threshold

# Store options used multiple times in local variables
outdir = opts.output_path
trig_file = opts.offsource_file
chisq_nhigh = opts.chisq_nhigh
null_thresh = map(float, opts.null_snr_threshold.split(','))
glitch_check_fac = opts.glitch_check_factor

# Initialize random number generator
np.random.seed(opts.seed)
logging.info("Setting random seed to %d.", opts.seed)

# Set output directory
logging.info("Setting output directory.")
if not os.path.isdir(outdir):
    os.makedirs(outdir)

# Extract IFOs and vetoes
logging.info("Extracting IFOs and vetoes.")
ifos, vetoes = extract_ifos_and_vetoes(trig_file, opts.veto_directory, \
                                       opts.veto_category)

# Load triggers, time-slides, and segment dictionary
logging.info("Loading triggers.")
trigs = load_xml_table(trig_file, lsctables.MultiInspiralTable.tableName)
logging.info("%d triggers loaded.", len(trigs))
logging.info("Loading timeslides.")
slide_dict = load_time_slides(trig_file)
logging.info("Loading segments.")
segment_dict = load_segment_dict(trig_file)

# Identify the number of slides
num_slides = len(slide_dict)

# Get segments
segs = readSegFiles(opts.segment_dir)

# Construct trials
logging.info("Constructing trials.")
trial_dict = construct_trials(num_slides, segs, segment_dict, ifos, slide_dict, vetoes)

# Sort the triggers into each slide
sorted_trigs = sort_trigs(trial_dict, trigs, num_slides, segment_dict)

total_trials = sum([len(trial_dict[slide_id]) for slide_id in range(num_slides)])

msg = "Segments loaded, triggers sorted, and %d trials generated." % (total_trials)
logging.info(msg)

# Extract basic trigger properties and store as dictionaries
# TODO: the for's can be made more Pythonic probably.
trig_time = {}
trig_snr = {}
trig_bestnr = {}
for slide_id in range(num_slides):
    slide_trigs = sorted_trigs[slide_id]
    trig_time[slide_id] = np.asarray(slide_trigs.get_end()).astype(float)
    trig_snr[slide_id] = np.asarray(slide_trigs.get_column('snr'))
    trig_bestnr[slide_id] = [get_bestnr(t, q=opts.chisq_index,\
                                        n=opts.chisq_nhigh,\
                                        null_thresh=null_thresh,\
                                        snr_threshold=opts.snr_threshold,\
                                        sngl_snr_threshold=opts.sngl_snr_threshold,\
                                        chisq_threshold=opts.newsnr_threshold,\
                                        null_grad_thresh=opts.null_grad_thresh,\
                                        null_grad_val=opts.null_grad_val) \
                             for t in slide_trigs]
    trig_bestnr[slide_id] = np.array(trig_bestnr[slide_id])
logging.info("Time, SNR, and BestNR of triggers extracted.")

# Calculate SNR and BestNR values and maxima
time_veto_max_snr = {}
time_veto_max_bestnr = {}
time_veto_max_snr_uncut = {}

for slide_id in range(num_slides):
    num_slide_segs = len(trial_dict[slide_id])
    time_veto_max_snr[slide_id] = np.zeros(num_slide_segs)
    time_veto_max_bestnr[slide_id] = np.zeros(num_slide_segs)
    time_veto_max_snr_uncut[slide_id] = np.zeros(num_slide_segs)

for slide_id in range(num_slides):
    for j, trial in enumerate(trial_dict[slide_id]):
        trial_cut = (trial[0] <= trig_time[slide_id])\
                          & (trig_time[slide_id] < trial[1])
        if not trial_cut.any():
            continue
        # Max SNR
        time_veto_max_snr[slide_id][j] = \
                        max(trig_snr[slide_id][trial_cut])
        # Max BestNR
        time_veto_max_bestnr[slide_id][j] = \
                        max(trig_bestnr[slide_id][trial_cut])
        # Max SNR for triggers passing SBVs
        sbv_cut = trig_bestnr[slide_id] != 0
        if not (trial_cut&sbv_cut).any():
            continue
        time_veto_max_snr_uncut[slide_id][j] =\
                          max(trig_snr[slide_id][trial_cut & sbv_cut])

# This is the data that will be plotted
full_time_veto_max_snr = sort_stat(time_veto_max_snr)
full_time_veto_max_snr_uncut = sort_stat(time_veto_max_snr_uncut)
max_bestnr, _, full_time_veto_max_bestnr =\
    max_median_stat(num_slides, time_veto_max_bestnr, trig_bestnr, total_trials)
# The 0.'s here force the histograms to start at (0, 1) if not trial
# returned a no-event (i.e., BestNR = 0)
if full_time_veto_max_bestnr[0] != 0.:
    full_time_veto_max_snr.insert(0, 0.)
    full_time_veto_max_snr_uncut.insert(0, 0.)
    full_time_veto_max_bestnr.insert(0, 0.)

logging.info("SNR and bestNR maxima calculated.")


# ==========
# Make plots
# ==========

# TODO: promote to executable with stat as option. This option should also
# determine the time_veto_max_* to calculate.
# Plot cumulative histograms
x_label_dict = {"bestnr": "BestNR",
                "snr": "SNR",
                "snruncut": "SNR after signal based vetoes"}
data_dict = {"bestnr": full_time_veto_max_bestnr,
             "snr": full_time_veto_max_snr,
             "snruncut": full_time_veto_max_snr_uncut}
for stat in ["bestnr", "snr", "snruncut"]:
    fig = plt.figure()
    ax = fig.gca()
    cumplot = plotutils.CumulativeHistogramPlot(x_label_dict[stat],
                                                "False alarm probability",
                                                "")
    cumplot.add_background([item] for item in data_dict[stat])
    # TODO: are we using this option with multiple scopes?
    cumplot.finalize(num_bins=opts.num_bins)
    cumplot.ax.set_ylim(ymax=1.2)
    cumplot.savefig('%s/%s_vs_fap.png' % (outdir, stat))
    plt.close()

logging.info("Plots complete.")

# USE THIS TO CHECK NOTHING IS BREAKING
# REMOVE ONCE DONE CODING UP THIS SCRIPT
for stat in ["bestnr", "snr", "snruncut"]:
    np.savetxt('%s/%s_vals.txt' % (outdir, stat), data_dict[stat])
