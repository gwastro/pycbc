#!/usr/bin/env python
""" Plot found and missed injections.
"""
import h5py, numpy, logging, os.path, argparse, sys
import matplotlib; matplotlib.use('Agg')
import matplotlib.pyplot as plot
import pycbc.results.followup, pycbc.pnutils, pycbc.results, pycbc.version
import pycbc.pnutils
from pycbc import init_logging
from pycbc.detector import Detector

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--injection-file',
                    help="The hdf injection file to plot", required=True)
# The code includes more x variable options but these are the ones that have
# been tested to work
admitted_xvars = ['mchirp', 'end_time']
parser.add_argument("-x", "--x-variable", default=None, required=True,
                    choices=admitted_xvars,
                    help="Quantity to plot on the horizontal axis. "+
                    "(Underscores may be omitted in specifying this option).")
parser.add_argument("--x-log", action="store_true",
                    help="Use log horizontal axis")
# The code includes more y variable options but these are the ones that have
# been tested to work.
admitted_yvars = ['distance', 'eff_dist', 'eff_site_dist', 'decisive_optimal_snr']
parser.add_argument("-y", "--y-variable", default=None, required=True,
                    choices=admitted_yvars,
                    help="Quantity to plot on the vertical axis. "+
                    "(Underscores may be omitted in specifying this option).")
parser.add_argument("--y-log", action="store_true",
                    help="Use log vertical axis")
parser.add_argument('--ifo',default=None,
                   help="Interferometer (used for effective site distance)")
parser.add_argument('--colormap',default='cividis_r',
                   help="Type of colormap to be used for the plots.")
parser.add_argument('--verbose', action='count')
parser.add_argument('--gradient-far', action='store_true',
                    help="Show far of found injections as a gradient")
parser.add_argument('--output-file', required=True)
parser.add_argument('--far-type', choices=('inclusive', 'exclusive'),
                    default='inclusive',
                    help="Type of far to plot for the color. Choices are "
                         "'inclusive' or 'exclusive'. Default = 'inclusive'")
parser.add_argument('--missed-on-top', action='store_true',
                    help="Plot missed injections on top of found ones and "
                         "high FAR on top of low FAR")
parser.add_argument('--version', action='version',
                    version=pycbc.version.git_verbose_msg)
args = parser.parse_args()

init_logging(args.verbose)

# Read in HDF5 file
logging.info('Reading in the data')
f = h5py.File(args.injection_file, 'r')

# Load basic injection data
time = f['injections/tc'][:]
found = f['found_after_vetoes/injection_index'][:]
missed = f['missed/after_vetoes'][:]

# Load inclusive and exclusive IFARs
if args.far_type == 'inclusive':
    ifar_found = f['found_after_vetoes/ifar'][:]
    far_title = 'Inclusive'
elif args.far_type == 'exclusive':
    ifar_found = f['found_after_vetoes/ifar_exc'][:]
    far_title = 'Exclusive'

# Initialize dictionary for x variable data
xvals = {}

# Get values necessary for calculations
m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
dist = f['injections/distance'][:]
s1z = f['injections/spin1z'][:]
s2z = f['injections/spin2z'][:]

# Compute x values that need calculations
xvals['mchirp'], eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)
xvals['eff_spin'] = (m1 * s1z + m2 * s2z) / (m1 + m2)
xvals['mtotal'] = m1 + m2
# use convention that q>1
xvals['mass_ratio'] = numpy.maximum(m1/m2, m2/m1)
# If x variable doesn't need calculations, it can be loaded directly 
# from HDF file
if args.x_variable not in ['mchirp', 'eff_spin', 'mtotal', 'mass_ratio']:
    xvals[args.x_variable] = f['injections/%s' % args.x_variable][:]


# Initialize dictionary for y variable
yvals = {}

# Load ifos that are available in the HDF file
if 'ifos' in f.attrs:
    ifos = f.attrs['ifos'].split(' ')
else:
    logging.warning("Ifos not found in input file, assuming H-L")
    ifos = ['H1', 'L1']

# NOTE: Effective distance is hardcoded to these values. It's also normally
#       meaningless for precessing injections.
try:
    eff_dists = []
    for ifo in ['H1', 'L1', 'V1']:
        eff_dists.append(Detector(ifo).effective_distance(
                             f['injections/distance'][:],
                             f['injections/ra'][:],
                             f['injections/dec'][:],
                             f['injections/polarization'][:],
                             f['injections/tc'][:],
                             f['injections/inclination'][:]))
    eff_dists = numpy.array(eff_dists).T

    # "Decisive" distance is the second smallest effective distance
    yvals['decisive_distance'] = numpy.sort(eff_dists)[:,1]
    yvals['dec_chirp_distance'] = \
        pycbc.pnutils.chirp_distance(yvals['decisive_distance'],
                                     xvals['mchirp'])
except KeyError:
    # If the ifo isn't in the effective distance columns you can't get this.
    # But you can still use other values.
    pass

# We already loaded the distance
yvals['distance'] = dist

# Compute y values that need calculations
yvals['chirp_distance'] = pycbc.pnutils.chirp_distance(dist, xvals['mchirp'])
# Redshift can be loaded directly
if args.y_variable == 'redshift':
    yvals['redshift'] = f['injections/redshift'][:]
if 'snr' in args.y_variable:  # only evaluate SNRs if needed
    if 'optimal_snr_1' in f['injections']:  # old 2-ifo search behaviour
        opt_snr_1 = f['injections/optimal_snr_1'][:]
        opt_snr_2 = f['injections/optimal_snr_2'][:]
        yvals['comb_optimal_snr'] = \
            numpy.sqrt(opt_snr_1 ** 2. + opt_snr_2 ** 2.)
        yvals['decisive_optimal_snr'] = \
            numpy.where(opt_snr_1 < opt_snr_2, opt_snr_1, opt_snr_2)
    else: # New workflow code syntax
        opt_snrsq_arr = \
            [f['injections/optimal_snr_%s' % ifo][:]**2. for ifo in ifos]
        yvals['comb_optimal_snr'] = \
            numpy.array([numpy.sqrt(sum(opt_snrsq))
                         for opt_snrsq in zip(*opt_snrsq_arr)])
        # Decisive optimal SNR is the 2nd largest optimal SNR
        yvals['decisive_optimal_snr'] = \
            numpy.array([numpy.sqrt(sorted(opt_snrsq)[-2])
                         for opt_snrsq in zip(*opt_snrsq_arr)])

# Load effective distances - copied from pycbc_pygrb_plot_injs_results
if args.y_variable == 'eff_site_dist': # For single detector site distances
    yvals['eff_site_dist'] = f['injections/eff_dist_%s' % args.ifo[0].lower()][:]
elif args.y_variable == 'eff_dist':
    local_dict = {}
    local_dict['eff_site_dist'] =\
        dict((ifo, f['injections/eff_dist_%s' % ifo[0].lower()][:])
             for ifo in ifos)
    yvals['eff_dist'] = numpy.power(numpy.power(numpy.asarray(
        list(local_dict['eff_site_dist'].values())), -1).sum(0), -1)

# Specify indices for found and missed injections
fyvals = yvals[args.y_variable][found]
myvals = yvals[args.y_variable][missed]

logging.info('Data loaded.')
labels={'mchirp': 'Chirp Mass',
        'mtotal': 'Total Mass',
        'mass1': 'Mass 1',
        'mass2': 'Mass 2',
        'mass_ratio': 'Mass Ratio',
        'distance': 'Distance (Mpc)',
        'decisive_distance': 'Injected Decisive Distance (Mpc)',
        'dec_chirp_distance': 'Injected Decisive Chirp Distance (Mpc)',
        'chirp_distance': 'Injected Chirp Distance (Mpc)',
        'comb_optimal_snr': 'Combined Optimal SNR',
        'decisive_optimal_snr': 'Decisive Optimal SNR',
        'redshift': 'Redshift',
        'end_time': 'Time (s)',
        'eff_spin': 'Weighted Aligned Spin',
        'coa_phase': 'Complex SNR Phase',
        'eff_dist': 'Inverse sum of effective distances (Mpc)',
        'eff_site_dist': '%s effective distance (Mpc)' % args.ifo,
       }

logging.info('Plotting...')
if args.missed_on_top:
  fig_title = 'Missed and Found Injections'
else:
  fig_title = 'Found and Missed Injections'

fig = plot.figure()
zmissed = args.missed_on_top
zfound = not args.missed_on_top

mpoints = plot.scatter(xvals[args.x_variable][missed], myvals, s=16,
                       linewidth=0.5, marker='x', color='red',
                       label='missed', zorder=zmissed)

fvals = xvals[args.x_variable][found]

ifsort = numpy.argsort(ifar_found)
if args.missed_on_top:
    ifsort = ifsort[::-1]

fvals = fvals[ifsort]
fyval = fyvals[ifsort]
ifsorted = ifar_found[ifsort]

if not args.gradient_far:
    color = numpy.ones(len(found))
    ten = numpy.where(ifsorted > 10)[0]
    hundred = numpy.where(ifsorted > 100)[0]
    thousand = numpy.where(ifsorted > 1000)[0]
    color[hundred] = 0.5
    color[thousand] = 0

    norm = matplotlib.colors.Normalize()
    caption = (fig_title + ": Red x's are missed injections. "
              "Blue circles are found with IFAR < 100 years, gray are < "
              "1000 years, and yellow are found with IFAR >=1000 years. ")
else:
    color = 1.0 / ifsorted
    if len(color) < 2:
        color=None

    norm = matplotlib.colors.LogNorm()
    caption = (fig_title + ": Red x's are missed injections. "
               "Circles are found injections. The color indicates the value "
               "of the false alarm rate." )

points = plot.scatter(fvals, fyval, c=color, linewidth=0, s=16, norm=norm,
                      marker='o', label='found', zorder=zfound,
                      cmap=args.colormap)
if args.gradient_far:
    try:
        c = plot.colorbar()
        c.set_label('False Alarm Rate $(yr^{-1})$, %s' % far_title)

        # Set up tick labels - there will always be 5
        min_tick = numpy.ceil(min(numpy.log10(color)))
        max_tick = numpy.floor(max(numpy.log10(color)))
        tick_step = numpy.floor((max_tick - min_tick) / 5)
        ticks = numpy.arange(min_tick, max_tick, tick_step)
        c.set_ticks(numpy.power(10, ticks))
    except (TypeError, ZeroDivisionError):
        # Can't make colorbar if no quiet found injections
        if len(fvals):
            raise

if args.missed_on_top:
  caption += "Missed injections are shown on top of found injections."
else:
  caption += "Found injections are shown on top of missed injections."

ax = plot.gca()
plot.xlabel(labels[args.x_variable])
plot.ylabel(labels[args.y_variable])
plot.grid()

if args.x_log:
    # log x axis may fail for some choices, eg effective spin
    ax.set_xscale('log')
    tmpxvals = list(xvals[args.x_variable][missed])
    tmpxvals += list(xvals[args.x_variable][found])
    xmax = 1.4 * max(tmpxvals)
    xmin = 0.7 * min(tmpxvals)
    plot.xlim(xmin, xmax)
if args.y_log:
    ax.set_yscale('log')

tmpyvals = list(fyvals) + list(myvals)
ymax = 1.2 * max(tmpyvals)
ymin = 0.9 * min(tmpyvals)

# note: ymin=0 will clash with args.y_log
# in that case it *should* throw an error!
plot.ylim(ymin, ymax)

if args.y_variable == 'redshift':
    # default y limit: min redshift 0
    plot.ylim(ymin=0, ymax=ymax)
else:
    # arbitrary limit of 1 distance-unit or snr-unit
    plot.ylim(ymin=1, ymax=ymax)

fig_kwds = {}
if '.png' in args.output_file:
    fig_kwds['dpi'] = 200

if ('.html' in args.output_file):
    plot.subplots_adjust(left=0.1, right=0.8, top=0.9, bottom=0.1)
    import mpld3, mpld3.plugins, mpld3.utils
    mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
    legend =  mpld3.plugins.InteractiveLegendPlugin([mpoints, points],
                                                    ['missed', 'found'],
                                                    alpha_unsel=0.1)
    mpld3.plugins.connect(fig, legend)

title = '%s: %s vs %s' % (fig_title, args.x_variable, args.y_variable)
cmd = ' '.join(sys.argv)
pycbc.results.save_fig_with_metadata(fig, args.output_file, fig_kwds=fig_kwds,
                                     title=title, cmd=cmd, caption=caption)
