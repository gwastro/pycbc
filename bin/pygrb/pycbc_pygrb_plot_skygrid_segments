#!/usr/bin/env python
#
# Copyright (C) 2021 Gino Contestabile, Francesco Pannarale, Michael Patel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# =============================================================================
# Preamble
# =============================================================================

"""
Plot search grid of a PyGRB run.
"""

from __future__ import division

import sys
import glob
import os
import logging
import numpy
import pycbc.version
import matplotlib.colors as colors
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.lines import Line2D 
from glue.ligolw import lsctables
from ligo.segments import segmentlistdict
from pycbc.detector import Detector
from pycbc.results import save_fig_with_metadata
from pycbc.results.color import ifo_color
from pycbc.results.pygrb_postprocessing_utils import extract_ifos_and_vetoes
from pycbc.results.pygrb_postprocessing_utils import load_segments_from_xml
from pycbc.results.pygrb_postprocessing_utils import load_triggers
from pycbc.results.pygrb_postprocessing_utils import PygrbFilterOutput
from pycbc.results.pygrb_postprocessing_utils import pygrb_shared_plot_setups
from pycbc.results.pygrb_postprocessing_utils import pygrb_plot_opts_parser
from pycbc.results.pygrb_postprocessing_utils import get_grb_time
from pycbc.results.pygrb_postprocessing_utils import get_antenna_dist_factor
plt.switch_backend('Agg')

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_plot_skygrid_segments"


# =============================================================================
# Main script starts here
# =============================================================================

@numpy.vectorize
def antenna_factor_wrapper(antenna, ra, dec, time):
    return get_antenna_dist_factor(antenna, ra, dec, time)

    
description = 'pycbc_pygrb_plot_skygrid will produce the sky grid plot.'
usage = __program__ + ' [--options]'
opts = pygrb_plot_opts_parser(usage=usage, description=description, version=__version__)

if opts.verbose:
    level = logging.INFO
else:
    level = logging.WARNING
logging.basicConfig(format="%(asctime)s:%(levelname)s : %(message)s",
                    level=level)

pygrb_shared_plot_setups()

logging.info("Imported and ready to go.")

# =============================================================================
# Load Data from the Command Line Options
# =============================================================================
trig_file = os.path.abspath(opts.trig_file)
seg_dir = opts.segment_dir

# Extract IFOs and vetoes
ifos, vetoes = extract_ifos_and_vetoes(trig_file, opts.veto_directory, \
                                       opts.veto_category)
# Load triggers
trigs = load_triggers(trig_file, vetoes)

# Extract trigger data
trig_data = PygrbFilterOutput(trigs, ifos,
                              lsctables.MultiInspiralTable.loadcolumns,
                              "triggers", opts)

# Get GRB time
GRB_time = get_grb_time(opts.segment_dir)

# Get trigger time with releation to GRB time
trig_times = [t-GRB_time for t in trig_data.time]

# This code produces different plots depending on whether a single ifo is 
# specified in the command line.
ifo = opts.ifo

# =============================================================================
# Sky Grid Plot
# =============================================================================
lats, indices = numpy.unique(trig_data.latitude, return_index=True)
# Remove the sidereal drift from the longitudes and plot points as at GRB time.
lons = trig_data.longitude - (numpy.array(trig_times) * 360.0 / 86164.0905)
lons = lons[indices]

# Handle grids that cross the meridian.
grid_wrap = False
if any(lons < 90) and any(lons > 270):
    grid_wrap = True
    if lons.mean() < 180:
        lons = numpy.where(lons > 180, lons - 360, lons)
    else:
        lons = numpy.where(lons < 180, lons + 360, lons)

fig = plt.figure()
ax = fig.gca()
ax.set_xlabel("Longitude (Degrees)")
ax.set_ylabel("Latitude (Degrees)")
ax.plot(360 - lons, lats, 'o', markerfacecolor='None', markeredgecolor='black', markeredgewidth=1)
if grid_wrap:
    labels = ax.get_xticks().tolist()
    new_labels = [l - 360 if l > 360 else l + 360 if l <= 0 else l
                  for l in labels]
else:
    new_labels = ax.get_xticks().tolist()
new_labels = [360 - l for l in new_labels]
ax.set_xticklabels(new_labels)

min_lon, max_lon = (min(ax.get_xticks().tolist()), max(ax.get_xticks().tolist()))
min_lat, max_lat = (min(ax.get_yticks().tolist()), max(ax.get_yticks().tolist()))

if ifo != None:
    min_lon, max_lon = (min(ax.get_xticks().tolist()), max(ax.get_xticks().tolist()))
    min_lat, max_lat = (min(ax.get_yticks().tolist()), max(ax.get_yticks().tolist()))    
    
    lat_mesh, lon_mesh = numpy.meshgrid(numpy.linspace(min_lat, max_lat, 50), numpy.linspace(min_lon, max_lon, 50))

    if grid_wrap:
        corrected_lon_mesh = numpy.where(lon_mesh > 0, 360.0 - lon_mesh, -lon_mesh)
    else:
        corrected_lon_mesh = lon_mesh

    logging.info('Generating Antenna Mesh')
    ifo_cmap = colors.LinearSegmentedColormap.from_list(ifo, [colors.to_rgb('#FFFFFF'), colors.to_rgb(ifo_color(ifo))])
    antenna = Detector(ifo)
    antenna_mesh = antenna_factor_wrapper(antenna, corrected_lon_mesh / 180 * numpy.pi, lat_mesh / 180 * numpy.pi, GRB_time)
    c = ax.contourf(lon_mesh, lat_mesh, antenna_mesh, 50, cmap=ifo_cmap)
    fig.colorbar(c, ticks=numpy.around(numpy.linspace(numpy.min(antenna_mesh), numpy.max(antenna_mesh), 9), decimals=3))
    plot_title = ifo + ' Antenna Factor'
    plot_caption = 'The black circles are the search points that PyGRB used in '
    plot_caption += 'the analysis. The color gradient shows the ' + ifo + ' ' 
    plot_caption += 'antenna factor over the area. This antenna factor is calulated '
    plot_caption += 'the same way as the antenna factors from the A1 table.'
else:
    plt.grid()
    plot_title = 'PyGRB Sky Grid'
    plot_caption = 'Search points that PyGRB used in the analysis. Please note '
    plot_caption += 'that these points are at GRB trigger time. The analysis, '
    plot_caption += 'however, does account for the relative shift in these positions'
    plot_caption += 'given the siderial shift over the off-source window.'

plt.tight_layout()

# Save the sky grid plot with metadata.
save_fig_with_metadata(fig, opts.skygrid_output_file, cmd=' '.join(sys.argv),
                       title=plot_title, caption=plot_caption)
plt.close() 

# =============================================================================
# Segments Plot
# =============================================================================
# Need to get the off-source window for either segment plot.
with open(opts.veto_directory + '/offSourceSeg.txt', 'r') as off_file:
    data = off_file.readlines()[1].split('\t')
    off_start, off_dur = (float(data[1]), float(data[3]))

# If no ifo is specified on the command line, then we plot the science segents along
# with the offsource window for each IFO with science segments.
if ifo == None:
    science_files = glob.glob(opts.veto_directory +'/*SCIENCE_OK*.xml')
    ifos = [os.path.basename(ifo).split('-')[0] for ifo in science_files]
    segdict = segmentlistdict()
    for ifo, science_file in zip(ifos, science_files):
        segdict[ifo] = load_segments_from_xml(science_file)
    fig, axs = plt.subplots(len(ifos), sharey=True)
    if len(ifos) == 1:
        axs = [axs]
    for ax, ifo in zip(axs, ifos):
        for seg in segdict[ifo]:
            ax.add_patch(Rectangle((seg[0], 0.1), abs(seg), 0.8, facecolor=ifo_color(ifo), edgecolor='None'))
        ax.plot([GRB_time, GRB_time], [0,1], '-', color='orange')
        ax.add_patch(Rectangle((off_start, 0), off_dur, 1, alpha=0.5, facecolor='orange', edgecolor='None'))
        ax.set_frame_on(False)
        ax.set_ylabel(ifo, rotation=0, labelpad=10)
        ax.set_yticks([])
        ax.set_ylim([0,1])
        ax.set_xlim([segdict.extent_all()[0], segdict.extent_all()[1]])
        ax.get_xaxis().get_major_formatter().set_useOffset(False)
        ax.get_xaxis().get_major_formatter().set_scientific(False)
        ax.get_xaxis().tick_bottom()
        if ax is axs[-1]:
            ax.tick_params(labelsize=10, pad=1)
        else:
            ax.get_xaxis().set_ticks([])
            ax.get_xaxis().set_ticklabels([])
    xmin, xmax = fig.axes[-1].get_xaxis().get_view_interval()
    ymin, _ = fig.axes[-1].get_yaxis().get_view_interval()
    fig.axes[-1].add_artist(Line2D((xmin, xmax), (ymin, ymin), color='black', linewidth=2))
    fig.axes[-1].set_xlabel('GPS Time')
    plt.xticks(rotation=20, ha='right')
    plt.tight_layout()
    fig.subplots_adjust(hspace=0)
    plot_title = 'Science Segments'
    plot_caption = 'Science segments for all ifos included in the configuration. '
    plot_caption += 'The off-source window is shown as the orange box, with the '
    plot_caption += 'GRB trigger time as the dark orange line.' 

# If an ifo is specified we plot the science segments for that ifo, as well
# as the veteos and gates.
else:
    fig, axs = plt.subplots(5, sharey=True)
    science_file = glob.glob(opts.veto_directory +'/%s*SCIENCE_OK*.xml' % (ifo))[0]
    science_segs = load_segments_from_xml(science_file)

    for ax, veto_cat in zip(axs, ['0','1','2','3','Gating']):
        # Top plot is the science segments.
        if ax is axs[0]:
            ax.set_ylabel('Science', rotation=0, labelpad=28, )
            for seg in science_segs:
                ax.add_patch(Rectangle((seg[0], 0.1), abs(seg), 0.8, facecolor=ifo_color(ifo), edgecolor='None'))
        # Next three are plots of the three veto catagories.
        elif ax in [axs[1], axs[2], axs[3]]:
            veto_file = glob.glob(opts.veto_directory +'/%s*CAT%s*.xml' % (ifo, veto_cat))[0]
            veto_segs = load_segments_from_xml(veto_file)
            ax.set_ylabel('CAT' + veto_cat, rotation=0, labelpad=22)
            for seg in veto_segs:
                ax.add_patch(Rectangle((seg[0], 0.1), abs(seg), 0.8, facecolor=ifo_color(ifo), edgecolor=ifo_color(ifo)))
        # Last is the gates.
        else:
            gating_file = glob.glob(opts.gates_directory +'/%s*OUTPUT_GATES*.txt' % (ifo))[0]
            gates = numpy.loadtxt(gating_file, delimiter=' ', dtype=float)
            ax.set_ylabel('Gating', rotation=0, labelpad=25)
            for gate in gates:
                gate_dur = gate[1] + gate[2]
                ax.add_patch(Rectangle((gate[0] - gate_dur, 0.1), 2 * gate_dur, 0.8, facecolor=ifo_color(ifo), edgecolor=ifo_color(ifo)))
        ax.plot([GRB_time, GRB_time], [0,1], '-', color='orange')
        ax.add_patch(Rectangle((off_start, 0), off_dur, 1, alpha=0.5, facecolor='orange', edgecolor='None'))
        ax.set_frame_on(False)
        ax.set_yticks([])
        ax.set_ylim([0,1])
        ax.set_xlim([science_segs.extent()[0], science_segs.extent()[1]])
        ax.get_xaxis().get_major_formatter().set_useOffset(False)
        ax.get_xaxis().get_major_formatter().set_scientific(False)
        ax.get_xaxis().tick_bottom()
        if ax is axs[-1]:
            ax.tick_params(labelsize=10, pad=1)
        else:
            ax.get_xaxis().set_ticks([])
            ax.get_xaxis().set_ticklabels([])

    xmin, xmax = fig.axes[-1].get_xaxis().get_view_interval()
    ymin, _ = fig.axes[-1].get_yaxis().get_view_interval()
    fig.axes[-1].add_artist(Line2D((xmin, xmax), (ymin, ymin), color='black', linewidth=2))
    fig.axes[-1].set_xlabel('GPS Time')
    plt.xticks(rotation=20, ha='right')
    plt.tight_layout()
    fig.subplots_adjust(hspace=0)
    plot_title = ifo + ' Segments'
    plot_caption = 'Segments for ' + ifo + ' . The off-source window is shown '
    plot_caption += 'as the orange box, with the GRB trigger time as the dark '
    plot_caption += 'orange line. If there are veto segments or periods of gating '
    plot_caption += '(either from the Gates file or from auto-gating) they are '
    plot_caption += 'shown in thier respecitve row.'

# Save the segments plot with the metadata.
save_fig_with_metadata(fig, opts.segments_output_file, cmd=' '.join(sys.argv),
                       title=plot_title, caption=plot_caption)
plt.close()
