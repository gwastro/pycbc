#!/usr/bin/env python

"""For a given external trigger (GRB, FRB, neutrino, etc...), generate a sky
grid covering its localization error region.

This sky grid will be used by `pycbc_multi_inspiral` to find multi-detector
gravitational wave triggers and calculate the coherent SNRs and related
statistics. 

The grid is constructed following the method described in Section V of
https://arxiv.org/abs/1410.6042.

Please refer to help(pycbc.types.angle_as_radians) for the recommended
configuration file syntax for angle arguments.
"""

import numpy as np
import argparse
import itertools
from scipy.spatial.transform import Rotation as R

import pycbc
from pycbc.distributions import UniformSky, FisherSky, HealpixSky
from pycbc.detector import Detector
from pycbc.types import angle_as_radians
from pycbc.tmpltbank.sky_grid import SkyGrid


def spher_to_cart(sky_points):
    """Convert spherical coordinates to cartesian coordinates."""
    cart = np.zeros((len(sky_points), 3))
    cart[:, 0] = np.cos(sky_points[:, 0]) * np.cos(sky_points[:, 1])
    cart[:, 1] = np.sin(sky_points[:, 0]) * np.cos(sky_points[:, 1])
    cart[:, 2] = np.sin(sky_points[:, 1])
    return cart


def cart_to_spher(sky_points):
    """Convert cartesian coordinates to spherical coordinates."""
    spher = np.zeros((len(sky_points), 2))
    spher[:, 0] = np.arctan2(sky_points[:, 1], sky_points[:, 0])
    spher[:, 1] = np.arcsin(sky_points[:, 2])
    spher[spher[:, 0] <0, 0] += 2 * np.pi
    return spher

def angular_distance(test_point, grid):
    grid_cart = spher_to_cart(grid)
    test_cart = spher_to_cart(np.array([test_point]))
    dot = np.tensordot(grid_cart, test_cart, ((1,),(1,))).ravel()
    dists = np.arccos(dot)
    return min(dists)

def make_single_det_grid(args):
    """Construct a sky grid for a single-detector analysis.
    Since a one-detector network has no sky localization capability,
    we just put a single point at the center of the input distribution.
    """
    sky_grid = SkyGrid(
        [args.ra], [args.dec], args.instruments, args.trigger_time
    )
    return sky_grid

def make_multi_det_grid(args):
    '''
    Compute a skygrid object using the time delay among detectors 
    in the network.
    '''
    args.instruments.sort()  # Put the ifos in alphabetical order
    detectors = args.instruments
    detectors = [Detector(d) for d in detectors]
    detector_pairs = list(itertools.combinations(detectors, 2))

    input_dist = eval(args.input_dist)
    sky_dist = eval(args.input_dist)
    sky_dist = sky_dist.to_uniform_patch(args.coverage) 
    grid = np.empty((0,2))

    while True:
        prev_size = grid.shape[0]
        sky_dist_samples = sky_dist.rvs(size=10000)
        sky_ra = sky_dist_samples['ra']
        sky_dec = sky_dist_samples['dec']
        for prop_ra, prop_dec in zip(sky_ra, sky_dec):
            # Calculate the time delay for each detector pair
            tds = [
                detector_pairs[i][0].time_delay_from_detector(
                    detector_pairs[i][1], prop_ra, prop_dec, trigger_time
                )
                for i in range(len(detector_pairs))
            ]
            

            # Calculate the light travel time between the detector pairs
            light_travel_times = [
                detector_pairs[i][0].light_travel_time_to_detector(detector_pairs[i][1])
                for i in range(len(detector_pairs))
            ]

            # Calculate the required angular spacing between the sky points
            ang_spacings = [
                (2 * timing_uncertainty)
                / np.sqrt(light_travel_times[i] ** 2 - tds[i] ** 2)
                for i in range(len(detector_pairs))
            ]
            angular_spacing = np.min(ang_spacings)

            if grid.shape[0] == 0:
                # first point, accept
                # FIXME handling the first point can surely be moved before the loop!
                grid = np.vstack((grid, input_dist.get_max_pixel_prob()))
                continue
            # FIXME it is not necessary to calculate *all* distances,
            # we can reject as soon as we find one below threshold!
            dist = angular_distance((prop_ra, prop_dec), grid)
            if dist > angular_spacing:
                # far enough from other points, accept
                grid = np.vstack((grid, (prop_ra, prop_dec)))
        num_new_accepted = grid.shape[0] - prev_size
        logging.info(f'{num_new_accepted} points accepted, {grid.shape[0]} total')
        if num_new_accepted == 0:

            sky_grid = SkyGrid(
                grid[:, 0], grid[:, 1], args.instruments, args.trigger_time
            )
            return sky_grid

parser = argparse.ArgumentParser(description=__doc__)
pycbc.add_common_pycbc_options(parser)
parser.add_argument(
    '--instruments',
    nargs="+",
    type=str,
    required=True,
    help="List of instruments to analyze.",
)
parser.add_argument(
    "--input-dist",
    type=str,
    default='UniformSky()',
    required=True,
    help="Input distribution of the sky map that you have, could "
    "be HealpixSky or FisherSky. See sky location documentation for "
    "more details",
)
parser.add_argument(
    '--coverage',
    type=float,
    required=True,
    help="Percentage of probability that you want to cover",
)
parser.add_argument(
    '--trigger-time',
    type=int,
    required=True,
    help="Time (in s) of the external trigger",
)
parser.add_argument(
    '--timing-uncertainty',
    type=float,
    default=0.0001,
    help="Timing uncertainty (in s) we are willing to accept",
)
parser.add_argument(
    '--output', type=str, required=True, help="Name of the sky grid"
)

args = parser.parse_args()

pycbc.init_logging(args.verbose)

if len(args.instruments) == 1:
    # Make a single point skygrid object
    sky_grid = make_single_det_grid(args)
else:
    # Make a skygrid object using timedelays among all detectors in the
    # network.
    sky_grid = make_multi_det_grid(args)


extra_attributes = {
    'triiger_ra': sky_grid[0][0],
    'trigger_dec': sky_grid[0][1],
    'coverage': args.coverage,
    'timing_uncertainty': args.timing_uncertainty
}

sky_grid.write_to_file(args.output, extra_attributes)
