#!/home/ian.harry/virtualenvs/pycbc_python3/bin/python3

# Copyright (C) 2016 Ian W. Harry, Alex Nitz
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Program for concatenating output files from pycbc_banksim_combine_banks with
a set of injection files. The *order* of the injection files *must* match the
bank files, and the number of injections in each must correspond one-to-one.
"""

from os.path import isfile
import imp
import argparse
import numpy as np
import h5py
from glue.ligolw import utils, table
import pycbc
from pycbc import pnutils
from pycbc.waveform import TemplateBank

__author__  = "Ian Harry <ian.harry@astro.cf.ac.uk>"
__version__ = pycbc.version.git_verbose_msg
__date__    = pycbc.version.date
__program__ = "pycbc_banksim_match_combine"

from glue.ligolw.ligolw import LIGOLWContentHandler
from glue.ligolw import lsctables
class mycontenthandler(LIGOLWContentHandler):
    pass
lsctables.use_in(mycontenthandler)

# Read command line options
_desc = __doc__[1:]
parser = argparse.ArgumentParser(description=_desc)

parser.add_argument("--version", action="version", version=__version__)
parser.add_argument("--verbose", action="store_true", default=False,
                    help="verbose output")
parser.add_argument("--match-files", nargs='+',
                    help="Explicit list of match files.")
#parser.add_argument("--inj-files", nargs='+',
#                    help="Explicit list of injection files. These must be in "
#                         "the same order, and match one-to-one with the "
#                         "match-files.")
parser.add_argument("-o", "--output-file", required=True,
                    help="Output file name")
parser.add_argument("--filter-func-file", default=None,
                    help="This can be provided to give a function to define "
                         "which points are covered by the template bank "
                         "bounds, and which are not. The file should contain "
                         "a function called filter_injections, which should "
                         "take as call profile, mass1, mass2, spin1z, spin2z, "
                         "as numpy arrays.")
options = parser.parse_args()

dtypem = np.dtype([('match_1', float64), ('match_2', float64),
                ('match_3', float64), ('match_4', float64),
                ('match_5', float64), ('match_vary', float64),
                ('match_vary_max2', float64), ('match_vary_max3', float64),
                ('match_vary_max4', float64), ('bank_1', unicode_, 256),
                ('bank_2', unicode_, 256), ('bank_3', unicode_, 256),
                ('bank_4', unicode_, 256), ('bank_5', unicode_, 256),
                ('bank_vary', unicode_, 256),
                ('bank_vary_max2', unicode_, 256),
                ('bank_vary_max3', unicode_, 256), 
                ('bank_vary_max4', unicode_, 256),
                ('bank_i_1', int32), ('bank_i_2', int32),
                ('bank_i_3', int32), ('bank_i_4', int32),
                ('bank_i_5', int32), ('bank_i_vary', int32),
                ('bank_i_vary_max2', int32), ('bank_i_vary_max3', int32),
                ('bank_i_vary_max4', int32), ('sim', unicode_, 256),
                ('sim_i', int32), ('sigmasq', float64)])

# Collect the results
res = None
for fil in options.match_files:
    if res is not None:
        res = np.append(res, np.loadtxt(fil, dtype=dtypem))
    else:
        res = np.loadtxt(fil, dtype=dtypem)

btables = {}
itables = {}     

f = h5py.File(options.output_file, "w")

# If we more these over to HDF we can decide column names dynamically. This is
# why I'm using a dictionary now.

bank_params = {}
    
bank_par_list = ['mass1', 'mass2', 'spin1x', 'spin1y', 'spin1z', 'spin2x',
                 'spin2y', 'spin2z']
for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
    bank_params[i] = {}
    for val in bank_par_list:
        bank_params[i][val] = np.zeros(len(res), dtype=np.float64)

inj_params = {}
inj_par_list = ['mass1', 'mass2', 'spin1x', 'spin1y', 'spin1z', 'spin2x',
                'spin2y', 'spin2z', 'coa_phase', 'inclination', 'latitude',
                'longitude', 'polarization']
for val in inj_par_list:
    inj_params[val] = np.zeros(len(res), dtype=np.float64)

trig_params = {}
trig_par_list = ['match', 'sigmasq']
for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
    trig_params[i] = {}
    for val in trig_par_list:
        trig_params[i][val] = np.zeros(len(res), dtype=np.float64)

for idx, row in enumerate(res): 
    outstr = ""
    for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
        if row['bank_{}'.format(i)] not in btables:
            bank_path = row['bank_{}'.format(i)]
            temp_bank = TemplateBank(bank_path)
            btables[row['bank_{}'.format(i)]] = temp_bank.table

    if row['sim'] not in itables:
        indoc = utils.load_filename(row['sim'], False, contenthandler=mycontenthandler)
        itables[row['sim']] = table.get_table(indoc, "sim_inspiral") 
    
    bts = []
    for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
        bts.append(btables[row['bank_{}'.format(i)]][row['bank_i_{}'.format(i)]])
    it = itables[row['sim']][row['sim_i']]
 
    for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
        for val in trig_par_list:
            if val == 'match':
                trig_params[i][val][idx] = row['match_{}'.format(i)]
            else:
                trig_params[i][val][idx] = row[val]
    for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
        for val in bank_par_list:
            try:
                bank_params[i][val][idx] = getattr(bts[i], val)
            except AttributeError:
                # Below is fine, but mass1 (and some others) must be there
                if val == 'mass1':
                    raise
                # If not present set to 0.
                # For example spin1x is not always stored in aligned-spin banks
                bank_params[i][val][idx] = 0.
    for val in inj_par_list:
        inj_params[val][idx] = getattr(it, val)

for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
    for val in bank_par_list:
        f['bank_params_{}/{}'.format(i, val)] = bank_params[i][val] 
    for val in trig_par_list:
        f['trig_params_{}/{}'.format(i, val)] = trig_params[i][val]

for val in inj_par_list:
    f['inj_params/{}'.format(val)] = inj_params[val]

# Also consider values over the whole set
for i in [1, 2, 3, 4, 5, 'vary', 'vary_max2', 'vary_max3', 'vary_max4']:
    # Signal recovery fraction
    sigma = trig_params[i]['sigmasq']**0.5
    srfn = np.sum((trig_params[i]['match'] * sigma)**3.)
    srfd = np.sum(sigma**3.)

    f['sig_rec_fac_{}'.format(i)] = srfn / srfd
    f['eff_fitting_factor_{}'.format(i)] = (srfn / srfd)**(1./3.)
    mchirp, _ = pnutils.mass1_mass2_to_mchirp_eta(inj_params['mass1'],
                                                  inj_params['mass2'])
    srfn_mcweighted = np.sum((trig_params[i]['match'] * mchirp**(-5./6.) *\
                                 sigma)**3.)
    srfd_mcweighted = np.sum((mchirp**(-5./6.) * sigma)**3.)
    f['sig_rec_fac_chirp_mass_weighted_{}'.format(i)] = srfn_mcweighted / srfd_mcweighted
    f['eff_fitting_factor_chirp_mass_weighted_{}'.format(i)] = \
        (srfn_mcweighted / srfd_mcweighted)**(1./3.)

f.close()
