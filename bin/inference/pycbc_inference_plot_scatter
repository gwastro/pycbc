#! /usr/bin/env python

# Copyright (C) 2016 Miriam Cabero Mueller
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import argparse
import logging
import numpy
import matplotlib
matplotlib.use('agg')
from matplotlib import pyplot
import pycbc
import scipy.stats
from pycbc.inference import option_utils, likelihood
from pycbc.io.inference_hdf import InferenceFile
from pycbc.results.scatter_histograms import scatter_histogram, get_scale_fac

def field_array_to_array(field_array, fields=None):
    """Converts the given field array to a numpy array.
    """
    if fields is None:
        fields = field_array.fieldnames
    # convert samples to 2D array
    arr = numpy.zeros((field_array.size, len(fields)), dtype=float)
    for ii,p in enumerate(fields):
        arr[:,ii] = field_array[p]
    return arr

def construct_kde(samples_array, use_kombine=False):
    """Constructs a KDE from the given samples.
    """
    if use_kombine:
        try:
            import kombine
        except ImportError:
            raise ImportError("kombine is not installed.")
    # construct the kde
    if use_kombine:
        kde = kombine.KDE(samples_array)
    else:
        kde = scipy.stats.gaussian_kde(samples_array.transpose())
    return kde

def plot_density(parameters, samples, plot_density=True, plot_contours=True,
        percentiles=None, cmap='viridis', contour_color='k',
        xmin=None, xmax=None, ymin=None, ymax=None, fig=None, ax=None,
        use_kombine=False):
    """Computes and plots confidence intervals using the given samples.
    """
    if len(parameters) != 2:
        raise ValueError("number of parameters must == 2")
    if percentiles is None:
        percentiles = numpy.array([50., 90.])
    percentiles = 100. - percentiles
    percentiles.sort()

    if ax is None and fig is None:
        fig = pyplot.figure()
    if ax is None:
        ax = fig.add_subplot(111)

    # convert samples to array and construct kde
    arr = field_array_to_array(samples, fields=parameters)
    kde = construct_kde(arr, use_kombine=use_kombine)
    # construct grid to evaluate on
    if xmin is None:
        xmin = samples[parameters[0]].min()
    if xmax is None:
        xmax = samples[parameters[0]].max()
    if ymin is None:
        ymin = samples[parameters[1]].min()
    if ymax is None:
        ymax = samples[parameters[1]].max()
    npts = 100
    X, Y = numpy.mgrid[xmin:xmax:complex(0,npts), ymin:ymax:complex(0,npts)]
    pos = numpy.vstack([X.ravel(), Y.ravel()])
    if use_kombine:
        Z = numpy.exp(kde(pos).reshape(X.shape).T)
        draw = kde.draw
    else:
        Z = numpy.reshape(kde(pos).T, X.shape)
        draw = kde.resample
    # Exclude out-of-bound regions
    # this is a bit kludgy; should probably figure out a better solution
    # eventually for more than just m_p m_s
    bnds_mask = None
    if parameters[0] == 'm_p' and parameters[1] == 'm_s':
        bnds_mask = Y > X
    elif parameters[0] == 'm_s' and parameters[1] == 'm_p':
        bnds_mask = X > Y
    Z[bnds_mask] = 0.
    if plot_density:
        im = ax.imshow(numpy.rot90(Z), extent=[xmin, xmax, ymin, ymax],
            aspect='auto', cmap=cmap, zorder=1)
    if plot_contours:
        # compute the percentile values
        resamps = kde(draw(int(npts**2)))
        if use_kombine:
            resamps = numpy.exp(resamps)
        s = numpy.percentile(resamps, percentiles)
        ct = ax.contour(X, Y, Z, s, colors=contour_color, zorder=5)
        # label contours
        lbls = ['{p}%'.format(p=int(p)) for p in (100. - percentiles)]
        fmt = dict(zip(ct.levels, lbls))
        fs = 8
        if fig is not None:
            # scale appropriately
            scale_fac = get_scale_fac(fig)
            fs *= scale_fac
        ax.clabel(ct, ct.levels, inline=True, fmt=fmt, fontsize=fs)

    return fig



parser = argparse.ArgumentParser()

parser.add_argument("--output-file", type=str, required=True,
                    help="Output plot path.")
parser.add_argument('--z-arg', type=str, required=True,
                    choices=['loglr', 'snr', 'logplr', 'logposterior', 'prior'],
                    help='What to color the points by.')
parser.add_argument("--vmin", type=float,
                    help="Minimum value for the colorbar.")
parser.add_argument("--vmax", type=float,
                    help="Maximum value for the colorbar.")
parser.add_argument("--cmap", type=str, default=None,
                    help="Specify the colormap to use for the points.")
parser.add_argument("--plot-contours", default=False, action="store_true",
                    help="Plot the confidence intervals.")
parser.add_argument("--contour-color", default='k',
                    help='What to color the contours.')
parser.add_argument('--use-kombine-kde', default=False, action="store_true",
                    help="Use kombine's KDE for determining contours. Default "
                         "is to use scipy's gaussian_kde.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Be verbose")
option_utils.add_inference_results_option_group(parser)

opts = parser.parse_args()

pycbc.init_logging(opts.verbose)

# Get parameters
logging.info("Loading parameters")
fp, parameters, labels, samples = option_utils.results_from_cli(opts)
logging.info("Plotting {i} samples".format(i=samples.size))
logging.info("Getting likelihood stats")
likelihood_stats = fp.read_likelihood_stats(thin_start=opts.thin_start,
        thin_end=opts.thin_end, thin_interval=opts.thin_interval,
        iteration=opts.iteration)

# get the value to plot on the z-axis
if opts.z_arg == 'loglr':
    zvals = likelihood_stats.loglr
    zlbl = r'$\log\mathcal{L}(\vec{\vartheta})$'
elif opts.z_arg == 'snr':
    zvals = likelihood.snr_from_loglr(likelihood_stats.loglr) 
    zlbl = r'$\rho(\vec{\vartheta})$'
elif opts.z_arg == 'logplr':
    zvals = likelihood_stats.loglr + likelihood_stats.prior
    zlbl = r'$\log[\mathcal{L}(\vec{\vartheta})p(\vec{\vartheta})]$'
elif opts.z_arg == 'logposterior':
    zvals = likelihood_stats.loglr + likelihood_stats.prior + fp.lognl
    zlbl = r'$\log[p(d|\vec{\vartheta})p(\vec{\vartheta})]$'
elif opts.z_arg == 'prior':
    zvals = likelihood_stats.prior
    zlbl = r'$\log p(\vec{\vartheta})$'
fp.close()

logging.info("Plotting")
fig, axis_dict = scatter_histogram(parameters, samples, zvals, labels=labels,  
                    cbar_label=zlbl, vmin=opts.vmin, vmax=opts.vmax,
                    cmap=opts.cmap)
if opts.plot_contours:
    logging.info("Plotting contours")
    for px,py in axis_dict:
        if px == py:
            continue
        logging.info("{x}, {y}".format(x=px, y=py))
        ax, _, _ = axis_dict[px, py]
        plot_density([px, py], samples, plot_density=False, plot_contours=True,
            percentiles=None, contour_color=opts.contour_color, ax=ax,
            use_kombine=opts.use_kombine_kde)
        
fig.savefig(opts.output_file, bbox_inches='tight', dpi=200)
logging.info("Done")
