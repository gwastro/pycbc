#! /usr/bin/env python

# Copyright (C) 2016 Miriam Cabero Mueller, Collin Capano
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import argparse
import logging
import numpy
import matplotlib
matplotlib.use('agg')
from matplotlib import pyplot
import pycbc
from pycbc.inference import option_utils, likelihood
from pycbc.io.inference_hdf import InferenceFile
from pycbc.results.scatter_histograms import create_multidim_plot

parser = argparse.ArgumentParser()

parser.add_argument("--output-file", type=str, required=True,
                    help="Output plot path.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Be verbose")
parser.add_argument('--plot-marginal', action='store_true', default=False,
                    help="Plot 1D marginalized distributions on the diagonal "
                         "axes.")
parser.add_argument("--plot-scatter", action='store_true', default=False,
                    help="Plot each sample point as a scatter plot.")
parser.add_argument("--plot-density", action="store_true", default=False,
                    help="Plot the posterior density as a color map.")
parser.add_argument("--plot-contours", action="store_true", default=False,
                    help="Draw contours showing the 50th and 90th percentile "
                         "confidence regions.")
# Scatter configuration
scatter_group = parser.add_argument_group("Options for configuring the "
                                          "scatter plot")
scatter_group.add_argument('--z-arg', type=str, default=None,
                    choices=['loglr', 'snr', 'logplr', 'logposterior',
                             'prior'],
                    help='What to color the scatter points by. If not set, '
                         'all points will be the same color. Choices are: '
                         'loglr: the log likelihood ratio; snr: SNR; '
                         'logplr: loglr + log of the prior; '
                         'logposterior: log likelihood function + log prior; '
                         'prior: the log of the prior.')
scatter_group.add_argument('--no-colorbar', action='store_true', default=False,
                    help='Do not show the color bar for the scatter plot. ')
scatter_group.add_argument("--vmin", type=float,
                    help="Minimum value for the colorbar.")
scatter_group.add_argument("--vmax", type=float,
                    help="Maximum value for the colorbar.")
scatter_group.add_argument("--scatter-cmap", type=str, default='viridis',
                    help="Specify the colormap to use for points. Default is "
                         "viridis.")
# Density configuration
density_group = parser.add_argument_group("Options for configuring the "
                                          "contours and density color map")
density_group.add_argument("--density-cmap", type=str, default='viridis',
                    help="Specify the colormap to use for the density. "
                         "Default is viridis.")
density_group.add_argument("--contour-color", type=str, default='k',
                    help="Specify the color to use for the contour lines. "
                         "Default is black (k).")
density_group.add_argument('--use-kombine-kde', default=False,
                    action="store_true",
                    help="Use kombine's KDE for determining contours. Default "
                         "is to use scipy's gaussian_kde.")
# add standard option utils
option_utils.add_inference_results_option_group(parser)

opts = parser.parse_args()

pycbc.init_logging(opts.verbose)

# Get parameters
logging.info("Loading parameters")
fp, parameters, labels, samples = option_utils.results_from_cli(opts)
logging.info("Using {i} samples".format(i=samples.size))
if opts.z_arg is not None:
    logging.info("Getting likelihood stats")
    likelihood_stats = fp.read_likelihood_stats(thin_start=opts.thin_start,
            thin_end=opts.thin_end, thin_interval=opts.thin_interval,
            iteration=opts.iteration)
    if opts.z_arg == 'loglr':
        zvals = likelihood_stats.loglr
        zlbl = r'$\log\mathcal{L}(\vec{\vartheta})$'
    elif opts.z_arg == 'snr':
        zvals = likelihood.snr_from_loglr(likelihood_stats.loglr) 
        zlbl = r'$\rho(\vec{\vartheta})$'
    elif opts.z_arg == 'logplr':
        zvals = likelihood_stats.loglr + likelihood_stats.prior
        zlbl = r'$\log[\mathcal{L}(\vec{\vartheta})p(\vec{\vartheta})]$'
    elif opts.z_arg == 'logposterior':
        zvals = likelihood_stats.loglr + likelihood_stats.prior + fp.lognl
        zlbl = r'$\log[p(d|\vec{\vartheta})p(\vec{\vartheta})]$'
    elif opts.z_arg == 'prior':
        zvals = likelihood_stats.prior
        zlbl = r'$\log p(\vec{\vartheta})$'
else:
    zvals = None
    zlbl = None
fp.close()

logging.info("Plotting")
fig, axis_dict = create_multidim_plot(
                parameters, samples, labels=labels,
                plot_marginal=opts.plot_marginal,
                plot_scatter=opts.plot_scatter,
                    zvals=zvals, show_colorbar=not opts.no_colorbar,
                    cbar_label=zlbl, vmin=opts.vmin, vmax=opts.vmax,
                    scatter_cmap=opts.scatter_cmap,
                plot_density=opts.plot_density,
                plot_contours=opts.plot_contours,
                    density_cmap=opts.density_cmap,
                    contour_color=opts.contour_color,
                    use_kombine=opts.use_kombine_kde)

# save
fig.savefig(opts.output_file, bbox_inches='tight', dpi=200)
logging.info("Done")
