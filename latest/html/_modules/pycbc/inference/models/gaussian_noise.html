

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pycbc.inference.models.gaussian_noise &mdash; PyCBC 2.10.dev1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=751f435e"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/typed.min.js?v=edb71f0b"></script>
      <script src="../../../../_static/terminal.css?v=d691274a"></script>
      <script src="../../../../_static/theme_overrides.css?v=e4e1d026"></script>
      <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(193,193,255,1) 85%)" >

          
          
          <a href="../../../../index.html">
            
              <img src="https://raw.githubusercontent.com/gwastro/pycbc-logo/master/pycbc_logo_name.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installing PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../credit.html">Use of PyCBC in Scientific Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../genindex.html">Index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Library Examples and Interactive Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../searches.html">PyCBC searches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../inference.html">PyCBC inference documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.inference</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../apps.html">Applications and Workflows</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Dev Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../extend.html">Extending PyCBC with external plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../devs.html">Documentation for Developers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(193,193,255,1) 85%)" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PyCBC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../pycbc.html">pycbc</a></li>
          <li class="breadcrumb-item"><a href="../models.html">pycbc.inference.models</a></li>
      <li class="breadcrumb-item active">pycbc.inference.models.gaussian_noise</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pycbc.inference.models.gaussian_noise</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2018  Collin Capano</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU General Public License as published by the</span>
<span class="c1"># Free Software Foundation; either version 3 of the License, or (at your</span>
<span class="c1"># option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but</span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c1"># Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>

<span class="sd">&quot;&quot;&quot;This module provides model classes that assume the noise is Gaussian.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shlex</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc</span><span class="w"> </span><span class="kn">import</span> <span class="nb">filter</span> <span class="k">as</span> <span class="n">pyfilter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.waveform</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">NoWaveformError</span><span class="p">,</span> <span class="n">FailedWaveformError</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.waveform</span><span class="w"> </span><span class="kn">import</span> <span class="n">generator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.strain</span><span class="w"> </span><span class="kn">import</span> <span class="n">gates_from_cli</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.strain.calibration</span><span class="w"> </span><span class="kn">import</span> <span class="n">Recalibrate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.inject</span><span class="w"> </span><span class="kn">import</span> <span class="n">InjectionSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">FieldArray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.types.optparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiDetOptionAction</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">ModelStats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.base_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseDataModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.data_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">data_opts_from_config</span><span class="p">,</span> <span class="n">data_from_cli</span><span class="p">,</span>
                         <span class="n">fd_data_from_strain_dict</span><span class="p">,</span> <span class="n">gate_overwhitened_data</span><span class="p">)</span>


<div class="viewcode-block" id="catch_waveform_error">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.catch_waveform_error">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">catch_waveform_error</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator that will catch no waveform errors.</span>

<span class="sd">    This can be added to a method in an inference model. The decorator will</span>
<span class="sd">    call the model&#39;s `_nowaveform_return` method if either of the following</span>
<span class="sd">    happens when the wrapped method is executed:</span>

<span class="sd">      * A `NoWaveformError` is raised.</span>
<span class="sd">      * A `RuntimeError` or `FailedWaveformError` is raised and the model has</span>
<span class="sd">        an `ignore_failed_waveforms` attribute that is set to True.</span>

<span class="sd">    This requires the model to have a `_nowaveform_handler` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the functools.wroaps decorator preserves the original method&#39;s name</span>
    <span class="c1"># and docstring</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">method_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NoWaveformError</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nowaveform_handler</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">FailedWaveformError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ignore_failed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_failed_waveforms</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">ignore_failed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">ignore_failed</span><span class="p">:</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nowaveform_handler</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">retval</span>
    <span class="k">return</span> <span class="n">method_wrapper</span></div>



<div class="viewcode-block" id="BaseGaussianNoise">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseGaussianNoise</span><span class="p">(</span><span class="n">BaseDataModel</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model for analyzing GW data with assuming a wide-sense stationary</span>
<span class="sd">    Gaussian noise model.</span>

<span class="sd">    This model will load gravitational wave data and calculate the log noise</span>
<span class="sd">    likelihood ``_lognl`` and normalization. It also implements the</span>
<span class="sd">    ``_loglikelihood`` function as the sum of the log likelihood ratio and the</span>
<span class="sd">    ``lognl``. It does not implement a log likelihood ratio function</span>
<span class="sd">    ``_loglr``, however, since that can differ depending on the signal model.</span>
<span class="sd">    Models that analyze GW data assuming it is stationary Gaussian should</span>
<span class="sd">    therefore inherit from this class and implement their own ``_loglr``</span>
<span class="sd">    function.</span>

<span class="sd">    For more details on the inner product used, the log likelihood of the</span>
<span class="sd">    noise, and the normalization factor, see :py:class:`GaussianNoise`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable_params : (tuple of) string(s)</span>
<span class="sd">        A tuple of parameter names that will be varied.</span>
<span class="sd">    data : dict</span>
<span class="sd">        A dictionary of data, in which the keys are the detector names and the</span>
<span class="sd">        values are the data (assumed to be unwhitened). All data must have the</span>
<span class="sd">        same frequency resolution.</span>
<span class="sd">    low_frequency_cutoff : dict</span>
<span class="sd">        A dictionary of starting frequencies, in which the keys are the</span>
<span class="sd">        detector names and the values are the starting frequencies for the</span>
<span class="sd">        respective detectors to be used for computing inner products.</span>
<span class="sd">    psds : dict, optional</span>
<span class="sd">        A dictionary of FrequencySeries keyed by the detector names. The</span>
<span class="sd">        dictionary must have a psd for each detector specified in the data</span>
<span class="sd">        dictionary. If provided, the inner products in each detector will be</span>
<span class="sd">        weighted by 1/psd of that detector.</span>
<span class="sd">    high_frequency_cutoff : dict, optional</span>
<span class="sd">        A dictionary of ending frequencies, in which the keys are the</span>
<span class="sd">        detector names and the values are the ending frequencies for the</span>
<span class="sd">        respective detectors to be used for computing inner products. If not</span>
<span class="sd">        provided, the minimum of the largest frequency stored in the data</span>
<span class="sd">        and a given waveform will be used.</span>
<span class="sd">    normalize : bool, optional</span>
<span class="sd">        If True, the normalization factor :math:`alpha` will be included in the</span>
<span class="sd">        log likelihood. See :py:class:`GaussianNoise` for details. Default is</span>
<span class="sd">        to not include it.</span>
<span class="sd">    static_params : dict, optional</span>
<span class="sd">        A dictionary of parameter names -&gt; values to keep fixed.</span>
<span class="sd">    ignore_failed_waveforms : bool, optional</span>
<span class="sd">        If the waveform generator raises an error when it tries to generate,</span>
<span class="sd">        treat the point as having zero likelihood. This allows the parameter</span>
<span class="sd">        estimation to continue. Otherwise, an error will be raised, stopping</span>
<span class="sd">        the run. Default is False.</span>
<span class="sd">    \**kwargs :</span>
<span class="sd">        All other keyword arguments are passed to ``BaseDataModel``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ignore_failed_waveforms : bool</span>
<span class="sd">        If True, points in parameter space that cause waveform generation to</span>
<span class="sd">        fail (i.e., they raise a ``FailedWaveformError``) will be treated as</span>
<span class="sd">        points with zero likelihood. Otherwise, such points will cause the</span>
<span class="sd">        model to raise a ``FailedWaveformError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">psds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">static_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_failed_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">no_save_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># set up the boiler-plate attributes</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseGaussianNoise</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">variable_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                                                <span class="n">static_params</span><span class="o">=</span><span class="n">static_params</span><span class="p">,</span>
                                                <span class="n">no_save_data</span><span class="o">=</span><span class="n">no_save_data</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_failed_waveforms</span> <span class="o">=</span> <span class="n">ignore_failed_waveforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_save_data</span> <span class="o">=</span> <span class="n">no_save_data</span>
        <span class="c1"># check if low frequency cutoff has been provided for every IFO with</span>
        <span class="c1"># data</span>
        <span class="k">for</span> <span class="n">ifo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">low_frequency_cutoff</span><span class="p">[</span><span class="n">ifo</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;A low-frequency-cutoff must be provided for every &quot;</span>
                    <span class="s2">&quot;detector for which data has been provided. If &quot;</span>
                    <span class="s2">&quot;loading the model settings from &quot;</span>
                    <span class="s2">&quot;a config file, please provide &quot;</span>
                    <span class="s2">&quot;`</span><span class="si">{DETECTOR}</span><span class="s2">:low-frequency-cutoff` options for &quot;</span>
                    <span class="s2">&quot;every detector in the `[model]` section, where &quot;</span>
                    <span class="s2">&quot;`</span><span class="si">{DETECTOR}</span><span class="s2"> is the name of the detector,&quot;</span>
                    <span class="s2">&quot;or provide a single low-frequency-cutoff option&quot;</span>
                    <span class="s2">&quot;which will be used for all detectors&quot;</span><span class="p">)</span>

        <span class="c1"># check that the data sets all have the same delta fs and delta ts</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">delta_t</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">delta_f</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">dts</span> <span class="o">==</span> <span class="n">dts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">dfs</span> <span class="o">==</span> <span class="n">dfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_ifodata_same_rate_length</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_ifodata_same_rate_length</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;You are using different data segment lengths or &quot;</span>
                <span class="s2">&quot;sampling rates for different IFOs&quot;</span><span class="p">)</span>

        <span class="c1"># store the number of samples in the time domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">det</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">delta_f</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">delta_t</span><span class="p">))</span>

        <span class="c1"># set lower/upper frequency cutoff</span>
        <span class="k">if</span> <span class="n">high_frequency_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high_frequency_cutoff</span> <span class="o">=</span> <span class="p">{</span><span class="n">ifo</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ifo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span> <span class="o">=</span> <span class="n">high_frequency_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_lower</span> <span class="o">=</span> <span class="n">low_frequency_cutoff</span>

        <span class="c1"># Set the cutoff indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">det</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">pyfilter</span><span class="o">.</span><span class="n">get_cutoff_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f_lower</span><span class="p">[</span><span class="n">det</span><span class="p">],</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span><span class="p">[</span><span class="n">det</span><span class="p">],</span>
                                                     <span class="n">d</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmax</span>

        <span class="c1"># store the psd segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psd_segments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">psds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_psd_segments</span><span class="p">(</span><span class="n">psds</span><span class="p">)</span>

        <span class="c1"># store the psds and calculate the inner product weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invpsds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># set the normalization state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
        <span class="c1"># store the psds and whiten the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psds</span> <span class="o">=</span> <span class="n">psds</span>

        <span class="c1"># attribute for storing the current waveforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">high_frequency_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The high frequency cutoff of the inner product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">low_frequency_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The low frequency cutoff of the inner product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_lower</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of starting indices for the inner product.</span>

<span class="sd">        This is determined from the lower frequency cutoff and the ``delta_f``</span>
<span class="sd">        of the data using</span>
<span class="sd">        :py:func:`pycbc.filter.matchedfilter.get_cutoff_indices`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of ending indices for the inner product.</span>

<span class="sd">        This is determined from the high frequency cutoff and the ``delta_f``</span>
<span class="sd">        of the data using</span>
<span class="sd">        :py:func:`pycbc.filter.matchedfilter.get_cutoff_indices`. If no high</span>
<span class="sd">        frequency cutoff was provided, this will be the indice corresponding to</span>
<span class="sd">        the Nyquist frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">psds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of detectors -&gt; PSD frequency series.</span>

<span class="sd">        If no PSD was provided for a detector, this will just be a frequency</span>
<span class="sd">        series of ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span>

    <span class="nd">@psds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">psds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the psds, and calculates the weight and norm from them.</span>

<span class="sd">        The data and the low and high frequency cutoffs must be set first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check that the data has been set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;low frequency cutoff not set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;high frequency cutoff not set&quot;</span><span class="p">)</span>
        <span class="c1"># make sure the relevant caches are cleared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invpsds</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">det</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">psds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No psd means assume white PSD</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">delta_f</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># copy for storage</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">psds</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="c1"># we&#39;ll store the weight to apply to the inner product</span>
            <span class="c1"># only set weight in band we will analyze</span>
            <span class="n">kmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">kmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">invp</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span> <span class="n">delta_f</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
            <span class="n">invp</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invpsds</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">invp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">invp</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">*</span> <span class="n">invp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
        <span class="c1"># set the lognl and lognorm; we&#39;ll get this by just calling lognl</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lognl</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">psd_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary giving times used for PSD estimation for each detector.</span>

<span class="sd">        If a detector&#39;s PSD was not estimated from data, or the segment wasn&#39;t</span>
<span class="sd">        provided, that detector will not be in the dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psd_segments</span>

<div class="viewcode-block" id="BaseGaussianNoise.set_psd_segments">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.set_psd_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_psd_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the PSD segments from a dictionary of PSDs.</span>

<span class="sd">        This attempts to get the PSD segment from a ``psd_segment`` attribute</span>
<span class="sd">        of each detector&#39;s PSD frequency series. If that attribute isn&#39;t set,</span>
<span class="sd">        then that detector is not added to the dictionary of PSD segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psds : dict</span>
<span class="sd">            Dictionary of detector name -&gt; PSD frequency series. The segment</span>
<span class="sd">            used for each PSD will try to be retrieved from the PSD&#39;s</span>
<span class="sd">            ``.psd_segment`` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">det</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">psds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psd_segments</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">psd_segment</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">continue</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dictionary of detectors -&gt; frequency series of inner-product</span>
<span class="sd">        weights.</span>

<span class="sd">        The weights are :math:`\sqrt{4 \Delta f / S_n(f)}`. This is set when</span>
<span class="sd">        the PSDs are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">whitened_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dictionary of detectors -&gt; whitened data frequency series.</span>

<span class="sd">        The whitened data is the data multiplied by the inner-product weight.</span>
<span class="sd">        Note that this includes the :math:`\sqrt{4 \Delta f}` factor. This</span>
<span class="sd">        is set when the PSDs are set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span>

<div class="viewcode-block" id="BaseGaussianNoise.det_lognorm">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.det_lognorm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">det_lognorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The log of the likelihood normalization in the given detector.</span>

<span class="sd">        If ``self.normalize`` is False, will just return 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># hasn&#39;t been calculated yet</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">delta_t</span>
            <span class="n">kmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">kmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">lognorm</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                             <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">lognorm</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span><span class="p">[</span><span class="n">det</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determines if the loglikelihood includes the normalization term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span>

    <span class="nd">@normalize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clears the current stats if the normalization state is changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">normalize</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span> <span class="o">=</span> <span class="n">ModelStats</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lognorm</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span> <span class="o">=</span> <span class="n">normalize</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lognorm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The log of the normalization of the log likelihood.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_lognorm</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

<div class="viewcode-block" id="BaseGaussianNoise.det_lognl">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.det_lognl">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">det_lognl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the log likelihood of the noise in the given detector:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \log p(d_i|n_i) = \log \alpha_i -</span>
<span class="sd">                \frac{1}{2} \left&lt;d_i | d_i\right&gt;.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        det : str</span>
<span class="sd">            The name of the detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float :</span>
<span class="sd">            The log likelihood of the noise in the requested detector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># hasn&#39;t been calculated yet; calculate &amp; store</span>
            <span class="n">kmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">kmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="n">lognorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_lognorm</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>
            <span class="n">lognl</span> <span class="o">=</span> <span class="n">lognorm</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">lognl</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det_lognls</span><span class="p">[</span><span class="n">det</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_lognl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the log likelihood assuming the data is noise.</span>

<span class="sd">        Since this is a constant for Gaussian noise, this is only computed once</span>
<span class="sd">        then stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_lognl</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

<div class="viewcode-block" id="BaseGaussianNoise.update">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="c1"># update</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># reset current waveforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_loglikelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the log likelihood of the paramaters,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \log p(d|\Theta, h) = \log \alpha -\frac{1}{2}\sum_i</span>
<span class="sd">                \left&lt;d_i - h_i(\Theta) | d_i - h_i(\Theta)\right&gt;,</span>

<span class="sd">        at the current parameter values :math:`\Theta`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the log likelihood evaluated at the given point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># since the loglr has fewer terms, we&#39;ll call that, then just add</span>
        <span class="c1"># back the noise term that canceled in the log likelihood ratio</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lognl</span>

<div class="viewcode-block" id="BaseGaussianNoise.write_metadata">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.write_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds writing the psds, analyzed detectors, and lognl.</span>

<span class="sd">        The analyzed detectors, their analysis segments, and the segments</span>
<span class="sd">        used for psd estimation are written as</span>
<span class="sd">        ``analyzed_detectors``, ``{{detector}}_analysis_segment``, and</span>
<span class="sd">        ``{{detector}}_psd_segment``, respectively. These are either written</span>
<span class="sd">        to the specified ``group``&#39;s attrs, or to the top level attrs if</span>
<span class="sd">        ``group`` is None.</span>

<span class="sd">        The total and each detector&#39;s lognl is written to the sample group&#39;s</span>
<span class="sd">        ``attrs``. If a group is specified, the group name will be prependend</span>
<span class="sd">        to the lognl labels with ``{group}__``, with any ``/`` in the group</span>
<span class="sd">        path replaced with ``__``. For example, if group is ``/a/b``, the</span>
<span class="sd">        ``lognl`` will be written as ``a__b__lognl`` in the sample&#39;s group</span>
<span class="sd">        attrs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fp : pycbc.inference.io.BaseInferenceFile instance</span>
<span class="sd">            The inference file to write to.</span>
<span class="sd">        group : str, optional</span>
<span class="sd">            If provided, the metadata will be written to the attrs specified</span>
<span class="sd">            by group, i.e., to ``fp[group].attrs``. Otherwise, metadata is</span>
<span class="sd">            written to the top-level attrs (``fp.attrs``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">write_metadata</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getattrs</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
        <span class="c1"># write the analyzed detectors and times</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;analyzed_detectors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detectors</span>
        <span class="k">for</span> <span class="n">det</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_analysis_segment&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>
            <span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">start_time</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">end_time</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_save_data</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write_psd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psds</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
        <span class="c1"># write the times used for psd estimation (if they were provided)</span>
        <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_segments</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_psd_segment&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>
            <span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_segments</span><span class="p">[</span><span class="n">det</span><span class="p">]))</span>
        <span class="c1"># save the frequency cutoffs</span>
        <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">detectors</span><span class="p">:</span>
            <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_likelihood_low_freq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_lower</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_likelihood_high_freq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_f_upper</span><span class="p">[</span><span class="n">det</span><span class="p">]</span>
        <span class="c1"># write the lognl to the samples group attrs</span>
        <span class="n">sampattrs</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getattrs</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">fp</span><span class="o">.</span><span class="n">samples_group</span><span class="p">)</span>
        <span class="c1"># if a group is specified, prepend the lognl names with it</span>
        <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">group</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;__&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
                <span class="n">prefix</span> <span class="o">+=</span> <span class="s1">&#39;__&#39;</span>
        <span class="n">sampattrs</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">lognl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lognl</span>
        <span class="c1"># also save the lognl in each detector</span>
        <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">detectors</span><span class="p">:</span>
            <span class="n">sampattrs</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">_lognl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">det</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_lognl</span><span class="p">(</span><span class="n">det</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fd_data_from_strain_dict</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">strain_dict</span><span class="p">,</span> <span class="n">psd_strain_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper around :py:func:`data_utils.fd_data_from_strain_dict`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fd_data_from_strain_dict</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">strain_dict</span><span class="p">,</span> <span class="n">psd_strain_dict</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_nowaveform_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method that gets called if a NoWaveformError or FailedWaveformError</span>
<span class="sd">        is raised. See the :py:func:catch_waveform_error decorator for details.</span>

<span class="sd">        Here, this will just raise a NotImplementedError, since how this should</span>
<span class="sd">        be handled is model dependent. Models that wish to deal with this</span>
<span class="sd">        scenario should override this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;A waveform could not be generated, but this model does not know &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;how to handle that. The parameters were: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_params</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BaseGaussianNoise.from_config">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.BaseGaussianNoise.from_config">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">data_section</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initializes an instance of this class from the given config file.</span>

<span class="sd">        In addition to ``[model]``, a ``data_section`` (default ``[data]``)</span>
<span class="sd">        must be in the configuration file. The data section specifies settings</span>
<span class="sd">        for loading data and estimating PSDs. See the `online documentation</span>
<span class="sd">        &lt;http://pycbc.org/pycbc/latest/html/inference.html#setting-data&gt;`_ for</span>
<span class="sd">        more details.</span>

<span class="sd">        The following options are read from the ``[model]`` section, in</span>
<span class="sd">        addition to ``name`` (which must be set):</span>

<span class="sd">        * ``{{DET}}-low-frequency-cutoff = FLOAT`` :</span>
<span class="sd">          The low frequency cutoff to use for each detector {{DET}}. A cutoff</span>
<span class="sd">          must be provided for every detector that may be analyzed (any</span>
<span class="sd">          additional detectors are ignored).</span>
<span class="sd">        * ``{{DET}}-high-frequency-cutoff = FLOAT`` :</span>
<span class="sd">          (Optional) A high frequency cutoff for each detector. If not</span>
<span class="sd">          provided, the Nyquist frequency is used.</span>
<span class="sd">        * ``check-for-valid-times =`` :</span>
<span class="sd">          (Optional) If provided, will check that there are no data quality</span>
<span class="sd">          flags on during the analysis segment and the segment used for PSD</span>
<span class="sd">          estimation in each detector. To check for flags,</span>
<span class="sd">          :py:func:`pycbc.dq.query_flag` is used, with settings pulled from the</span>
<span class="sd">          ``dq-*`` options in the ``[data]`` section. If a detector has bad</span>
<span class="sd">          data quality during either the analysis segment or PSD segment, it</span>
<span class="sd">          will be removed from the analysis.</span>
<span class="sd">        * ``shift-psd-times-to-valid =`` :</span>
<span class="sd">          (Optional) If provided, the segment used for PSD estimation will</span>
<span class="sd">          automatically be shifted left or right until a continous block of</span>
<span class="sd">          data with no data quality issues can be found. If no block can be</span>
<span class="sd">          found with a maximum shift of +/- the requested psd segment length,</span>
<span class="sd">          the detector will not be analyzed.</span>
<span class="sd">        * ``err-on-missing-detectors =`` :</span>
<span class="sd">          Raises an error if any detector is removed from the analysis because</span>
<span class="sd">          a valid time could not be found. Otherwise, a warning is printed</span>
<span class="sd">          to screen and the detector is removed from the analysis.</span>
<span class="sd">        * ``normalize =`` :</span>
<span class="sd">          (Optional) Turn on the normalization factor.</span>
<span class="sd">        * ``ignore-failed-waveforms =`` :</span>
<span class="sd">          Sets the ``ignore_failed_waveforms`` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cp : WorkflowConfigParser</span>
<span class="sd">            Config file parser to read.</span>
<span class="sd">        data_section : str, optional</span>
<span class="sd">            The name of the section to load data options from.</span>
<span class="sd">        \**kwargs :</span>
<span class="sd">            All additional keyword arguments are passed to the class. Any</span>
<span class="sd">            provided keyword will override what is in the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the injection file, to replace any FROM_INJECTION settings</span>
        <span class="k">if</span> <span class="s1">&#39;injection-file&#39;</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">injection_file</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;injection-file&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">injection_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># update any values that are to be retrieved from the injection</span>
        <span class="c1"># Note: this does nothing if there are FROM_INJECTION values</span>
        <span class="n">get_values_from_injection</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">injection_file</span><span class="p">,</span> <span class="n">update_cp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_init_args_from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
        <span class="c1"># add the injection file</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;injection_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">injection_file</span>
        <span class="c1"># check if normalize is set</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="s1">&#39;normalize&#39;</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;normalize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore-failed-waveforms&#39;</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;ignore_failed_waveforms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="s1">&#39;det-frame-waveform&#39;</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;det_frame_waveform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="s1">&#39;no-save-data&#39;</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;no_save_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># get any other keyword arguments provided in the model section</span>
        <span class="n">ignore_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;name&#39;</span><span class="p">,</span>
            <span class="s1">&#39;normalize&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ignore-failed-waveforms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;no-save-data&#39;</span><span class="p">,</span>
            <span class="s1">&#39;det-frame-waveform&#39;</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">option</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;low-frequency-cutoff&quot;</span><span class="p">,</span> <span class="s2">&quot;high-frequency-cutoff&quot;</span><span class="p">):</span>
                <span class="n">ignore_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">option</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
                <span class="n">args</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_cli_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                                               <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                               <span class="n">action</span><span class="o">=</span><span class="n">MultiDetOptionAction</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;low_frequency_cutoff&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;low-frequency-cutoff must be provided in the&quot;</span>
                             <span class="s2">&quot; model section, but is not found!&quot;</span><span class="p">)</span>

        <span class="c1"># data args</span>
        <span class="n">bool_args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;check-for-valid-times&#39;</span><span class="p">,</span> <span class="s1">&#39;shift-psd-times-to-valid&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;err-on-missing-detectors&#39;</span><span class="p">]</span>
        <span class="n">data_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">):</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">bool_args</span>
                     <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)}</span>
        <span class="n">ignore_args</span> <span class="o">+=</span> <span class="n">bool_args</span>
        <span class="c1"># load the data</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">data_opts_from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">data_section</span><span class="p">,</span>
                                     <span class="n">args</span><span class="p">[</span><span class="s1">&#39;low_frequency_cutoff&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">psds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strain_dict</span><span class="p">,</span> <span class="n">psd_strain_dict</span> <span class="o">=</span> <span class="n">data_from_cli</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">**</span><span class="n">data_args</span><span class="p">)</span>
            <span class="c1"># convert to frequency domain and get psds</span>
            <span class="n">stilde_dict</span><span class="p">,</span> <span class="n">psds</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fd_data_from_strain_dict</span><span class="p">(</span>
                <span class="n">opts</span><span class="p">,</span> <span class="n">strain_dict</span><span class="p">,</span> <span class="n">psd_strain_dict</span><span class="p">)</span>
            <span class="c1"># save the psd data segments if the psd was estimated from data</span>
            <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">psd_estimation</span><span class="p">:</span>
                <span class="n">_tdict</span> <span class="o">=</span> <span class="n">psd_strain_dict</span> <span class="ow">or</span> <span class="n">strain_dict</span>
                <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="n">psds</span><span class="p">:</span>
                    <span class="n">psds</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">psd_segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">_tdict</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span>
                                             <span class="n">_tdict</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
            <span class="c1"># gate overwhitened if desired</span>
            <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">gate_overwhitened</span> <span class="ow">and</span> <span class="n">opts</span><span class="o">.</span><span class="n">gate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stilde_dict</span> <span class="o">=</span> <span class="n">gate_overwhitened_data</span><span class="p">(</span>
                    <span class="n">stilde_dict</span><span class="p">,</span> <span class="n">psds</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">gate</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stilde_dict</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39;psds&#39;</span><span class="p">:</span> <span class="n">psds</span><span class="p">})</span>
        <span class="c1"># any extra args</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">extra_args_from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s2">&quot;model&quot;</span><span class="p">,</span>
                                               <span class="n">skip_args</span><span class="o">=</span><span class="n">ignore_args</span><span class="p">))</span>
        <span class="c1"># get ifo-specific instances of calibration model</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="s1">&#39;calibration&#39;</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initializing calibration model&quot;</span><span class="p">)</span>
            <span class="n">recalib</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">ifo</span><span class="p">:</span> <span class="n">Recalibrate</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ifo</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;calibration&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ifo</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">instruments</span><span class="p">}</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;recalibration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recalib</span>
        <span class="c1"># get gates for templates</span>
        <span class="n">gates</span> <span class="o">=</span> <span class="n">gates_from_cli</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gates</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;gates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gates</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="GaussianNoise">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.GaussianNoise">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GaussianNoise</span><span class="p">(</span><span class="n">BaseGaussianNoise</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Model that assumes data is stationary Gaussian noise.</span>

<span class="sd">    With Gaussian noise the log likelihood functions for signal</span>
<span class="sd">    :math:`\log p(d|\Theta, h)` and for noise :math:`\log p(d|n)` are given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \log p(d|\Theta, h) &amp;=  \log\alpha -\frac{1}{2} \sum_i</span>
<span class="sd">            \left&lt; d_i - h_i(\Theta) | d_i - h_i(\Theta) \right&gt; \\</span>
<span class="sd">        \log p(d|n) &amp;= \log\alpha -\frac{1}{2} \sum_i \left&lt;d_i | d_i\right&gt;</span>

<span class="sd">    where the sum is over the number of detectors, :math:`d_i` is the data in</span>
<span class="sd">    each detector, and :math:`h_i(\Theta)` is the model signal in each</span>
<span class="sd">    detector. The (discrete) inner product is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \left&lt;a_i | b_i\right&gt; = 4\Re \Delta f</span>
<span class="sd">            \sum_{k=k_{\mathrm{min}}}^{k_{\mathrm{max}}}</span>
<span class="sd">            \frac{\tilde{a}_i^{*}[k] \tilde{b}_i[k]}{S^{(i)}_n[k]},</span>

<span class="sd">    where :math:`\Delta f` is the frequency resolution (given by 1 / the</span>
<span class="sd">    observation time :math:`T`), :math:`k` is an index over the discretely</span>
<span class="sd">    sampled frequencies :math:`f = k \Delta_f`, and :math:`S^{(i)}_n[k]` is the</span>
<span class="sd">    PSD in the given detector. The upper cutoff on the inner product</span>
<span class="sd">    :math:`k_{\max}` is by default the Nyquist frequency</span>
<span class="sd">    :math:`k_{\max} = N/2+1`, where :math:`N = \lfloor T/\Delta t \rfloor`</span>
<span class="sd">    is the number of samples in the time domain, but this can be set manually</span>
<span class="sd">    to a smaller value.</span>

<span class="sd">    The normalization factor :math:`\alpha` is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \alpha = \prod_{i} \frac{1}{\left(\pi T\right)^{N/2}</span>
<span class="sd">            \prod_{k=k_\mathrm{min}}^{k_{\mathrm{max}}} S^{(i)}_n[k]},</span>

<span class="sd">    where the product is over the number of detectors. By default, the</span>
<span class="sd">    normalization constant is not included in the log likelihood, but it can</span>
<span class="sd">    be turned on using the ``normalize`` keyword argument.</span>

<span class="sd">    Note that the log likelihood ratio has fewer terms than the log likelihood,</span>
<span class="sd">    since the normalization and :math:`\left&lt;d_i|d_i\right&gt;` terms cancel:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \log \mathcal{L}(\Theta) = \sum_i \left[</span>
<span class="sd">            \left&lt;h_i(\Theta)|d_i\right&gt; -</span>
<span class="sd">            \frac{1}{2} \left&lt;h_i(\Theta)|h_i(\Theta)\right&gt; \right]</span>

<span class="sd">    Upon initialization, the data is whitened using the given PSDs. If no PSDs</span>
<span class="sd">    are given the data and waveforms returned by the waveform generator are</span>
<span class="sd">    assumed to be whitened.</span>

<span class="sd">    For more details on initialization parameters and definition of terms, see</span>
<span class="sd">    :py:class:`models.BaseDataModel`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable_params : (tuple of) string(s)</span>
<span class="sd">        A tuple of parameter names that will be varied.</span>
<span class="sd">    data : dict</span>
<span class="sd">        A dictionary of data, in which the keys are the detector names and the</span>
<span class="sd">        values are the data (assumed to be unwhitened). The list of keys must</span>
<span class="sd">        match the waveform generator&#39;s detectors keys, and the epoch of every</span>
<span class="sd">        data set must be the same as the waveform generator&#39;s epoch.</span>
<span class="sd">    low_frequency_cutoff : dict</span>
<span class="sd">        A dictionary of starting frequencies, in which the keys are the</span>
<span class="sd">        detector names and the values are the starting frequencies for the</span>
<span class="sd">        respective detectors to be used for computing inner products.</span>
<span class="sd">    psds : dict, optional</span>
<span class="sd">        A dictionary of FrequencySeries keyed by the detector names. The</span>
<span class="sd">        dictionary must have a psd for each detector specified in the data</span>
<span class="sd">        dictionary. If provided, the inner products in each detector will be</span>
<span class="sd">        weighted by 1/psd of that detector.</span>
<span class="sd">    high_frequency_cutoff : dict, optional</span>
<span class="sd">        A dictionary of ending frequencies, in which the keys are the</span>
<span class="sd">        detector names and the values are the ending frequencies for the</span>
<span class="sd">        respective detectors to be used for computing inner products. If not</span>
<span class="sd">        provided, the minimum of the largest frequency stored in the data</span>
<span class="sd">        and a given waveform will be used.</span>
<span class="sd">    normalize : bool, optional</span>
<span class="sd">        If True, the normalization factor :math:`alpha` will be included in the</span>
<span class="sd">        log likelihood. Default is to not include it.</span>
<span class="sd">    static_params : dict, optional</span>
<span class="sd">        A dictionary of parameter names -&gt; values to keep fixed.</span>
<span class="sd">    det_frame_waveform : bool</span>
<span class="sd">        If True, the waveform will be generated directly in the detector frame</span>
<span class="sd">        using the</span>
<span class="sd">        :py:class:`~pycbc.waveform.generator.FDomainDirectDetFrameGenerator`.</span>
<span class="sd">        This requires the approximant be implemented in</span>
<span class="sd">        :py:func:`~pycbc.waveform.get_fd_det_waveform`.</span>
<span class="sd">        If False, the</span>
<span class="sd">        :py:class:`~pycbc.waveform.generator.FDomainDetFrameGenerator` will be</span>
<span class="sd">        used instead. Defaults to :code:`False`.</span>
<span class="sd">    \**kwargs :</span>
<span class="sd">        All other keyword arguments are passed to ``BaseDataModel``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a signal, and set up the model using that signal:</span>

<span class="sd">    &gt;&gt;&gt; from pycbc import psd as pypsd</span>
<span class="sd">    &gt;&gt;&gt; from pycbc.inference.models import GaussianNoise</span>
<span class="sd">    &gt;&gt;&gt; from pycbc.waveform.generator import (FDomainDetFrameGenerator,</span>
<span class="sd">    ...                                       FDomainCBCGenerator)</span>
<span class="sd">    &gt;&gt;&gt; seglen = 4</span>
<span class="sd">    &gt;&gt;&gt; sample_rate = 2048</span>
<span class="sd">    &gt;&gt;&gt; N = seglen*sample_rate/2+1</span>
<span class="sd">    &gt;&gt;&gt; fmin = 30.</span>
<span class="sd">    &gt;&gt;&gt; static_params = {&#39;approximant&#39;: &#39;IMRPhenomD&#39;, &#39;f_lower&#39;: fmin,</span>
<span class="sd">    ...                  &#39;mass1&#39;: 38.6, &#39;mass2&#39;: 29.3,</span>
<span class="sd">    ...                  &#39;spin1z&#39;: 0., &#39;spin2z&#39;: 0., &#39;ra&#39;: 1.37, &#39;dec&#39;: -1.26,</span>
<span class="sd">    ...                  &#39;polarization&#39;: 2.76, &#39;distance&#39;: 3*500.}</span>
<span class="sd">    &gt;&gt;&gt; variable_params = [&#39;tc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; tsig = 3.1</span>
<span class="sd">    &gt;&gt;&gt; generator = FDomainDetFrameGenerator(</span>
<span class="sd">    ...     FDomainCBCGenerator, 0., detectors=[&#39;H1&#39;, &#39;L1&#39;],</span>
<span class="sd">    ...     variable_args=variable_params,</span>
<span class="sd">    ...     delta_f=1./seglen, **static_params)</span>
<span class="sd">    &gt;&gt;&gt; signal = generator.generate(tc=tsig)</span>
<span class="sd">    &gt;&gt;&gt; psd = pypsd.aLIGOZeroDetHighPower(N, 1./seglen, 20.)</span>
<span class="sd">    &gt;&gt;&gt; psds = {&#39;H1&#39;: psd, &#39;L1&#39;: psd}</span>
<span class="sd">    &gt;&gt;&gt; low_frequency_cutoff = {&#39;H1&#39;: fmin, &#39;L1&#39;: fmin}</span>
<span class="sd">    &gt;&gt;&gt; model = GaussianNoise(variable_params, signal, low_frequency_cutoff,</span>
<span class="sd">                              psds=psds, static_params=static_params)</span>

<span class="sd">    Set the current position to the coalescence time of the signal:</span>

<span class="sd">    &gt;&gt;&gt; model.update(tc=tsig)</span>

<span class="sd">    Now compute the log likelihood ratio and prior-weighted likelihood ratio;</span>
<span class="sd">    since we have not provided a prior, these should be equal to each other:</span>

<span class="sd">    &gt;&gt;&gt; print(&#39;{:.2f}&#39;.format(model.loglr))</span>
<span class="sd">    282.43</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;{:.2f}&#39;.format(model.logplr))</span>
<span class="sd">    282.43</span>

<span class="sd">    Print all of the default_stats:</span>

<span class="sd">    &gt;&gt;&gt; print(&#39;,\n&#39;.join([&#39;{}: {:.2f}&#39;.format(s, v)</span>
<span class="sd">    ...                   for (s, v) in sorted(model.current_stats.items())]))</span>
<span class="sd">    H1_cplx_loglr: 177.76+0.00j,</span>
<span class="sd">    H1_optimal_snrsq: 355.52,</span>
<span class="sd">    L1_cplx_loglr: 104.67+0.00j,</span>
<span class="sd">    L1_optimal_snrsq: 209.35,</span>
<span class="sd">    logjacobian: 0.00,</span>
<span class="sd">    loglikelihood: 0.00,</span>
<span class="sd">    loglr: 282.43,</span>
<span class="sd">    logprior: 0.00</span>

<span class="sd">    Compute the SNR; for this system and PSD, this should be approximately 24:</span>

<span class="sd">    &gt;&gt;&gt; from pycbc.conversions import snr_from_loglr</span>
<span class="sd">    &gt;&gt;&gt; x = snr_from_loglr(model.loglr)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;{:.2f}&#39;.format(x))</span>
<span class="sd">    23.77</span>

<span class="sd">    Since there is no noise, the SNR should be the same as the quadrature sum</span>
<span class="sd">    of the optimal SNRs in each detector:</span>

<span class="sd">    &gt;&gt;&gt; x = (model.det_optimal_snrsq(&#39;H1&#39;) +</span>
<span class="sd">    ...      model.det_optimal_snrsq(&#39;L1&#39;))**0.5</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;{:.2f}&#39;.format(x))</span>
<span class="sd">    23.77</span>

<span class="sd">    Toggle on the normalization constant:</span>

<span class="sd">    &gt;&gt;&gt; model.normalize = True</span>
<span class="sd">    &gt;&gt;&gt; model.loglikelihood</span>
<span class="sd">    835397.8757405131</span>

<span class="sd">    Using the same model, evaluate the log likelihood ratio at several points</span>
<span class="sd">    in time and check that the max is at tsig:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; times = numpy.linspace(tsig-1, tsig+1, num=101)</span>
<span class="sd">    &gt;&gt;&gt; loglrs = numpy.zeros(len(times))</span>
<span class="sd">    &gt;&gt;&gt; for (ii, t) in enumerate(times):</span>
<span class="sd">    ...     model.update(tc=t)</span>
<span class="sd">    ...     loglrs[ii] = model.loglr</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;tsig: {:.2f}, time of max loglr: {:.2f}&#39;.format(</span>
<span class="sd">    ...     tsig, times[loglrs.argmax()]))</span>
<span class="sd">    tsig: 3.10, time of max loglr: 3.10</span>

<span class="sd">    Create a prior and use it (see distributions module for more details):</span>

<span class="sd">    &gt;&gt;&gt; from pycbc import distributions</span>
<span class="sd">    &gt;&gt;&gt; uniform_prior = distributions.Uniform(tc=(tsig-0.2,tsig+0.2))</span>
<span class="sd">    &gt;&gt;&gt; prior = distributions.JointDistribution(variable_params, uniform_prior)</span>
<span class="sd">    &gt;&gt;&gt; model = GaussianNoise(variable_params,</span>
<span class="sd">    ...     signal, low_frequency_cutoff, psds=psds, prior=prior,</span>
<span class="sd">    ...     static_params=static_params)</span>
<span class="sd">    &gt;&gt;&gt; model.update(tc=tsig)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;{:.2f}&#39;.format(model.logplr))</span>
<span class="sd">    283.35</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;,\n&#39;.join([&#39;{}: {:.2f}&#39;.format(s, v)</span>
<span class="sd">    ...                   for (s, v) in sorted(model.current_stats.items())]))</span>
<span class="sd">    H1_cplx_loglr: 177.76+0.00j,</span>
<span class="sd">    H1_optimal_snrsq: 355.52,</span>
<span class="sd">    L1_cplx_loglr: 104.67+0.00j,</span>
<span class="sd">    L1_optimal_snrsq: 209.35,</span>
<span class="sd">    logjacobian: 0.00,</span>
<span class="sd">    loglikelihood: 0.00,</span>
<span class="sd">    loglr: 282.43,</span>
<span class="sd">    logprior: 0.92</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gaussian_noise&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">psds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">static_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">det_frame_waveform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># set up the boiler-plate attributes</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GaussianNoise</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">variable_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">psds</span><span class="o">=</span><span class="n">psds</span><span class="p">,</span>
            <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">static_params</span><span class="o">=</span><span class="n">static_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Determine if all data have the same sampling rate and segment length</span>
        <span class="k">if</span> <span class="n">det_frame_waveform</span><span class="p">:</span>
            <span class="n">generator_class</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">FDomainDirectDetFrameGenerator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generator_class</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">FDomainDetFrameGenerator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_ifodata_same_rate_length</span><span class="p">:</span>
            <span class="c1"># create a waveform generator for all ifos</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span> <span class="o">=</span> <span class="n">create_waveform_generator</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">generator_class</span><span class="o">=</span><span class="n">generator_class</span><span class="p">,</span>
                <span class="n">waveform_transforms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform_transforms</span><span class="p">,</span>
                <span class="n">recalibration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recalibration</span><span class="p">,</span>
                <span class="n">gates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">static_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># create a waveform generator for each ifo respestively</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_waveform_generator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_params</span><span class="p">,</span> <span class="p">{</span><span class="n">det</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">det</span><span class="p">]},</span>
                    <span class="n">generator_class</span><span class="o">=</span><span class="n">generator_class</span><span class="p">,</span>
                    <span class="n">waveform_transforms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform_transforms</span><span class="p">,</span>
                    <span class="n">recalibration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recalibration</span><span class="p">,</span>
                    <span class="n">gates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">static_params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_extra_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds ``loglr``, plus ``cplx_loglr`` and ``optimal_snrsq`` in each</span>
<span class="sd">        detector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;loglr&#39;</span><span class="p">]</span> <span class="o">+</span> \
               <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_cplx_loglr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span> <span class="o">+</span> \
               <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_optimal_snrsq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_nowaveform_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience function to set loglr values if no waveform generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;loglikelihood&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_cplx_loglr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">),</span>
                    <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="c1"># snr can&#39;t be &lt; 0 by definition, so return 0</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_optimal_snrsq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multi_signal_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The list of classes that this model supports in a multi-signal</span>
<span class="sd">        likelihood</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

<div class="viewcode-block" id="GaussianNoise.multi_loglikelihood">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.GaussianNoise.multi_loglikelihood">[docs]</a>
    <span class="nd">@catch_waveform_error</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multi_loglikelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate a multi-model (signal) likelihood</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate the waveforms for each submodel</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]:</span>
            <span class="n">wfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">())</span>

        <span class="c1"># combine into a single waveform</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">mlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">det</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wfs</span><span class="p">])</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">mlen</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wfs</span><span class="p">]</span>
            <span class="n">combine</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wfs</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="o">=</span> <span class="n">combine</span>
        <span class="n">loglr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loglr</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">loglr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lognl</span></div>


<div class="viewcode-block" id="GaussianNoise.get_waveforms">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.GaussianNoise.get_waveforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The waveforms generated using the current parameters.</span>

<span class="sd">        If the waveforms haven&#39;t been generated yet, they will be generated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict :</span>
<span class="sd">            Dictionary of detector names -&gt; FrequencySeries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_ifodata_same_rate_length</span><span class="p">:</span>
                <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wfs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="n">wfs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span><span class="p">[</span><span class="n">det</span><span class="p">]</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span> <span class="o">=</span> <span class="n">wfs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_wfs</span></div>


    <span class="nd">@catch_waveform_error</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_loglr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the log likelihood ratio,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \log \mathcal{L}(\Theta) = \sum_i</span>
<span class="sd">                \left&lt;h_i(\Theta)|d_i\right&gt; -</span>
<span class="sd">                \frac{1}{2}\left&lt;h_i(\Theta)|h_i(\Theta)\right&gt;,</span>

<span class="sd">        at the current parameter values :math:`\Theta`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the log likelihood ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">()</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">det</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">wfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># the kmax of the waveforms may be different than internal kmax</span>
            <span class="n">kmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmax</span><span class="p">[</span><span class="n">det</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">kmax</span><span class="p">:</span>
                <span class="c1"># if the waveform terminates before the filtering low frequency</span>
                <span class="c1"># cutoff, then the loglr is just 0 for this detector</span>
                <span class="n">cplx_hd</span> <span class="o">=</span> <span class="mi">0</span><span class="n">j</span>
                <span class="n">hh</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">],</span> <span class="n">kmax</span><span class="p">)</span>
                <span class="c1"># whiten the waveform</span>
                <span class="n">h</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_kmin</span><span class="p">[</span><span class="n">det</span><span class="p">]:</span><span class="n">kmax</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">[</span><span class="n">det</span><span class="p">][</span><span class="n">slc</span><span class="p">]</span>

                <span class="c1"># the inner products</span>
                <span class="n">cplx_hd</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_whitened_data</span><span class="p">[</span><span class="n">det</span><span class="p">][</span><span class="n">slc</span><span class="p">])</span>  <span class="c1"># &lt;h, d&gt;</span>
                <span class="n">hh</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">slc</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># &lt; h, h&gt;</span>
            <span class="n">cplx_loglr</span> <span class="o">=</span> <span class="n">cplx_hd</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">hh</span>
            <span class="c1"># store</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_optimal_snrsq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">),</span> <span class="n">hh</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_cplx_loglr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">),</span>
                    <span class="n">cplx_loglr</span><span class="p">)</span>
            <span class="n">lr</span> <span class="o">+=</span> <span class="n">cplx_loglr</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># also store the loglikelihood, to ensure it is populated in the</span>
        <span class="c1"># current stats even if loglikelihood is never called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="o">.</span><span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">lr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lognl</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianNoise.det_cplx_loglr">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.GaussianNoise.det_cplx_loglr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">det_cplx_loglr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the complex log likelihood ratio in the given detector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        det : str</span>
<span class="sd">            The name of the detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex float :</span>
<span class="sd">            The complex log likelihood ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># try to get it from current stats</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_cplx_loglr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># hasn&#39;t been calculated yet; call loglr to do so</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loglr</span><span class="p">()</span>
            <span class="c1"># now try returning again</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_cplx_loglr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">))</span></div>


<div class="viewcode-block" id="GaussianNoise.det_optimal_snrsq">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.GaussianNoise.det_optimal_snrsq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">det_optimal_snrsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the opitmal SNR squared in the given detector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        det : str</span>
<span class="sd">            The name of the detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float :</span>
<span class="sd">            The opimtal SNR squared.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># try to get it from current stats</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_optimal_snrsq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># hasn&#39;t been calculated yet; call loglr to do so</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loglr</span><span class="p">()</span>
            <span class="c1"># now try returning again</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_stats</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_optimal_snrsq&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det</span><span class="p">))</span></div>
</div>



<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                               Support functions</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>


<div class="viewcode-block" id="get_values_from_injection">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.get_values_from_injection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_values_from_injection</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">injection_file</span><span class="p">,</span> <span class="n">update_cp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replaces all FROM_INJECTION values in a config file with the</span>
<span class="sd">    corresponding value from the injection.</span>

<span class="sd">    This looks for any options that start with ``FROM_INJECTION[:ARG]`` in</span>
<span class="sd">    a config file. It then replaces that value with the corresponding value</span>
<span class="sd">    from the injection file. An argument may be optionally provided, in which</span>
<span class="sd">    case the argument will be retrieved from the injection file. Functions of</span>
<span class="sd">    parameters in the injection file may be used; the syntax and functions</span>
<span class="sd">    available is the same as the ``--parameters`` argument in executables</span>
<span class="sd">    such as ``pycbc_inference_extract_samples``. If no ``ARG`` is provided,</span>
<span class="sd">    then the option name will try to be retrieved from the injection.</span>

<span class="sd">    For example,</span>

<span class="sd">    .. code-block:: ini</span>

<span class="sd">       mass1 = FROM_INJECTION</span>

<span class="sd">    will cause ``mass1`` to be retrieved from the injection file, while:</span>

<span class="sd">    .. code-block:: ini</span>

<span class="sd">       mass1 = FROM_INJECTION:&#39;primary_mass(mass1, mass2)&#39;</span>

<span class="sd">    will cause the larger of mass1 and mass2 to be retrieved from the injection</span>
<span class="sd">    file. Note that if spaces are in the argument, it must be encased in</span>
<span class="sd">    single quotes.</span>

<span class="sd">    The injection file may contain only one injection. Otherwise, a ValueError</span>
<span class="sd">    will be raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cp : ConfigParser</span>
<span class="sd">        The config file within which to replace values.</span>
<span class="sd">    injection_file : str or None</span>
<span class="sd">        The injection file to get values from. A ValueError will be raised</span>
<span class="sd">        if there are any ``FROM_INJECTION`` values in the config file, and</span>
<span class="sd">        injection file is None, or if there is more than one injection.</span>
<span class="sd">    update_cp : bool, optional</span>
<span class="sd">        Update the config parser with the replaced parameters. If False,</span>
<span class="sd">        will just retrieve the parameter values to update, without updating</span>
<span class="sd">        the config file. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        The parameters that were replaced, as a tuple of section name, option,</span>
<span class="sd">        value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lookfor</span> <span class="o">=</span> <span class="s1">&#39;FROM_INJECTION&#39;</span>
    <span class="c1"># figure out what parameters need to be set</span>
    <span class="n">replace_params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">sections</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">sec</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
            <span class="n">splitvals</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">replace_this</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splitvals</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">subval</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">lookfor</span><span class="p">):</span>
                    <span class="c1"># determine what we should retrieve from the injection</span>
                    <span class="n">subval</span> <span class="o">=</span> <span class="n">subval</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">subval</span> <span class="o">=</span> <span class="n">opt</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">subval</span> <span class="o">=</span> <span class="n">subval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">replace_this</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ii</span><span class="p">,</span> <span class="n">subval</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">replace_this</span><span class="p">:</span>
                <span class="n">replace_params</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">splitvals</span><span class="p">,</span> <span class="n">replace_this</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">replace_params</span><span class="p">:</span>
        <span class="c1"># check that we have an injection file</span>
        <span class="k">if</span> <span class="n">injection_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or values are set to </span><span class="si">{}</span><span class="s2">, but no injection &quot;</span>
                             <span class="s2">&quot;file provided&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lookfor</span><span class="p">))</span>
        <span class="c1"># load the injection file</span>
        <span class="n">inj</span> <span class="o">=</span> <span class="n">InjectionSet</span><span class="p">(</span><span class="n">injection_file</span><span class="p">)</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">FieldArray</span><span class="p">)</span>
        <span class="c1"># make sure there&#39;s only one injection provided</span>
        <span class="k">if</span> <span class="n">inj</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more values are set to </span><span class="si">{}</span><span class="s2">, but more than &quot;</span>
                             <span class="s2">&quot;one injection exists in the injection file.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lookfor</span><span class="p">))</span>
    <span class="c1"># get the injection values to replace</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">splitvals</span><span class="p">,</span> <span class="n">replace_this</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">replace_params</span><span class="p">):</span>
        <span class="c1"># replace the value in the shlex-splitted string with the value</span>
        <span class="c1"># from the injection</span>
        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">replace_this</span><span class="p">:</span>
            <span class="n">splitvals</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">inj</span><span class="p">[</span><span class="n">arg</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># now rejoin the string...</span>
        <span class="c1"># shlex will strip quotes around arguments; this can be problematic</span>
        <span class="c1"># when rejoining if the the argument had a space in it. In python 3.8</span>
        <span class="c1"># there is a shlex.join function which properly rejoins things taking</span>
        <span class="c1"># that into account. Since we need to continue to support earlier</span>
        <span class="c1"># versions of python, the following kludge tries to account for that.</span>
        <span class="c1"># If/when we drop support for all earlier versions of python, then the</span>
        <span class="c1"># following can just be replaced by:</span>
        <span class="c1"># replace_val = shlex.join(splitvals)</span>
        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splitvals</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
                <span class="n">splitvals</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="n">replace_val</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">splitvals</span><span class="p">)</span>
        <span class="n">replace_params</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">)</span>
    <span class="c1"># replace in the config file</span>
    <span class="k">if</span> <span class="n">update_cp</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">replace_params</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">replace_params</span></div>



<div class="viewcode-block" id="create_waveform_generator">
<a class="viewcode-back" href="../../../../pycbc.inference.models.html#pycbc.inference.models.gaussian_noise.create_waveform_generator">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_waveform_generator</span><span class="p">(</span>
        <span class="n">variable_params</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">waveform_transforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">recalibration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">generator_class</span><span class="o">=</span><span class="n">generator</span><span class="o">.</span><span class="n">FDomainDetFrameGenerator</span><span class="p">,</span>
        <span class="o">**</span><span class="n">static_params</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a waveform generator for use with a model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable_params : list of str</span>
<span class="sd">        The names of the parameters varied.</span>
<span class="sd">    data : dict</span>
<span class="sd">        Dictionary mapping detector names to either a</span>
<span class="sd">        :py:class:`&lt;pycbc.types.TimeSeries TimeSeries&gt;` or</span>
<span class="sd">        :py:class:`&lt;pycbc.types.FrequencySeries FrequencySeries&gt;`.</span>
<span class="sd">    waveform_transforms : list, optional</span>
<span class="sd">        The list of transforms applied to convert variable parameters into</span>
<span class="sd">        parameters that will be understood by the waveform generator.</span>
<span class="sd">    recalibration : dict, optional</span>
<span class="sd">        Dictionary mapping detector names to</span>
<span class="sd">        :py:class:`&lt;pycbc.calibration.Recalibrate&gt;` instances for</span>
<span class="sd">        recalibrating data.</span>
<span class="sd">    gates : dict of tuples, optional</span>
<span class="sd">        Dictionary of detectors -&gt; tuples of specifying gate times. The</span>
<span class="sd">        sort of thing returned by :py:func:`pycbc.gate.gates_from_cli`.</span>
<span class="sd">    generator_class : detector-frame fdomain generator, optional</span>
<span class="sd">        Class to use for generating waveforms. Default is</span>
<span class="sd">        :py:class:`waveform.generator.FDomainDetFrameGenerator`.</span>
<span class="sd">    \**static_params :</span>
<span class="sd">        All other keyword arguments are passed as static parameters to the</span>
<span class="sd">        waveform generator.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pycbc.waveform.FDomainDetFrameGenerator</span>
<span class="sd">        A waveform generator for frequency domain generation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the waveform generator will get the variable_params + the output</span>
    <span class="c1"># of the waveform transforms, so we&#39;ll add them to the list of</span>
    <span class="c1"># parameters</span>
    <span class="k">if</span> <span class="n">waveform_transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wfoutputs</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">outputs</span>
                                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">waveform_transforms</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wfoutputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">variable_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">variable_params</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">wfoutputs</span><span class="p">)</span>
    <span class="c1"># figure out what generator to use based on the approximant</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">approximant</span> <span class="o">=</span> <span class="n">static_params</span><span class="p">[</span><span class="s1">&#39;approximant&#39;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no approximant provided in the static args&quot;</span><span class="p">)</span>

    <span class="n">dm</span> <span class="o">=</span> <span class="n">static_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;preferred_domain&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">gen_function</span> <span class="o">=</span> <span class="n">generator_class</span><span class="o">.</span><span class="n">select_rframe_generator</span><span class="p">(</span><span class="n">approximant</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
    <span class="c1"># get data parameters; we&#39;ll just use one of the data to get the</span>
    <span class="c1"># values, then check that all the others are the same</span>
    <span class="n">delta_f</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">delta_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta_f</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">delta_f</span>
            <span class="n">delta_t</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">delta_t</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">start_time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">==</span> <span class="n">delta_f</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">delta_t</span> <span class="o">==</span> <span class="n">delta_t</span><span class="p">,</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="n">start_time</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data must all have the same delta_t, &quot;</span>
                                 <span class="s2">&quot;delta_f, and start_time&quot;</span><span class="p">)</span>
    <span class="n">waveform_generator</span> <span class="o">=</span> <span class="n">generator_class</span><span class="p">(</span>
        <span class="n">gen_function</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">variable_args</span><span class="o">=</span><span class="n">variable_params</span><span class="p">,</span> <span class="n">detectors</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="n">delta_f</span><span class="o">=</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">,</span>
        <span class="n">recalib</span><span class="o">=</span><span class="n">recalibration</span><span class="p">,</span> <span class="n">gates</span><span class="o">=</span><span class="n">gates</span><span class="p">,</span>
        <span class="o">**</span><span class="n">static_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">waveform_generator</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, 2016, 2017, Alexander Nitz, Ian Harry, Christopher M. Biwer, Duncan A.  Brown, Josh Willis, and Tito Dal Canton.
      <span class="lastupdated">Last updated on Feb 06, 2026.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>