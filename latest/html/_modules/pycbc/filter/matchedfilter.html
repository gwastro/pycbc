

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pycbc.filter.matchedfilter &mdash; PyCBC 2.10.dev1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=751f435e"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/typed.min.js?v=edb71f0b"></script>
      <script src="../../../_static/terminal.css?v=d691274a"></script>
      <script src="../../../_static/theme_overrides.css?v=e4e1d026"></script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(193,193,255,1) 85%)" >

          
          
          <a href="../../../index.html">
            
              <img src="https://raw.githubusercontent.com/gwastro/pycbc-logo/master/pycbc_logo_name.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credit.html">Use of PyCBC in Scientific Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Library Examples and Interactive Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../searches.html">PyCBC searches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../inference.html">PyCBC inference documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.inference</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apps.html">Applications and Workflows</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Dev Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extend.html">Extending PyCBC with external plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devs.html">Documentation for Developers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(193,193,255,1) 85%)" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyCBC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../pycbc.html">pycbc</a></li>
      <li class="breadcrumb-item active">pycbc.filter.matchedfilter</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pycbc.filter.matchedfilter</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2012  Alex Nitz</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU General Public License as published by the</span>
<span class="c1"># Free Software Foundation; either version 3 of the License, or (at your</span>
<span class="c1"># option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but</span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c1"># Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                                   Preamble</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This modules provides functions for matched filtering along with associated</span>
<span class="sd">utilities.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">FrequencySeries</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">Array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">complex_same_precision_as</span><span class="p">,</span> <span class="n">real_same_precision_as</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">IFFT</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pycbc.scheme</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc</span><span class="w"> </span><span class="kn">import</span> <span class="n">events</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.events</span><span class="w"> </span><span class="kn">import</span> <span class="n">ranking</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pycbc</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pycbc.filter.matchedfilter&#39;</span><span class="p">)</span>

<span class="n">BACKEND_PREFIX</span><span class="o">=</span><span class="s2">&quot;pycbc.filter.matchedfilter_&quot;</span>

<div class="viewcode-block" id="correlate">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.correlate">[docs]</a>
<span class="nd">@pycbc</span><span class="o">.</span><span class="n">scheme</span><span class="o">.</span><span class="n">schemed</span><span class="p">(</span><span class="n">BACKEND_PREFIX</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;This function is a stub that should be overridden using the &quot;</span>
    <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;scheme. You shouldn&#39;t be seeing this error!&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">BatchCorrelator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create a batch correlation engine</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Correlate x and y, store in z. Arrays need not be equal length, but</span>
<span class="sd">        must be at least size long and of the same dtype. No error checking</span>
<span class="sd">        will be performed, so be careful. All dtypes must be complex64.</span>
<span class="sd">        Note, must be created within the processing context that it will be used in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_vectors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

        <span class="c1"># keep reference to arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zs</span> <span class="o">=</span> <span class="n">zs</span>

        <span class="c1"># Store each pointer as in integer array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">ptr</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="nd">@pycbc</span><span class="o">.</span><span class="n">scheme</span><span class="o">.</span><span class="n">schemed</span><span class="p">(</span><span class="n">BACKEND_PREFIX</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_correlate_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">execute</span> <span class="o">=</span> <span class="n">batch_correlate_execute</span>


<span class="nd">@pycbc</span><span class="o">.</span><span class="n">scheme</span><span class="o">.</span><span class="n">schemed</span><span class="p">(</span><span class="n">BACKEND_PREFIX</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_correlate_factory</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;This class is a stub that should be overridden using the &quot;</span>
    <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;scheme. You shouldn&#39;t be seeing this error!&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Correlator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create a correlator engine</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    x : complex64</span>
<span class="sd">      Input pycbc.types.Array (or subclass); it will be conjugated</span>
<span class="sd">    y : complex64</span>
<span class="sd">      Input pycbc.types.Array (or subclass); it will not be conjugated</span>
<span class="sd">    z : complex64</span>
<span class="sd">      Output pycbc.types.Array (or subclass).</span>
<span class="sd">      It will contain conj(x) * y, element by element</span>

<span class="sd">    The addresses in memory of the data of all three parameter vectors</span>
<span class="sd">    must be the same modulo pycbc.PYCBC_ALIGNMENT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">real_cls</span> <span class="o">=</span> <span class="n">_correlate_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">real_cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># pylint:disable=not-callable</span>


<span class="c1"># The class below should serve as the parent for all schemed classes.</span>
<span class="c1"># The intention is that this class serves simply as the location for</span>
<span class="c1"># all documentation of the class and its methods, though that is not</span>
<span class="c1"># yet implemented.  Perhaps something along the lines of:</span>
<span class="c1">#</span>
<span class="c1">#    http://stackoverflow.com/questions/2025562/inherit-docstrings-in-python-class-inheritance</span>
<span class="c1">#</span>
<span class="c1"># will work? Is there a better way?</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_BaseCorrelator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the correlation of the vectors specified at object</span>
<span class="sd">        instantiation, writing into the output vector given when the</span>
<span class="sd">        object was instantiated. The intention is that this method</span>
<span class="sd">        should be called many times, with the contents of those vectors</span>
<span class="sd">        changing between invocations, but not their locations in memory</span>
<span class="sd">        or length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<div class="viewcode-block" id="MatchedFilterControl">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterControl">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MatchedFilterControl</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span>
                 <span class="n">delta_f</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">segment_list</span><span class="p">,</span> <span class="n">template_output</span><span class="p">,</span> <span class="n">use_cluster</span><span class="p">,</span>
                 <span class="n">downsample_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upsample_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upsample_method</span><span class="o">=</span><span class="s1">&#39;pruned_fft&#39;</span><span class="p">,</span>
                 <span class="n">gpu_callback_method</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cluster_function</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create a matched filter engine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">            The frequency to begin the filter calculation. If None, begin at the</span>
<span class="sd">            first frequency after DC.</span>
<span class="sd">        high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">            The frequency to stop the filter calculation. If None, continue to the</span>
<span class="sd">            the nyquist frequency.</span>
<span class="sd">        snr_threshold : float</span>
<span class="sd">            The minimum snr to return when filtering</span>
<span class="sd">        segment_list : list</span>
<span class="sd">            List of FrequencySeries that are the Fourier-transformed data segments</span>
<span class="sd">        template_output : complex64</span>
<span class="sd">            Array of memory given as the &#39;out&#39; parameter to waveform.FilterBank</span>
<span class="sd">        use_cluster : boolean</span>
<span class="sd">            If true, cluster triggers above threshold using a window; otherwise,</span>
<span class="sd">            only apply a threshold.</span>
<span class="sd">        downsample_factor : {1, int}, optional</span>
<span class="sd">            The factor by which to reduce the sample rate when doing a hierarchical</span>
<span class="sd">            matched filter</span>
<span class="sd">        upsample_threshold : {1, float}, optional</span>
<span class="sd">            The fraction of the snr_threshold to trigger on the subsampled filter.</span>
<span class="sd">        upsample_method : {pruned_fft, str}</span>
<span class="sd">            The method to upsample or interpolate the reduced rate filter.</span>
<span class="sd">        cluster_function : {symmetric, str}, optional</span>
<span class="sd">            Which method is used to cluster triggers over time. If &#39;findchirp&#39;, a</span>
<span class="sd">            sliding forward window; if &#39;symmetric&#39;, each window&#39;s peak is compared</span>
<span class="sd">            to the windows before and after it, and only kept as a trigger if larger</span>
<span class="sd">            than both.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assuming analysis time is constant across templates and segments, also</span>
        <span class="c1"># delta_f is constant across segments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span> <span class="o">=</span> <span class="n">tlen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">=</span> <span class="n">delta_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">=</span> <span class="n">snr_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">low_frequency_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span> <span class="o">=</span> <span class="n">high_frequency_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu_callback_method</span> <span class="o">=</span> <span class="n">gpu_callback_method</span>
        <span class="k">if</span> <span class="n">cluster_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="s1">&#39;findchirp&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MatchedFilter: &#39;cluster_function&#39; must be either &#39;symmetric&#39; or &#39;findchirp&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_function</span> <span class="o">=</span> <span class="n">cluster_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">segment_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">htilde</span> <span class="o">=</span> <span class="n">template_output</span>

        <span class="k">if</span> <span class="n">downsample_factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_cluster</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cluster_function</span> <span class="o">==</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_filter_and_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_matched_filter_and_cluster_symm</span>
                <span class="c1"># setup the threasholding/clustering operations for each segment</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">threshold_and_clusterers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                    <span class="n">thresh</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">ThresholdCluster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">analyze</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">threshold_and_clusterers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thresh</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">use_cluster</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cluster_function</span> <span class="o">==</span> <span class="s1">&#39;findchirp&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_filter_and_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_matched_filter_and_cluster_fc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_filter_and_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_matched_filter_thresh_only</span>

            <span class="c1"># Assuming analysis time is constant across templates and segments, also</span>
            <span class="c1"># delta_f is constant across segments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">)</span>

            <span class="c1"># Set up the correlation operations for each analysis segment</span>
            <span class="n">corr_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlators</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">Correlator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">htilde</span><span class="p">[</span><span class="n">corr_slice</span><span class="p">],</span>
                                  <span class="n">seg</span><span class="p">[</span><span class="n">corr_slice</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">[</span><span class="n">corr_slice</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correlators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>

            <span class="c1"># setup up the ifft we will do</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span> <span class="o">=</span> <span class="n">IFFT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">downsample_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_filter_and_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchical_matched_filter_and_cluster</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span> <span class="o">=</span> <span class="n">downsample_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upsample_method</span> <span class="o">=</span> <span class="n">upsample_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upsample_threshold</span> <span class="o">=</span> <span class="n">upsample_threshold</span>

            <span class="n">N_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span>
            <span class="n">N_red</span> <span class="o">=</span> <span class="n">N_full</span> <span class="o">/</span> <span class="n">downsample_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kmin_full</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">N_full</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">kmin_red</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">N_red</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span> <span class="o">&lt;</span> <span class="n">N_red</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span> <span class="o">=</span> <span class="n">N_red</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N_red</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_full</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">delta_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N_red</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter_vec</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N_full</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid downsample factor&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MatchedFilterControl.full_matched_filter_and_cluster_symm">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_symm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_matched_filter_and_cluster_symm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segnum</span><span class="p">,</span> <span class="n">template_norm</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the complex snr timeseries, normalization of the complex snr,</span>
<span class="sd">        the correlation vector frequency series, the list of indices of the</span>
<span class="sd">        triggers, and the snr values at the trigger locations. Returns empty</span>
<span class="sd">        lists for these for points that are not above the threshold.</span>

<span class="sd">        Calculated the matched filter, threshold, and cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segnum : int</span>
<span class="sd">            Index into the list of segments at MatchedFilterControl construction</span>
<span class="sd">            against which to filter.</span>
<span class="sd">        template_norm : float</span>
<span class="sd">            The htilde, template normalization factor.</span>
<span class="sd">        window : int</span>
<span class="sd">            Size of the window over which to cluster triggers, in samples</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : TimeSeries</span>
<span class="sd">            A time series containing the complex snr.</span>
<span class="sd">        norm : float</span>
<span class="sd">            The normalization of the complex snr.</span>
<span class="sd">        correlation: FrequencySeries</span>
<span class="sd">            A frequency series containing the correlation vector.</span>
<span class="sd">        idx : Array</span>
<span class="sd">            List of indices of the triggers.</span>
<span class="sd">        snrv : Array</span>
<span class="sd">            The snr values at the trigger locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">template_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlators</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">correlate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
        <span class="n">snrv</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_and_clusterers</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">threshold_and_cluster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points above threshold&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">,</span> <span class="n">delta_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">snr</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span></div>


<div class="viewcode-block" id="MatchedFilterControl.full_matched_filter_and_cluster_fc">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_fc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_matched_filter_and_cluster_fc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segnum</span><span class="p">,</span> <span class="n">template_norm</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the complex snr timeseries, normalization of the complex snr,</span>
<span class="sd">        the correlation vector frequency series, the list of indices of the</span>
<span class="sd">        triggers, and the snr values at the trigger locations. Returns empty</span>
<span class="sd">        lists for these for points that are not above the threshold.</span>

<span class="sd">        Calculated the matched filter, threshold, and cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segnum : int</span>
<span class="sd">            Index into the list of segments at MatchedFilterControl construction</span>
<span class="sd">            against which to filter.</span>
<span class="sd">        template_norm : float</span>
<span class="sd">            The htilde, template normalization factor.</span>
<span class="sd">        window : int</span>
<span class="sd">            Size of the window over which to cluster triggers, in samples</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : TimeSeries</span>
<span class="sd">            A time series containing the complex snr.</span>
<span class="sd">        norm : float</span>
<span class="sd">            The normalization of the complex snr.</span>
<span class="sd">        correlation: FrequencySeries</span>
<span class="sd">            A frequency series containing the correlation vector.</span>
<span class="sd">        idx : Array</span>
<span class="sd">            List of indices of the triggers.</span>
<span class="sd">        snrv : Array</span>
<span class="sd">            The snr values at the trigger locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">template_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlators</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">correlate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">analyze</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">cluster_reduce</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points above threshold&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">,</span> <span class="n">delta_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">snr</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span></div>


<div class="viewcode-block" id="MatchedFilterControl.full_matched_filter_thresh_only">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_thresh_only">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_matched_filter_thresh_only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segnum</span><span class="p">,</span> <span class="n">template_norm</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the complex snr timeseries, normalization of the complex snr,</span>
<span class="sd">        the correlation vector frequency series, the list of indices of the</span>
<span class="sd">        triggers, and the snr values at the trigger locations. Returns empty</span>
<span class="sd">        lists for these for points that are not above the threshold.</span>

<span class="sd">        Calculated the matched filter, threshold, and cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segnum : int</span>
<span class="sd">            Index into the list of segments at MatchedFilterControl construction</span>
<span class="sd">            against which to filter.</span>
<span class="sd">        template_norm : float</span>
<span class="sd">            The htilde, template normalization factor.</span>
<span class="sd">        window : int</span>
<span class="sd">            Size of the window over which to cluster triggers, in samples.</span>
<span class="sd">            This is IGNORED by this function, and provided only for API compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : TimeSeries</span>
<span class="sd">            A time series containing the complex snr.</span>
<span class="sd">        norm : float</span>
<span class="sd">            The normalization of the complex snr.</span>
<span class="sd">        correlation: FrequencySeries</span>
<span class="sd">            A frequency series containing the correlation vector.</span>
<span class="sd">        idx : Array</span>
<span class="sd">            List of indices of the triggers.</span>
<span class="sd">        snrv : Array</span>
<span class="sd">            The snr values at the trigger locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">template_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlators</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">correlate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_only</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span><span class="o">.</span><span class="n">analyze</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points above threshold&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">,</span> <span class="n">delta_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">snr</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span></div>


<div class="viewcode-block" id="MatchedFilterControl.hierarchical_matched_filter_and_cluster">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterControl.hierarchical_matched_filter_and_cluster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hierarchical_matched_filter_and_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segnum</span><span class="p">,</span> <span class="n">template_norm</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the complex snr timeseries, normalization of the complex snr,</span>
<span class="sd">        the correlation vector frequency series, the list of indices of the</span>
<span class="sd">        triggers, and the snr values at the trigger locations. Returns empty</span>
<span class="sd">        lists for these for points that are not above the threshold.</span>

<span class="sd">        Calculated the matched filter, threshold, and cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segnum : int</span>
<span class="sd">            Index into the list of segments at MatchedFilterControl construction</span>
<span class="sd">        template_norm : float</span>
<span class="sd">            The htilde, template normalization factor.</span>
<span class="sd">        window : int</span>
<span class="sd">            Size of the window over which to cluster triggers, in samples</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : TimeSeries</span>
<span class="sd">            A time series containing the complex snr at the reduced sample rate.</span>
<span class="sd">        norm : float</span>
<span class="sd">            The normalization of the complex snr.</span>
<span class="sd">        correlation: FrequencySeries</span>
<span class="sd">            A frequency series containing the correlation vector.</span>
<span class="sd">        idx : Array</span>
<span class="sd">            List of indices of the triggers.</span>
<span class="sd">        snrv : Array</span>
<span class="sd">            The snr values at the trigger locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.fft.fftw_pruned</span><span class="w"> </span><span class="kn">import</span> <span class="n">pruned_c2cifft</span><span class="p">,</span> <span class="n">fft_transpose</span>
        <span class="n">htilde</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">htilde</span>
        <span class="n">stilde</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">segnum</span><span class="p">]</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">template_norm</span><span class="p">)</span>

        <span class="n">correlate</span><span class="p">(</span><span class="n">htilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">],</span>
                  <span class="n">stilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">],</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">])</span>

        <span class="n">ifft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stilde</span><span class="p">,</span> <span class="s1">&#39;red_analyze&#39;</span><span class="p">):</span>
            <span class="n">stilde</span><span class="o">.</span><span class="n">red_analyze</span> <span class="o">=</span> \
                             <span class="nb">slice</span><span class="p">(</span><span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="o">.</span><span class="n">start</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span><span class="p">,</span>
                                   <span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="o">.</span><span class="n">stop</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span><span class="p">)</span>


        <span class="n">idx_red</span><span class="p">,</span> <span class="n">snrv_red</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">[</span><span class="n">stilde</span><span class="o">.</span><span class="n">red_analyze</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">/</span> <span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample_threshold</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_red</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">idx_red</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">cluster_reduce</span><span class="p">(</span><span class="n">idx_red</span><span class="p">,</span> <span class="n">snrv_red</span><span class="p">,</span> <span class="n">window</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points above threshold at reduced resolution&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">idx_red</span><span class="p">))</span>

        <span class="c1"># The fancy upsampling is here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample_method</span><span class="o">==</span><span class="s1">&#39;pruned_fft&#39;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_red</span> <span class="o">+</span> <span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="o">.</span><span class="n">start</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span><span class="p">)</span>\
                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">smear</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span><span class="p">)</span>

            <span class="c1"># cache transposed  versions of htilde and stilde</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">,</span> <span class="s1">&#39;transposed&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="s1">&#39;transposed&#39;</span><span class="p">):</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_full</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">]</span> <span class="o">=</span> <span class="n">htilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_full</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">]</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">fft_transpose</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stilde</span><span class="p">,</span> <span class="s1">&#39;transposed&#39;</span><span class="p">):</span>
                <span class="n">stilde</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">stilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_full</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">]</span> <span class="o">=</span> <span class="n">stilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmin_full</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">]</span>
                <span class="n">stilde</span><span class="o">.</span><span class="n">transposed</span> <span class="o">=</span> <span class="n">fft_transpose</span><span class="p">(</span><span class="n">stilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">)</span>

            <span class="n">correlate</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">transposed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="o">.</span><span class="n">transposed</span><span class="p">)</span>
            <span class="n">snrv</span> <span class="o">=</span> <span class="n">pruned_c2cifft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="o">.</span><span class="n">transposed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_vec</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pretransposed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="o">.</span><span class="n">start</span>
            <span class="n">idx2</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">Array</span><span class="p">(</span><span class="n">snrv</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">correlate</span><span class="p">(</span><span class="n">htilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">],</span>
                          <span class="n">stilde</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_red</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">kmax_full</span><span class="p">])</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">cluster_reduce</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="n">snrv</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points at full rate and clustering&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_mem_full</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid upsample method&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="compute_max_snr_over_sky_loc_stat">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.compute_max_snr_over_sky_loc_stat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_max_snr_over_sky_loc_stat</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                                      <span class="n">hpnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hcnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                      <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                      <span class="n">analyse_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matched filter maximised over polarization and orbital phase.</span>

<span class="sd">    This implements the statistic derived in 1603.02444. It is encouraged</span>
<span class="sd">    to read that work to understand the limitations and assumptions implicit</span>
<span class="sd">    in this statistic before using it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    hplus : TimeSeries</span>
<span class="sd">        This is the IFFTed complex SNR time series of (h+, data). If not</span>
<span class="sd">        normalized, supply the normalization factor so this can be done!</span>
<span class="sd">        It is recommended to normalize this before sending through this</span>
<span class="sd">        function</span>
<span class="sd">    hcross : TimeSeries</span>
<span class="sd">        This is the IFFTed complex SNR time series of (hx, data). If not</span>
<span class="sd">        normalized, supply the normalization factor so this can be done!</span>
<span class="sd">    hphccorr : float</span>
<span class="sd">        The real component of the overlap between the two polarizations</span>
<span class="sd">        Re[(h+, hx)]. Note that the imaginary component does not enter the</span>
<span class="sd">        detection statistic. This must be normalized and is sign-sensitive.</span>
<span class="sd">    thresh : float</span>
<span class="sd">        Used for optimization. If we do not care about the value of SNR</span>
<span class="sd">        values below thresh we can calculate a quick statistic that will</span>
<span class="sd">        always overestimate SNR and then only calculate the proper, more</span>
<span class="sd">        expensive, statistic at points where the quick SNR is above thresh.</span>
<span class="sd">    hpsigmasq : float</span>
<span class="sd">        The normalization factor (h+, h+). Default = None (=1, already</span>
<span class="sd">        normalized)</span>
<span class="sd">    hcsigmasq : float</span>
<span class="sd">        The normalization factor (hx, hx). Default = None (=1, already</span>
<span class="sd">        normalized)</span>
<span class="sd">    out : TimeSeries (optional, default=None)</span>
<span class="sd">        If given, use this array to store the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    det_stat : TimeSeries</span>
<span class="sd">        The SNR maximized over sky location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: Not much optimization has been done here! This may need to be</span>
    <span class="c1"># Cythonized.</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hplus</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;non_zero_locs&#39;</span><span class="p">):</span>
            <span class="c1"># Doing this every time is not a zero-cost operation</span>
            <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only set non zero locations to zero</span>
            <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="c1"># If threshold is given we can limit the points at which to compute the</span>
    <span class="c1"># full statistic</span>
    <span class="k">if</span> <span class="n">thresh</span><span class="p">:</span>
        <span class="c1"># This is the statistic that always overestimates the SNR...</span>
        <span class="c1"># It allows some unphysical freedom that the full statistic does not</span>
        <span class="n">idx_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_only</span><span class="p">(</span><span class="n">hplus</span><span class="p">[</span><span class="n">analyse_slice</span><span class="p">],</span>
                                                    <span class="n">thresh</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">hpnorm</span><span class="p">))</span>
        <span class="n">idx_c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_only</span><span class="p">(</span><span class="n">hcross</span><span class="p">[</span><span class="n">analyse_slice</span><span class="p">],</span>
                                                    <span class="n">thresh</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">hcnorm</span><span class="p">))</span>
        <span class="n">idx_p</span> <span class="o">=</span> <span class="n">idx_p</span> <span class="o">+</span> <span class="n">analyse_slice</span><span class="o">.</span><span class="n">start</span>
        <span class="n">idx_c</span> <span class="o">=</span> <span class="n">idx_c</span> <span class="o">+</span> <span class="n">analyse_slice</span><span class="o">.</span><span class="n">start</span>
        <span class="n">hp_red</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">*</span> <span class="n">hpnorm</span>
        <span class="n">hc_red</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">*</span> <span class="n">hcnorm</span>
        <span class="n">stat_p</span> <span class="o">=</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                     <span class="n">hc_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hc_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">locs_p</span> <span class="o">=</span> <span class="n">idx_p</span><span class="p">[</span><span class="n">stat_p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">thresh</span><span class="o">*</span><span class="n">thresh</span><span class="p">)]</span>
        <span class="n">hp_red</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">idx_c</span><span class="p">]</span> <span class="o">*</span> <span class="n">hpnorm</span>
        <span class="n">hc_red</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">idx_c</span><span class="p">]</span> <span class="o">*</span> <span class="n">hcnorm</span>
        <span class="n">stat_c</span> <span class="o">=</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                     <span class="n">hc_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hc_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">locs_c</span> <span class="o">=</span> <span class="n">idx_c</span><span class="p">[</span><span class="n">stat_c</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">thresh</span><span class="o">*</span><span class="n">thresh</span><span class="p">)]</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">locs_p</span><span class="p">,</span> <span class="n">locs_c</span><span class="p">)))</span>

        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span>

    <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span> <span class="o">*</span> <span class="n">hpnorm</span>
    <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span> <span class="o">*</span> <span class="n">hcnorm</span>


    <span class="c1"># Calculate and sanity check the denominator</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hphccorr</span><span class="o">*</span><span class="n">hphccorr</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hphccorr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap between hp and hc is given as </span><span class="si">%f</span><span class="s2">. &quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">hphccorr</span><span class="p">)</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;How can an overlap be bigger than 1?&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;There really is no way to raise this error!?! &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;If you&#39;re seeing this, it is bad.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This case, of hphccorr==1, makes the statistic degenerate</span>
        <span class="c1"># This case should not physically be possible luckily.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;You have supplied a real overlap between hp and hc of 1. &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Ian is reasonably certain this is physically impossible &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;so why are you seeing this?&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">hcross</span><span class="p">))</span>

    <span class="c1"># Now the stuff where comp. cost may be a problem</span>
    <span class="n">hplus_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span>
    <span class="n">hcross_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>
    <span class="n">rho_pluscross</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>

    <span class="n">sqroot</span> <span class="o">=</span> <span class="p">(</span><span class="n">hplus_magsq</span> <span class="o">-</span> <span class="n">hcross_magsq</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">sqroot</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">hphccorr</span> <span class="o">*</span> <span class="n">hplus_magsq</span> <span class="o">-</span> <span class="n">rho_pluscross</span><span class="p">)</span> <span class="o">*</span> \
                  <span class="p">(</span><span class="n">hphccorr</span> <span class="o">*</span> <span class="n">hcross_magsq</span> <span class="o">-</span> <span class="n">rho_pluscross</span><span class="p">)</span>
    <span class="c1"># Sometimes this can be less than 0 due to numeric imprecision, catch this.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqroot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sqroot</span><span class="p">))[</span><span class="n">sqroot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># This should not be *much* smaller than 0 due to numeric imprecision</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sqroot</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.0001</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Square root has become negative. Something wrong here!&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="n">sqroot</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sqroot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sqroot</span><span class="p">)</span>
    <span class="n">det_stat_sq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">hplus_magsq</span> <span class="o">+</span> <span class="n">hcross_magsq</span> <span class="o">-</span> \
                         <span class="mi">2</span> <span class="o">*</span> <span class="n">rho_pluscross</span><span class="o">*</span><span class="n">hphccorr</span> <span class="o">+</span> <span class="n">sqroot</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="n">det_stat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">det_stat_sq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">thresh</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_stat</span>
        <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">locs</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">det_stat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_u_val_for_sky_loc_stat">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.compute_u_val_for_sky_loc_stat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_u_val_for_sky_loc_stat</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                 <span class="n">hpnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hcnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The max-over-sky location detection statistic maximizes over a phase,</span>
<span class="sd">    an amplitude and the ratio of F+ and Fx, encoded in a variable called u.</span>
<span class="sd">    Here we return the value of u for the given indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">hpnorm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span> <span class="o">*</span> <span class="n">hpnorm</span>
    <span class="k">if</span> <span class="n">hcnorm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span> <span class="o">*</span> <span class="n">hcnorm</span>

    <span class="c1"># Sanity checking in func. above should already have identified any points</span>
    <span class="c1"># which are bad, and should be used to construct indices for input here</span>
    <span class="n">hplus_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span>
    <span class="n">hcross_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>
    <span class="n">rho_pluscross</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">hphccorr</span> <span class="o">*</span> <span class="n">hplus_magsq</span> <span class="o">-</span> <span class="n">rho_pluscross</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">hplus_magsq</span> <span class="o">-</span> <span class="n">hcross_magsq</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">rho_pluscross</span> <span class="o">-</span> <span class="n">hphccorr</span> <span class="o">*</span> <span class="n">hcross_magsq</span>

    <span class="n">sq_root</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
    <span class="n">sq_root</span> <span class="o">=</span> <span class="n">sq_root</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">sq_root</span> <span class="o">=</span> <span class="o">-</span><span class="n">sq_root</span>
    <span class="c1"># Catch the a-&gt;0 case</span>
    <span class="n">bad_lgc</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dbl_bad_lgc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dbl_bad_lgc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bad_lgc</span><span class="p">,</span> <span class="n">dbl_bad_lgc</span><span class="p">)</span>
    <span class="c1"># Initialize u</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sq_root</span> <span class="o">*</span> <span class="mf">0.</span>
    <span class="c1"># In this case u is completely degenerate, so set it to 1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">dbl_bad_lgc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="c1"># If a-&gt;0 avoid overflow by just setting to a large value</span>
    <span class="n">u</span><span class="p">[</span><span class="n">bad_lgc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dbl_bad_lgc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E17</span>
    <span class="c1"># Otherwise normal statistic</span>
    <span class="n">u</span><span class="p">[</span><span class="o">~</span><span class="n">bad_lgc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="o">~</span><span class="n">bad_lgc</span><span class="p">]</span> <span class="o">+</span> <span class="n">sq_root</span><span class="p">[</span><span class="o">~</span><span class="n">bad_lgc</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="o">~</span><span class="n">bad_lgc</span><span class="p">])</span>

    <span class="n">snr_cplx</span> <span class="o">=</span> <span class="n">hplus</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">hcross</span>
    <span class="n">coa_phase</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">snr_cplx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">coa_phase</span></div>


<div class="viewcode-block" id="compute_max_snr_over_sky_loc_stat_no_phase">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.compute_max_snr_over_sky_loc_stat_no_phase">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_max_snr_over_sky_loc_stat_no_phase</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                               <span class="n">hpnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hcnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                               <span class="n">analyse_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matched filter maximised over polarization phase.</span>

<span class="sd">    This implements the statistic derived in 1709.09181. It is encouraged</span>
<span class="sd">    to read that work to understand the limitations and assumptions implicit</span>
<span class="sd">    in this statistic before using it.</span>

<span class="sd">    In contrast to compute_max_snr_over_sky_loc_stat this function</span>
<span class="sd">    performs no maximization over orbital phase, treating that as an intrinsic</span>
<span class="sd">    parameter. In the case of aligned-spin 2,2-mode only waveforms, this</span>
<span class="sd">    collapses to the normal statistic (at twice the computational cost!)</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    hplus : TimeSeries</span>
<span class="sd">        This is the IFFTed complex SNR time series of (h+, data). If not</span>
<span class="sd">        normalized, supply the normalization factor so this can be done!</span>
<span class="sd">        It is recommended to normalize this before sending through this</span>
<span class="sd">        function</span>
<span class="sd">    hcross : TimeSeries</span>
<span class="sd">        This is the IFFTed complex SNR time series of (hx, data). If not</span>
<span class="sd">        normalized, supply the normalization factor so this can be done!</span>
<span class="sd">    hphccorr : float</span>
<span class="sd">        The real component of the overlap between the two polarizations</span>
<span class="sd">        Re[(h+, hx)]. Note that the imaginary component does not enter the</span>
<span class="sd">        detection statistic. This must be normalized and is sign-sensitive.</span>
<span class="sd">    thresh : float</span>
<span class="sd">        Used for optimization. If we do not care about the value of SNR</span>
<span class="sd">        values below thresh we can calculate a quick statistic that will</span>
<span class="sd">        always overestimate SNR and then only calculate the proper, more</span>
<span class="sd">        expensive, statistic at points where the quick SNR is above thresh.</span>
<span class="sd">    hpsigmasq : float</span>
<span class="sd">        The normalization factor (h+, h+). Default = None (=1, already</span>
<span class="sd">        normalized)</span>
<span class="sd">    hcsigmasq : float</span>
<span class="sd">        The normalization factor (hx, hx). Default = None (=1, already</span>
<span class="sd">        normalized)</span>
<span class="sd">    out : TimeSeries (optional, default=None)</span>
<span class="sd">        If given, use this array to store the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    det_stat : TimeSeries</span>
<span class="sd">        The SNR maximized over sky location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: Not much optimization has been done here! This may need to be</span>
    <span class="c1"># Cythonized.</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hplus</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;non_zero_locs&#39;</span><span class="p">):</span>
            <span class="c1"># Doing this every time is not a zero-cost operation</span>
            <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only set non zero locations to zero</span>
            <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># If threshold is given we can limit the points at which to compute the</span>
    <span class="c1"># full statistic</span>
    <span class="k">if</span> <span class="n">thresh</span><span class="p">:</span>
        <span class="c1"># This is the statistic that always overestimates the SNR...</span>
        <span class="c1"># It allows some unphysical freedom that the full statistic does not</span>
        <span class="c1">#</span>
        <span class="c1"># For now this is copied from the max-over-phase statistic. One could</span>
        <span class="c1"># probably make this faster by removing the imaginary components of</span>
        <span class="c1"># the matched filter, as these are not used here.</span>
        <span class="n">idx_p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_only</span><span class="p">(</span><span class="n">hplus</span><span class="p">[</span><span class="n">analyse_slice</span><span class="p">],</span>
                                                    <span class="n">thresh</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">hpnorm</span><span class="p">))</span>
        <span class="n">idx_c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_only</span><span class="p">(</span><span class="n">hcross</span><span class="p">[</span><span class="n">analyse_slice</span><span class="p">],</span>
                                                    <span class="n">thresh</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">hcnorm</span><span class="p">))</span>
        <span class="n">idx_p</span> <span class="o">=</span> <span class="n">idx_p</span> <span class="o">+</span> <span class="n">analyse_slice</span><span class="o">.</span><span class="n">start</span>
        <span class="n">idx_c</span> <span class="o">=</span> <span class="n">idx_c</span> <span class="o">+</span> <span class="n">analyse_slice</span><span class="o">.</span><span class="n">start</span>
        <span class="n">hp_red</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">*</span> <span class="n">hpnorm</span>
        <span class="n">hc_red</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">idx_p</span><span class="p">]</span> <span class="o">*</span> <span class="n">hcnorm</span>
        <span class="n">stat_p</span> <span class="o">=</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                     <span class="n">hc_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hc_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">locs_p</span> <span class="o">=</span> <span class="n">idx_p</span><span class="p">[</span><span class="n">stat_p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">thresh</span><span class="o">*</span><span class="n">thresh</span><span class="p">)]</span>
        <span class="n">hp_red</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">idx_c</span><span class="p">]</span> <span class="o">*</span> <span class="n">hpnorm</span>
        <span class="n">hc_red</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">idx_c</span><span class="p">]</span> <span class="o">*</span> <span class="n">hcnorm</span>
        <span class="n">stat_c</span> <span class="o">=</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hp_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                     <span class="n">hc_red</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">hc_red</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">locs_c</span> <span class="o">=</span> <span class="n">idx_c</span><span class="p">[</span><span class="n">stat_c</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">thresh</span><span class="o">*</span><span class="n">thresh</span><span class="p">)]</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">locs_p</span><span class="p">,</span> <span class="n">locs_c</span><span class="p">)))</span>

        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span>

    <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span> <span class="o">*</span> <span class="n">hpnorm</span>
    <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span> <span class="o">*</span> <span class="n">hcnorm</span>


    <span class="c1"># Calculate and sanity check the denominator</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hphccorr</span><span class="o">*</span><span class="n">hphccorr</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hphccorr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap between hp and hc is given as </span><span class="si">%f</span><span class="s2">. &quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">hphccorr</span><span class="p">)</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;How can an overlap be bigger than 1?&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;There really is no way to raise this error!?! &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;If you&#39;re seeing this, it is bad.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This case, of hphccorr==1, makes the statistic degenerate</span>
        <span class="c1"># This case should not physically be possible luckily.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;You have supplied a real overlap between hp and hc of 1. &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Ian is reasonably certain this is physically impossible &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;so why are you seeing this?&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">hcross</span><span class="p">))</span>

    <span class="c1"># Now the stuff where comp. cost may be a problem</span>
    <span class="n">hplus_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span>
    <span class="n">hcross_magsq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>
    <span class="n">rho_pluscross</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>

    <span class="n">det_stat_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">hplus_magsq</span> <span class="o">+</span> <span class="n">hcross_magsq</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho_pluscross</span><span class="o">*</span><span class="n">hphccorr</span><span class="p">)</span>

    <span class="n">det_stat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">det_stat_sq</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">thresh</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">locs</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_stat</span>
        <span class="n">out</span><span class="o">.</span><span class="n">non_zero_locs</span> <span class="o">=</span> <span class="n">locs</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">det_stat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_u_val_for_sky_loc_stat_no_phase">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.compute_u_val_for_sky_loc_stat_no_phase">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_u_val_for_sky_loc_stat_no_phase</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                 <span class="n">hpnorm</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">hcnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The max-over-sky location (no phase) detection statistic maximizes over</span>
<span class="sd">    an amplitude and the ratio of F+ and Fx, encoded in a variable called u.</span>
<span class="sd">    Here we return the value of u for the given indices.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">hpnorm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hplus</span> <span class="o">=</span> <span class="n">hplus</span> <span class="o">*</span> <span class="n">hpnorm</span>
    <span class="k">if</span> <span class="n">hcnorm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hcross</span> <span class="o">=</span> <span class="n">hcross</span> <span class="o">*</span> <span class="n">hcnorm</span>

    <span class="n">rhoplusre</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span>
    <span class="n">rhocrossre</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>
    <span class="n">overlap</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hphccorr</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">rhocrossre</span><span class="o">+</span><span class="n">overlap</span><span class="o">*</span><span class="n">rhoplusre</span><span class="p">)</span>
    <span class="c1"># Initialize tan_kappa array</span>
    <span class="n">u_val</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="mf">0.</span>
    <span class="c1"># Catch the denominator -&gt; 0 case</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1E17</span><span class="p">)</span>
    <span class="c1"># Otherwise do normal statistic</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">denom</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">rhoplusre</span><span class="o">+</span><span class="n">overlap</span><span class="o">*</span><span class="n">rhocrossre</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">rhocrossre</span><span class="o">+</span><span class="n">overlap</span><span class="o">*</span><span class="n">rhoplusre</span><span class="p">))</span>
    <span class="n">coa_phase</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u_val</span><span class="p">,</span> <span class="n">coa_phase</span></div>



<div class="viewcode-block" id="MatchedFilterSkyMaxControl">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MatchedFilterSkyMaxControl</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># FIXME: This seems much more simplistic than the aligned-spin class.</span>
    <span class="c1">#        E.g. no correlators. Is this worth updating?</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">,</span>
                <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">delta_f</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a matched filter engine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">            The frequency to begin the filter calculation. If None, begin</span>
<span class="sd">            at the first frequency after DC.</span>
<span class="sd">        high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">            The frequency to stop the filter calculation. If None, continue</span>
<span class="sd">            to the nyquist frequency.</span>
<span class="sd">        snr_threshold : float</span>
<span class="sd">            The minimum snr to return when filtering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tlen</span> <span class="o">=</span> <span class="n">tlen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">=</span> <span class="n">delta_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">=</span> <span class="n">snr_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">low_frequency_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span> <span class="o">=</span> <span class="n">high_frequency_cutoff</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_filter_and_cluster</span> <span class="o">=</span> \
                                    <span class="bp">self</span><span class="o">.</span><span class="n">full_matched_filter_and_cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_plus_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_plus_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_cross_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_cross_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hplus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hcross</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_psd</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="MatchedFilterSkyMaxControl.full_matched_filter_and_cluster">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl.full_matched_filter_and_cluster">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_matched_filter_and_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hplus_norm</span><span class="p">,</span>
                                        <span class="n">hcross_norm</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">stilde</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the complex snr and normalization.</span>

<span class="sd">        Calculated the matched filter, threshold, and cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h_quantities : Various</span>
<span class="sd">            FILL ME IN</span>
<span class="sd">        stilde : FrequencySeries</span>
<span class="sd">            The strain data to be filtered.</span>
<span class="sd">        window : int</span>
<span class="sd">            The size of the cluster window in samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : TimeSeries</span>
<span class="sd">            A time series containing the complex snr.</span>
<span class="sd">        norm : float</span>
<span class="sd">            The normalization of the complex snr.</span>
<span class="sd">        correlation: FrequencySeries</span>
<span class="sd">            A frequency series containing the correlation vector.</span>
<span class="sd">        idx : Array</span>
<span class="sd">            List of indices of the triggers.</span>
<span class="sd">        snrv : Array</span>
<span class="sd">            The snr values at the trigger locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">I_plus</span><span class="p">,</span> <span class="n">Iplus_corr</span><span class="p">,</span> <span class="n">Iplus_norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">stilde</span><span class="p">,</span>
                                          <span class="n">h_norm</span><span class="o">=</span><span class="n">hplus_norm</span><span class="p">,</span>
                                          <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                          <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span>
                                          <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_plus_mem</span><span class="p">,</span>
                                          <span class="n">corr_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_plus_mem</span><span class="p">)</span>


        <span class="n">I_cross</span><span class="p">,</span> <span class="n">Icross_corr</span><span class="p">,</span> <span class="n">Icross_norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span><span class="n">hcross</span><span class="p">,</span>
                                          <span class="n">stilde</span><span class="p">,</span> <span class="n">h_norm</span><span class="o">=</span><span class="n">hcross_norm</span><span class="p">,</span>
                                          <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                          <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span>
                                          <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_cross_mem</span><span class="p">,</span>
                                          <span class="n">corr_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_cross_mem</span><span class="p">)</span>

        <span class="c1"># The information on the complex side of this overlap is important</span>
        <span class="c1"># we may want to use this in the future.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hplus</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hcross</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_psd</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hplus_cross_corr</span> <span class="o">=</span> <span class="n">overlap_cplx</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
                                           <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span>
                                           <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fhigh</span><span class="p">,</span>
                                           <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">hplus_cross_corr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hplus_cross_corr</span><span class="p">)</span>
            <span class="n">hplus_cross_corr</span> <span class="o">=</span> <span class="n">hplus_cross_corr</span> <span class="o">/</span> <span class="p">(</span><span class="n">hcross_norm</span><span class="o">*</span><span class="n">hplus_norm</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span> <span class="o">=</span> <span class="n">hplus_cross_corr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hplus</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">hplus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_hcross</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">hcross</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_psd</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hplus_cross_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_hplus_hcross_correlation</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maximized_snr</span><span class="p">(</span><span class="n">I_plus</span><span class="p">,</span><span class="n">I_cross</span><span class="p">,</span>
                                  <span class="n">hplus_cross_corr</span><span class="p">,</span>
                                  <span class="n">hpnorm</span><span class="o">=</span><span class="n">Iplus_norm</span><span class="p">,</span>
                                  <span class="n">hcnorm</span><span class="o">=</span><span class="n">Icross_norm</span><span class="p">,</span>
                                  <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_mem</span><span class="p">,</span>
                                  <span class="n">thresh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span><span class="p">,</span>
                                  <span class="n">analyse_slice</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="p">)</span>
        <span class="c1"># FIXME: This should live further down</span>
        <span class="c1"># Convert output to pycbc TimeSeries</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tlen</span> <span class="o">*</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">,</span>
                         <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">threshold_real_numpy</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> points above threshold&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>


        <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">cluster_reduce</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> clustered points&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="c1"># erased self.</span>
        <span class="n">u_vals</span><span class="p">,</span> <span class="n">coa_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maximized_extrinsic_params</span>\
            <span class="p">(</span><span class="n">I_plus</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">I_cross</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">hplus_cross_corr</span><span class="p">,</span>
             <span class="n">indices</span><span class="o">=</span><span class="n">idx</span><span class="o">+</span><span class="n">stilde</span><span class="o">.</span><span class="n">analyze</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">hpnorm</span><span class="o">=</span><span class="n">Iplus_norm</span><span class="p">,</span>
             <span class="n">hcnorm</span><span class="o">=</span><span class="n">Icross_norm</span><span class="p">)</span>



        <span class="k">return</span> <span class="n">snr</span><span class="p">,</span> <span class="n">Iplus_corr</span><span class="p">,</span> <span class="n">Icross_corr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snrv</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">coa_phase</span><span class="p">,</span>\
                                      <span class="n">hplus_cross_corr</span><span class="p">,</span> <span class="n">Iplus_norm</span><span class="p">,</span> <span class="n">Icross_norm</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_maximized_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">compute_max_snr_over_sky_loc_stat</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_maximized_extrinsic_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">compute_u_val_for_sky_loc_stat</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="MatchedFilterSkyMaxControlNoPhase">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControlNoPhase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MatchedFilterSkyMaxControlNoPhase</span><span class="p">(</span><span class="n">MatchedFilterSkyMaxControl</span><span class="p">):</span>
    <span class="c1"># Basically the same as normal SkyMaxControl, except we use a slight</span>
    <span class="c1"># variation in the internal SNR functions.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_maximized_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">compute_max_snr_over_sky_loc_stat_no_phase</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span>
                                                          <span class="n">hphccorr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_maximized_extrinsic_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">compute_u_val_for_sky_loc_stat_no_phase</span><span class="p">(</span><span class="n">hplus</span><span class="p">,</span> <span class="n">hcross</span><span class="p">,</span> <span class="n">hphccorr</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_frequency_series">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.make_frequency_series">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_frequency_series</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a frequency series of the input vector.</span>

<span class="sd">    If the input is a frequency series it is returned, else if the input</span>
<span class="sd">    vector is a real time series it is fourier transformed and returned as a</span>
<span class="sd">    frequency series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : TimeSeries or FrequencySeries</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Frequency Series: FrequencySeries</span>
<span class="sd">        A frequency domain version of the input vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">FrequencySeries</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">vec</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">delta_f</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">N</span> <span class="o">/</span> <span class="n">vec</span><span class="o">.</span><span class="n">delta_t</span>
        <span class="n">vectilde</span> <span class="o">=</span>  <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_same_precision_as</span><span class="p">(</span><span class="n">vec</span><span class="p">)),</span>
                                    <span class="n">delta_f</span><span class="o">=</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fft</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">vectilde</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vectilde</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only convert a TimeSeries to a FrequencySeries&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="sigmasq_series">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.sigmasq_series">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sigmasq_series</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a cumulative sigmasq frequency series.</span>

<span class="sd">    Return a frequency series containing the accumulated power in the input</span>
<span class="sd">    up to that frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    htilde : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector</span>
<span class="sd">    psd : {None, FrequencySeries}, optional</span>
<span class="sd">        The psd used to weight the accumulated power.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin accumulating power. If None, start at the beginning</span>
<span class="sd">        of the vector.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop considering accumulated power. If None, continue</span>
<span class="sd">        until the end of the input vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Frequency Series: FrequencySeries</span>
<span class="sd">        A frequency series containing the cumulative sigmasq.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span>
    <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
                                   <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">sigma_vec</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">htilde</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">real_same_precision_as</span><span class="p">(</span><span class="n">htilde</span><span class="p">)),</span>
                                <span class="n">delta_f</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">squared_norm</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mag</span> <span class="o">/=</span> <span class="n">psd</span>

    <span class="n">sigma_vec</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sigma_vec</span><span class="o">*</span><span class="n">norm</span></div>



<div class="viewcode-block" id="sigmasq">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.sigmasq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sigmasq</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the loudness of the waveform. This is defined (see Duncan</span>
<span class="sd">    Brown&#39;s thesis) as the unnormalized matched-filter of the input waveform,</span>
<span class="sd">    htilde, with itself. This quantity is usually referred to as (sigma)^2</span>
<span class="sd">    and is then used to normalize matched-filters with the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    htilde : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : {None, FrequencySeries}, optional</span>
<span class="sd">        The psd used to weight the accumulated power.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin considering waveform power.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop considering waveform power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sigmasq: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span>
    <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
                                   <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">htilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">psd</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Waveform does not have same delta_f as psd&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sq</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sq</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">weighted_inner</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">psd</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sq</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="sigma">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.sigma">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sigma</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the sigma of the waveform. See sigmasq for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    htilde : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : {None, FrequencySeries}, optional</span>
<span class="sd">        The psd used to weight the accumulated power.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin considering waveform power.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop considering waveform power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sigmasq: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sigmasq</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_cutoff_indices">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.get_cutoff_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cutoff_indices</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">fhigh</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the indices of a frequency series at which to stop an overlap</span>
<span class="sd">    calculation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flow: float</span>
<span class="sd">        The frequency (in Hz) of the lower index.</span>
<span class="sd">    fhigh: float</span>
<span class="sd">        The frequency (in Hz) of the upper index.</span>
<span class="sd">    df: float</span>
<span class="sd">        The frequency step (in Hz) of the frequency series.</span>
<span class="sd">    N: int</span>
<span class="sd">        The number of points in the **time** series. Can be odd</span>
<span class="sd">        or even.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kmin: int</span>
<span class="sd">    kmax: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">flow</span><span class="p">:</span>
        <span class="n">kmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">flow</span> <span class="o">/</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kmin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Start frequency cannot be negative. &quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Supplied value and kmin </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">kmin</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kmin</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">fhigh</span><span class="p">:</span>
        <span class="n">kmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fhigh</span> <span class="o">/</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kmax</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">((</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">):</span>
            <span class="n">kmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># int() truncates towards 0, so this is</span>
        <span class="c1"># equivalent to the floor of the float</span>
        <span class="n">kmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kmax</span> <span class="o">&lt;=</span> <span class="n">kmin</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Kmax cannot be less than or equal to kmin. &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Provided values of freqencies (min,max) were &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">fhigh</span><span class="p">)</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;corresponding to (kmin, kmax) of &quot;</span>
        <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kmin</span><span class="p">,</span><span class="n">kmax</span></div>


<div class="viewcode-block" id="matched_filter_core">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.matched_filter_core">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matched_filter_core</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the complex snr and normalization.</span>

<span class="sd">    Return the complex snr, along with its associated normalization of the template,</span>
<span class="sd">    matched filtered against the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    template : TimeSeries or FrequencySeries</span>
<span class="sd">        The template waveform</span>
<span class="sd">    data : TimeSeries or FrequencySeries</span>
<span class="sd">        The strain data to be filtered.</span>
<span class="sd">    psd : {FrequencySeries}, optional</span>
<span class="sd">        The noise weighting of the filter.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the filter calculation. If None, begin at the</span>
<span class="sd">        first frequency after DC.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the filter calculation. If None, continue to the</span>
<span class="sd">        the nyquist frequency.</span>
<span class="sd">    h_norm : {None, float}, optional</span>
<span class="sd">        The template normalization. If none, this value is calculated internally.</span>
<span class="sd">    out : {None, Array}, optional</span>
<span class="sd">        An array to use as memory for snr storage. If None, memory is allocated</span>
<span class="sd">        internally.</span>
<span class="sd">    corr_out : {None, Array}, optional</span>
<span class="sd">        An array to use as memory for correlation storage. If None, memory is allocated</span>
<span class="sd">        internally. If provided, management of the vector is handled externally by the</span>
<span class="sd">        caller. No zero&#39;ing is done internally.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    snr : TimeSeries</span>
<span class="sd">        A time series containing the complex snr.</span>
<span class="sd">    correlation: FrequencySeries</span>
<span class="sd">        A frequency series containing the correlation vector.</span>
<span class="sd">    norm : float</span>
<span class="sd">        The normalization of the complex snr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">stilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stilde</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of template and data must match&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stilde</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
                                   <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">corr_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qtilde</span> <span class="o">=</span> <span class="n">corr_out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qtilde</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_same_precision_as</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_q</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_same_precision_as</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Array</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span><span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">_q</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid Output Vector: wrong length or dtype&#39;</span><span class="p">)</span>

    <span class="n">correlate</span><span class="p">(</span><span class="n">htilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">],</span> <span class="n">stilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">],</span> <span class="n">qtilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">FrequencySeries</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PSD delta_f does not match data&quot;</span><span class="p">)</span>
            <span class="n">qtilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span> <span class="o">/=</span> <span class="n">psd</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;PSD must be a FrequencySeries&quot;</span><span class="p">)</span>

    <span class="n">ifft</span><span class="p">(</span><span class="n">qtilde</span><span class="p">,</span> <span class="n">_q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">h_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">h_norm</span> <span class="o">=</span> <span class="n">sigmasq</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">)</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span> <span class="n">h_norm</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">(</span><span class="n">_q</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">_epoch</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
           <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">qtilde</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">_epoch</span><span class="p">,</span> <span class="n">delta_f</span><span class="o">=</span><span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
           <span class="n">norm</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">smear</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will take as input an array of indexes and return every</span>
<span class="sd">    unique index within the specified factor of the inputs.</span>

<span class="sd">    E.g.: smear([5,7,100],2) = [3,4,5,6,7,8,9,98,99,100,101,102]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    idx : numpy.array of ints</span>
<span class="sd">        The indexes to be smeared.</span>
<span class="sd">    factor : idx</span>
<span class="sd">        The factor by which to smear out the input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    new_idx : numpy.array of ints</span>
<span class="sd">        The smeared array of indexes.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">factor</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

<div class="viewcode-block" id="matched_filter">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.matched_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matched_filter</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigmasq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the complex snr.</span>

<span class="sd">    Return the complex snr, along with its associated normalization of the</span>
<span class="sd">    template, matched filtered against the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    template : TimeSeries or FrequencySeries</span>
<span class="sd">        The template waveform</span>
<span class="sd">    data : TimeSeries or FrequencySeries</span>
<span class="sd">        The strain data to be filtered.</span>
<span class="sd">    psd : FrequencySeries</span>
<span class="sd">        The noise weighting of the filter.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the filter calculation. If None, begin at the</span>
<span class="sd">        first frequency after DC.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the filter calculation. If None, continue to the</span>
<span class="sd">        the nyquist frequency.</span>
<span class="sd">    sigmasq : {None, float}, optional</span>
<span class="sd">        The template normalization. If none, this value is calculated</span>
<span class="sd">        internally.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    snr : TimeSeries</span>
<span class="sd">        A time series containing the complex snr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">snr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
            <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
            <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">h_norm</span><span class="o">=</span><span class="n">sigmasq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">snr</span> <span class="o">*</span> <span class="n">norm</span></div>


<span class="n">_snr</span> <span class="o">=</span> <span class="kc">None</span>
<div class="viewcode-block" id="match">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.match">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="n">vec1</span><span class="p">,</span>
    <span class="n">vec2</span><span class="p">,</span>
    <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">v1_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">v2_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">subsample_interpolation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the match between the two TimeSeries or FrequencySeries.</span>

<span class="sd">    Return the match between two waveforms. This is equivalent to the overlap</span>
<span class="sd">    maximized over time and phase.</span>

<span class="sd">    The maximization is only performed with discrete time-shifts,</span>
<span class="sd">    or a quadratic interpolation of them if the subsample_interpolation</span>
<span class="sd">    option is turned on; for a more precise computation</span>
<span class="sd">    of the match between two waveforms, use the optimized_match function.</span>
<span class="sd">    The accuracy of this function is guaranteed up to the fourth decimal place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vec1 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    vec2 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : Frequency Series</span>
<span class="sd">        A power spectral density to weight the overlap.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the match.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the match.</span>
<span class="sd">    v1_norm : {None, float}, optional</span>
<span class="sd">        The normalization of the first waveform. This is equivalent to its</span>
<span class="sd">        sigmasq value. If None, it is internally calculated.</span>
<span class="sd">    v2_norm : {None, float}, optional</span>
<span class="sd">        The normalization of the second waveform. This is equivalent to its</span>
<span class="sd">        sigmasq value. If None, it is internally calculated.</span>
<span class="sd">    subsample_interpolation : {False, bool}, optional</span>
<span class="sd">        If True the peak will be interpolated between samples using a simple</span>
<span class="sd">        quadratic fit. This can be important if measuring matches very close to</span>
<span class="sd">        1 and can cause discontinuities if you don&#39;t use it as matches move</span>
<span class="sd">        between discrete samples. If True the index returned will be a float.</span>
<span class="sd">    return_phase : {False, bool}, optional</span>
<span class="sd">        If True, also return the phase shift that gives the match.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    match: float</span>
<span class="sd">    index: int</span>
<span class="sd">        The number of samples to shift to get the match.</span>
<span class="sd">    phi: float</span>
<span class="sd">        Phase to rotate complex waveform to get the match, if desired.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">stilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">htilde</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">global</span> <span class="n">_snr</span>
    <span class="k">if</span> <span class="n">_snr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_snr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">_snr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">_snr</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_same_precision_as</span><span class="p">(</span><span class="n">vec1</span><span class="p">))</span>
    <span class="n">snr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">snr_norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span>
        <span class="n">htilde</span><span class="p">,</span>
        <span class="n">stilde</span><span class="p">,</span>
        <span class="n">psd</span><span class="p">,</span>
        <span class="n">low_frequency_cutoff</span><span class="p">,</span>
        <span class="n">high_frequency_cutoff</span><span class="p">,</span>
        <span class="n">v1_norm</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">_snr</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">maxsnr</span><span class="p">,</span> <span class="n">max_id</span> <span class="o">=</span> <span class="n">snr</span><span class="o">.</span><span class="n">abs_max_loc</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v2_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v2_norm</span> <span class="o">=</span> <span class="n">sigmasq</span><span class="p">(</span><span class="n">stilde</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subsample_interpolation</span><span class="p">:</span>
        <span class="c1"># This uses the implementation coded up in sbank. Thanks Nick!</span>
        <span class="c1"># The maths for this is well summarized here:</span>
        <span class="c1"># https://ccrma.stanford.edu/~jos/sasp/Quadratic_Interpolation_Spectral_Peaks.html</span>
        <span class="c1"># We use adjacent points to interpolate, but wrap off the end if needed</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_id</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="n">max_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="n">maxsnr</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">max_id</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="n">max_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Get derivatives</span>
        <span class="n">id_shift</span><span class="p">,</span> <span class="n">maxsnr</span> <span class="o">=</span> <span class="n">quadratic_interpolate_peak</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">max_id</span> <span class="o">=</span> <span class="n">max_id</span> <span class="o">+</span> <span class="n">id_shift</span>

    <span class="k">if</span> <span class="n">return_phase</span><span class="p">:</span>
        <span class="n">rounded_max_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">max_id</span><span class="p">))</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="n">rounded_max_id</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">maxsnr</span> <span class="o">*</span> <span class="n">snr_norm</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">v2_norm</span><span class="p">),</span> <span class="n">max_id</span><span class="p">,</span> <span class="n">phi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">maxsnr</span> <span class="o">*</span> <span class="n">snr_norm</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">v2_norm</span><span class="p">),</span> <span class="n">max_id</span></div>


<div class="viewcode-block" id="overlap">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.overlap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the overlap between the two TimeSeries or FrequencySeries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vec1 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    vec2 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : Frequency Series</span>
<span class="sd">        A power spectral density to weight the overlap.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the overlap.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the overlap.</span>
<span class="sd">    normalized : {True, boolean}, optional</span>
<span class="sd">        Set if the overlap is normalized. If true, it will range from 0 to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    overlap: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">overlap_cplx</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> \
            <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>\
            <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">,</span>\
            <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="overlap_cplx">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.overlap_cplx">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">overlap_cplx</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the complex overlap between the two TimeSeries or FrequencySeries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vec1 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    vec2 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : Frequency Series</span>
<span class="sd">        A power spectral density to weight the overlap.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the overlap.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the overlap.</span>
<span class="sd">    normalized : {True, boolean}, optional</span>
<span class="sd">        Set if the overlap is normalized. If true, it will range from 0 to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    overlap: complex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">stilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>

    <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
            <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stilde</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">psd</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="p">(</span><span class="n">htilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span><span class="o">.</span><span class="n">weighted_inner</span><span class="p">(</span><span class="n">stilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">],</span> <span class="n">psd</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="p">(</span><span class="n">htilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">stilde</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
        <span class="n">sig1</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
                     <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">)</span>
        <span class="n">sig2</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">(</span><span class="n">vec2</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
                     <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sig1</span> <span class="o">/</span> <span class="n">sig2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">*</span> <span class="n">inner</span> <span class="o">*</span> <span class="n">norm</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">quadratic_interpolate_peak</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate the peak and offset using a quadratic approximation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : numpy array</span>
<span class="sd">        Values at a relative bin value of [-1]</span>
<span class="sd">    middle : numpy array</span>
<span class="sd">        Values at a relative bin value of [0]</span>
<span class="sd">    right : numpy array</span>
<span class="sd">        Values at a relative bin value of [1]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_offset : numpy array</span>
<span class="sd">        Array of bins offsets, each in the range [-1/2, 1/2]</span>
<span class="sd">    peak_values : numpy array</span>
<span class="sd">        Array of the estimated peak values at the interpolated offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_offset</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">peak_value</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">*</span> <span class="n">bin_offset</span>
    <span class="k">return</span> <span class="n">bin_offset</span><span class="p">,</span> <span class="n">peak_value</span>


<div class="viewcode-block" id="LiveBatchMatchedFilter">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.LiveBatchMatchedFilter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LiveBatchMatchedFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate SNR and signal consistency tests in a batched progression&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">chisq_bins</span><span class="p">,</span> <span class="n">sg_chisq</span><span class="p">,</span>
                 <span class="n">maxelements</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">27</span><span class="p">,</span>
                 <span class="n">snr_abort_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">newsnr_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_triggers_in_batch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a batched matchedfilter instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        templates: list of `FrequencySeries`</span>
<span class="sd">            List of templates from the FilterBank class.</span>
<span class="sd">        snr_threshold: float</span>
<span class="sd">            Minimum value to record peaks in the SNR time series.</span>
<span class="sd">        chisq_bins: str</span>
<span class="sd">            Str that determines how the number of chisq bins varies as a</span>
<span class="sd">            function of the template bank parameters.</span>
<span class="sd">        sg_chisq: pycbc.vetoes.SingleDetSGChisq</span>
<span class="sd">            Instance of the sg_chisq class to calculate sg_chisq with.</span>
<span class="sd">        maxelements: {int, 2**27}</span>
<span class="sd">            Maximum size of a batched fourier transform.</span>
<span class="sd">        snr_abort_threshold: {float, None}</span>
<span class="sd">            If the SNR is above this threshold, do not record any triggers.</span>
<span class="sd">        newsnr_threshold: {float, None}</span>
<span class="sd">            Only record triggers that have a re-weighted NewSNR above this</span>
<span class="sd">            threshold.</span>
<span class="sd">        max_triggers_in_batch: {int, None}</span>
<span class="sd">            Record X number of the loudest triggers by SNR in each MPI</span>
<span class="sd">            process. Signal consistency values will also only be calculated</span>
<span class="sd">            for these triggers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span> <span class="o">=</span> <span class="n">snr_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_abort_threshold</span> <span class="o">=</span> <span class="n">snr_abort_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newsnr_threshold</span> <span class="o">=</span> <span class="n">newsnr_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_triggers_in_batch</span> <span class="o">=</span> <span class="n">max_triggers_in_batch</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pycbc</span><span class="w"> </span><span class="kn">import</span> <span class="n">vetoes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power_chisq</span> <span class="o">=</span> <span class="n">vetoes</span><span class="o">.</span><span class="n">SingleDetPowerChisq</span><span class="p">(</span><span class="n">chisq_bins</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sg_chisq</span> <span class="o">=</span> <span class="n">sg_chisq</span>

        <span class="n">durations</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">t</span><span class="o">.</span><span class="n">delta_f</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">])</span>

        <span class="n">lsort</span> <span class="o">=</span> <span class="n">durations</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">durations</span><span class="p">[</span><span class="n">lsort</span><span class="p">]</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">templates</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">lsort</span><span class="p">]</span>

        <span class="c1"># Figure out how to chunk together the templates into groups to process</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tsamples</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">]</span>
        <span class="n">grabs</span> <span class="o">=</span> <span class="n">maxelements</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tsamples</span><span class="p">)</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">grab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">grabs</span><span class="p">):</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="n">grab</span><span class="p">))</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">count</span> <span class="o">+</span> <span class="n">num</span><span class="p">])</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="n">count</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

        <span class="c1"># We now have how many templates to grab at a time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_mem</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cout_mem</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">chunk_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">durations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_tsamples</span> <span class="o">=</span> <span class="p">[</span><span class="n">tsamples</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_tsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span>

        <span class="c1"># Create workspace memory for correlate and snr</span>
        <span class="n">mem_ids</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunk_durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)]</span>
        <span class="n">mem_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mem_ids</span><span class="p">,</span> <span class="n">samples</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tgroups</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mids</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">mem_types</span><span class="p">:</span>
            <span class="n">dur</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cout_mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IFFT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cout_mem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_mem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                <span class="n">nbatch</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                                <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cout_mem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">//</span> <span class="n">count</span><span class="p">)</span>

        <span class="c1"># Split the templates into their processing groups</span>
        <span class="k">for</span> <span class="n">dur</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">mem_ids</span><span class="p">:</span>
            <span class="n">tgroup</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">count</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tgroups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tgroup</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dur</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
            <span class="n">templates</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="n">count</span><span class="p">:]</span>

        <span class="c1"># Associate the snr and corr memory block to each template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tgroup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tgroups</span><span class="p">):</span>
            <span class="n">psize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_tsamples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">psize</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">htilde</span> <span class="ow">in</span> <span class="n">tgroup</span><span class="p">:</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_mem</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">cout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cout_mem</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">psize</span>
                <span class="n">e</span> <span class="o">+=</span> <span class="n">psize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BatchCorrelator</span><span class="p">(</span><span class="n">tgroup</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">cout</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tgroup</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

<div class="viewcode-block" id="LiveBatchMatchedFilter.set_data">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.set_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the data reader object to use&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_id</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="LiveBatchMatchedFilter.combine_results">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.combine_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine results from different batches of filtering&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="LiveBatchMatchedFilter.process_data">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_reader</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the data for all of the templates&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data_reader</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_all</span><span class="p">()</span></div>


<div class="viewcode-block" id="LiveBatchMatchedFilter.process_all">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process every batch group and return as single result&quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">veto_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">veto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_batch</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">veto_info</span> <span class="o">+=</span> <span class="n">veto</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_results</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_triggers_in_batch</span><span class="p">:</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_triggers_in_batch</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sort</span><span class="p">]</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="n">veto_info</span>
            <span class="n">veto_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_vetoes</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">veto_info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_process_vetoes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">veto_info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate signal based vetoes&quot;&quot;&quot;</span>
        <span class="n">chisq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">veto_info</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">veto_info</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sg_chisq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">veto_info</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                               <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;chisq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chisq</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;chisq_dof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dof</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sg_chisq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg_chisq</span>

        <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">snrv</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">veto_info</span><span class="p">):</span>
            <span class="n">correlate</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="p">,</span> <span class="n">htilde</span><span class="o">.</span><span class="n">cout</span><span class="p">)</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_chisq</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">cout</span><span class="p">,</span> <span class="n">snrv</span><span class="p">,</span>
                                           <span class="n">norm</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span> <span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">htilde</span><span class="p">)</span>
            <span class="n">chisq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dof</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">sgv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg_chisq</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">stilde</span><span class="p">,</span> <span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span>
                                       <span class="n">snrv</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sgv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sg_chisq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sgv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">newsnr_threshold</span><span class="p">:</span>
                <span class="n">newsnr</span> <span class="o">=</span> <span class="n">ranking</span><span class="o">.</span><span class="n">newsnr</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;snr&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">chisq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">newsnr</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newsnr_threshold</span><span class="p">:</span>
                    <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">newsnr_threshold</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">keep</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process only a single batch group of data&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_id</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tgroups</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">tgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgroups</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_id</span><span class="p">]</span>
        <span class="n">psize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_tsamples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_id</span><span class="p">]</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_id</span><span class="p">]</span>
        <span class="n">stilde</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">overwhitened_data</span><span class="p">(</span><span class="n">tgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">psd</span>

        <span class="n">valid_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">psize</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">trim_padding</span><span class="p">)</span>
        <span class="n">valid_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid_end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>

        <span class="n">seg</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">valid_start</span><span class="p">,</span> <span class="n">valid_end</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_id</span><span class="p">]</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stilde</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifts</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgroup</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgroup</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgroup</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">sigmasq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tgroup</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">time</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">start_time</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tkeys</span> <span class="o">=</span> <span class="n">tgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tkeys</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">veto_info</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Find the peaks in our SNR times series from the various templates</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">htilde</span> <span class="ow">in</span> <span class="n">tgroup</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="s1">&#39;time_offset&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;time_offset&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;time_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">l</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">abs_arg_max</span><span class="p">()</span>

            <span class="n">sgm</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">sigmasq</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span> <span class="o">/</span> <span class="p">(</span><span class="n">sgm</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">valid_start</span>
            <span class="n">snrv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">htilde</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span>

            <span class="c1"># If nothing is above threshold we can exit this template</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snrv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">norm</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_threshold</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">valid_start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample_rate</span>

            <span class="c1"># We have an SNR so high that we will drop the entire analysis</span>
            <span class="c1"># of this chunk of time!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_abort_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_abort_threshold</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;We are seeing some *really* high SNRs, let&#39;s &quot;</span>
                            <span class="s2">&quot;assume they aren&#39;t signals and just give up&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[]</span>

            <span class="n">veto_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">snrv</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="p">))</span>

            <span class="n">snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">snrv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm</span>
            <span class="n">sigmasq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sgm</span>
            <span class="n">templates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="s1">&#39;dict_params&#39;</span><span class="p">):</span>
                <span class="n">htilde</span><span class="o">.</span><span class="n">dict_params</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tkeys</span><span class="p">:</span>
                    <span class="n">htilde</span><span class="o">.</span><span class="n">dict_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tkeys</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">dict_params</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="s1">&#39;time_offset&#39;</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;time_offset&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">time_offset</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;snr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;coa_phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">snr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;template_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;sigmasq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmasq</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tkeys</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;time_offset&#39;</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;time_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;time_offset&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">veto_info</span></div>


<div class="viewcode-block" id="followup_event_significance">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.followup_event_significance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">followup_event_significance</span><span class="p">(</span><span class="n">ifo</span><span class="p">,</span> <span class="n">data_reader</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
                                <span class="n">template_id</span><span class="p">,</span> <span class="n">coinc_times</span><span class="p">,</span>
                                <span class="n">coinc_threshold</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                                <span class="n">lookback</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">0.095</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a detector, a template waveform and a set of candidate event</span>
<span class="sd">    times in different detectors, perform an on-source/off-source analysis</span>
<span class="sd">    to determine if the SNR in the first detector has a significant peak</span>
<span class="sd">    in the on-source window. The significance is given in terms of a</span>
<span class="sd">    p-value. See Dal Canton et al. 2021 (https://arxiv.org/abs/2008.07494)</span>
<span class="sd">    for details. A portion of the SNR time series around the on-source window</span>
<span class="sd">    is also returned for use in BAYESTAR.</span>

<span class="sd">    If the calculation cannot be carried out, for example because `ifo` is</span>
<span class="sd">    not in observing mode at the requested time, then None is returned.</span>
<span class="sd">    Otherwise, the dict contains the following keys. `snr_series` is a</span>
<span class="sd">    TimeSeries object with the SNR time series for BAYESTAR. `peak_time` is the</span>
<span class="sd">    time of maximum SNR in the on-source window. `pvalue` is the p-value for</span>
<span class="sd">    the maximum on-source SNR compared to the off-source realizations.</span>
<span class="sd">    `pvalue_saturated` is a bool indicating whether the p-value is limited by</span>
<span class="sd">    the number of off-source realizations, i.e. whether the maximum on-source</span>
<span class="sd">    SNR is larger than all the off-source ones. `sigma2` is the SNR</span>
<span class="sd">    normalization (squared) for the given template and detector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ifo: str</span>
<span class="sd">        Which detector is being used for the calculation.</span>
<span class="sd">    data_reader: StrainBuffer</span>
<span class="sd">        StrainBuffer object providing the data for the given detector.</span>
<span class="sd">    bank: LiveFilterBank</span>
<span class="sd">        Template bank object providing the template related quantities.</span>
<span class="sd">    template_id: int</span>
<span class="sd">        Index of the template in the bank.</span>
<span class="sd">    coinc_times: dict</span>
<span class="sd">        Dictionary keyed by detector names reporting the coalescence times of</span>
<span class="sd">        a candidate measured at the different detectors. Used to define the</span>
<span class="sd">        on-source window of the candidate in `ifo`.</span>
<span class="sd">    coinc_threshold: float</span>
<span class="sd">        Nominal statistical uncertainty in `coinc_times`; expands the</span>
<span class="sd">        on-source window by twice the given amount.</span>
<span class="sd">    lookback: float</span>
<span class="sd">        Nominal amount of time to use for the calculation of the onsource and</span>
<span class="sd">        offsource SNR time series. The actual time may be reduced depending on</span>
<span class="sd">        the duration of the template and the strain buffer in the data reader</span>
<span class="sd">        (if so, a warning is logged).</span>
<span class="sd">    duration: float</span>
<span class="sd">        Duration of the SNR time series to be reported to BAYESTAR.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    followup_info: dict or None</span>
<span class="sd">        Results of the followup calculation (see above) or None if `ifo` did</span>
<span class="sd">        not have usable data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.waveform</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_waveform_filter_length_in_time</span>
    <span class="n">tmplt</span> <span class="o">=</span> <span class="n">bank</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">template_id</span><span class="p">]</span>
    <span class="n">length_in_time</span> <span class="o">=</span> <span class="n">get_waveform_filter_length_in_time</span><span class="p">(</span><span class="n">tmplt</span><span class="p">[</span><span class="s1">&#39;approximant&#39;</span><span class="p">],</span>
                                                        <span class="n">tmplt</span><span class="p">)</span>

    <span class="c1"># calculate onsource time range</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycbc.detector</span><span class="w"> </span><span class="kn">import</span> <span class="n">Detector</span>
    <span class="n">onsource_start</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">onsource_end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">fdet</span> <span class="o">=</span> <span class="n">Detector</span><span class="p">(</span><span class="n">ifo</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cifo</span> <span class="ow">in</span> <span class="n">coinc_times</span><span class="p">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">coinc_times</span><span class="p">[</span><span class="n">cifo</span><span class="p">]</span>
        <span class="n">dtravel</span> <span class="o">=</span> <span class="n">Detector</span><span class="p">(</span><span class="n">cifo</span><span class="p">)</span><span class="o">.</span><span class="n">light_travel_time_to_detector</span><span class="p">(</span><span class="n">fdet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">-</span> <span class="n">dtravel</span> <span class="o">&gt;</span> <span class="n">onsource_start</span><span class="p">:</span>
            <span class="n">onsource_start</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">dtravel</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">+</span> <span class="n">dtravel</span> <span class="o">&lt;</span> <span class="n">onsource_end</span><span class="p">:</span>
            <span class="n">onsource_end</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">dtravel</span>

    <span class="c1"># Source must be within this time window to be considered a possible</span>
    <span class="c1"># coincidence</span>
    <span class="n">onsource_start</span> <span class="o">-=</span> <span class="n">coinc_threshold</span>
    <span class="n">onsource_end</span> <span class="o">+=</span> <span class="n">coinc_threshold</span>

    <span class="c1"># Calculate how much time is needed to calculate the significance.</span>
    <span class="c1"># At the minimum, we need enough time to include the lookback, plus time</span>
    <span class="c1"># that we will throw away because of corruption from finite-duration filter</span>
    <span class="c1"># responses (this is equal to the nominal padding plus the template</span>
    <span class="c1"># duration). Next, for efficiency, we round the resulting duration up to</span>
    <span class="c1"># align it with one of the frequency resolutions preferred by the template</span>
    <span class="c1"># bank. And finally, the resulting duration must fit into the strain buffer</span>
    <span class="c1"># available in the data reader, so we check that.</span>
    <span class="n">trim_pad</span> <span class="o">=</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">trim_padding</span> <span class="o">*</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">strain</span><span class="o">.</span><span class="n">delta_t</span>
    <span class="n">buffer_duration</span> <span class="o">=</span> <span class="n">lookback</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">trim_pad</span> <span class="o">+</span> <span class="n">length_in_time</span>
    <span class="n">buffer_samples</span> <span class="o">=</span> <span class="n">bank</span><span class="o">.</span><span class="n">round_up</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">buffer_duration</span> <span class="o">*</span> <span class="n">bank</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
    <span class="n">max_safe_buffer_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="mf">0.9</span> <span class="o">*</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">strain</span><span class="o">.</span><span class="n">duration</span> <span class="o">*</span> <span class="n">bank</span><span class="o">.</span><span class="n">sample_rate</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">buffer_samples</span> <span class="o">&gt;</span> <span class="n">max_safe_buffer_samples</span><span class="p">:</span>
        <span class="n">buffer_samples</span> <span class="o">=</span> <span class="n">max_safe_buffer_samples</span>
        <span class="n">new_lookback</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">buffer_samples</span> <span class="o">/</span> <span class="n">bank</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trim_pad</span> <span class="o">+</span> <span class="n">length_in_time</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Require a minimum lookback time of twice the onsource window or SNR</span>
        <span class="c1"># time series (whichever is longer) so we have enough data for the</span>
        <span class="c1"># onsource window, the SNR time series, and at least a few background</span>
        <span class="c1"># samples</span>
        <span class="n">min_required_lookback</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">onsource_end</span> <span class="o">-</span> <span class="n">onsource_start</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_lookback</span> <span class="o">&gt;</span> <span class="n">min_required_lookback</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;Strain buffer too short for a lookback time of </span><span class="si">%f</span><span class="s1"> s, &#39;</span>
                <span class="s1">&#39;reducing lookback to </span><span class="si">%f</span><span class="s1"> s&#39;</span><span class="p">,</span>
                <span class="n">lookback</span><span class="p">,</span>
                <span class="n">new_lookback</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s1">&#39;Strain buffer too short to compute the followup SNR time &#39;</span>
                <span class="s1">&#39;series for template </span><span class="si">%d</span><span class="s1">, will not use </span><span class="si">%s</span><span class="s1"> for followup. &#39;</span>
                <span class="s1">&#39;Either use shorter templates, or raise --max-length.&#39;</span><span class="p">,</span>
                <span class="n">template_id</span><span class="p">,</span>
                <span class="n">ifo</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="n">buffer_duration</span> <span class="o">=</span> <span class="n">buffer_samples</span> <span class="o">/</span> <span class="n">bank</span><span class="o">.</span><span class="n">sample_rate</span>

    <span class="c1"># Require all strain be valid within lookback time</span>
    <span class="k">if</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">state_start_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data_reader</span><span class="o">.</span><span class="n">strain</span><span class="o">.</span><span class="n">end_time</span>
            <span class="o">-</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">reduced_pad</span> <span class="o">*</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">strain</span><span class="o">.</span><span class="n">delta_t</span>
            <span class="o">-</span> <span class="n">buffer_duration</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">is_extent_valid</span><span class="p">(</span>
            <span class="n">state_start_time</span><span class="p">,</span> <span class="n">buffer_duration</span>
        <span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> strain buffer contains invalid data during lookback, &#39;</span>
                <span class="s1">&#39;will not use for followup&#39;</span><span class="p">,</span>
                <span class="n">ifo</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># We won&#39;t require that all DQ checks be valid for now, except at</span>
    <span class="c1"># onsource time.</span>
    <span class="k">if</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dq_start_time</span> <span class="o">=</span> <span class="n">onsource_start</span> <span class="o">-</span> <span class="n">duration</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">dq_duration</span> <span class="o">=</span> <span class="n">onsource_end</span> <span class="o">-</span> <span class="n">onsource_start</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq</span><span class="o">.</span><span class="n">is_extent_valid</span><span class="p">(</span><span class="n">dq_start_time</span><span class="p">,</span> <span class="n">dq_duration</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> DQ buffer indicates invalid data during onsource window, &#39;</span>
                <span class="s1">&#39;will not use for followup&#39;</span><span class="p">,</span>
                <span class="n">ifo</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Calculate SNR time series for the entire lookback duration</span>
    <span class="n">htilde</span> <span class="o">=</span> <span class="n">bank</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span>
        <span class="n">template_id</span><span class="p">,</span> <span class="n">delta_f</span><span class="o">=</span><span class="n">bank</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">buffer_samples</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">stilde</span> <span class="o">=</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">overwhitened_data</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>

    <span class="n">sigma2</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">sigmasq</span><span class="p">(</span><span class="n">stilde</span><span class="o">.</span><span class="n">psd</span><span class="p">)</span>
    <span class="n">snr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="p">,</span> <span class="n">h_norm</span><span class="o">=</span><span class="n">sigma2</span><span class="p">)</span>

    <span class="c1"># Find peak SNR in on-source and determine p-value</span>
    <span class="n">onsrc</span> <span class="o">=</span> <span class="n">snr</span><span class="o">.</span><span class="n">time_slice</span><span class="p">(</span><span class="n">onsource_start</span><span class="p">,</span> <span class="n">onsource_end</span><span class="p">)</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">onsrc</span><span class="o">.</span><span class="n">abs_arg_max</span><span class="p">()</span>
    <span class="n">peak_time</span> <span class="o">=</span> <span class="n">peak</span> <span class="o">*</span> <span class="n">snr</span><span class="o">.</span><span class="n">delta_t</span> <span class="o">+</span> <span class="n">onsrc</span><span class="o">.</span><span class="n">start_time</span>
    <span class="n">peak_value</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">onsrc</span><span class="p">[</span><span class="n">peak</span><span class="p">])</span>

    <span class="n">bstart</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">snr</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="n">length_in_time</span> <span class="o">+</span> <span class="n">trim_pad</span>
    <span class="n">bkg</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snr</span><span class="o">.</span><span class="n">time_slice</span><span class="p">(</span><span class="n">bstart</span><span class="p">,</span> <span class="n">onsource_start</span><span class="p">))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">onsource_end</span> <span class="o">-</span> <span class="n">onsource_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bkg</span><span class="p">)</span> <span class="o">/</span> <span class="n">window</span><span class="p">)</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="n">bkg</span><span class="p">[:</span><span class="n">nsamples</span><span class="o">*</span><span class="n">window</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num_louder_bg</span> <span class="o">=</span> <span class="p">(</span><span class="n">peaks</span> <span class="o">&gt;=</span> <span class="n">peak_value</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">num_louder_bg</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nsamples</span><span class="p">)</span>
    <span class="n">pvalue_saturated</span> <span class="o">=</span> <span class="n">num_louder_bg</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># Return recentered source SNR for bayestar, along with p-value, and trig</span>
    <span class="n">peak_full</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">peak_time</span> <span class="o">-</span> <span class="n">snr</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">snr</span><span class="o">.</span><span class="n">delta_t</span><span class="p">)</span>
    <span class="n">half_dur_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">snr_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">peak_full</span> <span class="o">-</span> <span class="n">half_dur_samples</span><span class="p">,</span>
                      <span class="n">peak_full</span> <span class="o">+</span> <span class="n">half_dur_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">baysnr</span> <span class="o">=</span> <span class="n">snr</span><span class="p">[</span><span class="n">snr_slice</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">%s</span><span class="s1"> to candidate, pvalue </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1"> samples&#39;</span><span class="p">,</span> <span class="n">ifo</span><span class="p">,</span>
                <span class="n">pvalue</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;snr_series&#39;</span><span class="p">:</span> <span class="n">baysnr</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span>
        <span class="s1">&#39;peak_time&#39;</span><span class="p">:</span> <span class="n">peak_time</span><span class="p">,</span>
        <span class="s1">&#39;pvalue&#39;</span><span class="p">:</span> <span class="n">pvalue</span><span class="p">,</span>
        <span class="s1">&#39;pvalue_saturated&#39;</span><span class="p">:</span> <span class="n">pvalue_saturated</span><span class="p">,</span>
        <span class="s1">&#39;sigma2&#39;</span><span class="p">:</span> <span class="n">sigma2</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="compute_followup_snr_series">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.compute_followup_snr_series">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_followup_snr_series</span><span class="p">(</span><span class="n">data_reader</span><span class="p">,</span> <span class="n">htilde</span><span class="p">,</span> <span class="n">trig_time</span><span class="p">,</span>
                                <span class="n">duration</span><span class="o">=</span><span class="mf">0.095</span><span class="p">,</span> <span class="n">check_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">coinc_window</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a StrainBuffer, a template frequency series and a trigger time,</span>
<span class="sd">    compute a portion of the SNR time series centered on the trigger for its</span>
<span class="sd">    rapid sky localization and followup.</span>

<span class="sd">    If the trigger time is too close to the boundary of the valid data segment</span>
<span class="sd">    the SNR series is calculated anyway and might be slightly contaminated by</span>
<span class="sd">    filter and wrap-around effects. For reasonable durations this will only</span>
<span class="sd">    affect a small fraction of the triggers and probably in a negligible way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_reader : StrainBuffer</span>
<span class="sd">        The StrainBuffer object to read strain data from.</span>

<span class="sd">    htilde : FrequencySeries</span>
<span class="sd">        The frequency series containing the template waveform.</span>

<span class="sd">    trig_time : {float, lal.LIGOTimeGPS}</span>
<span class="sd">        The trigger time.</span>

<span class="sd">    duration : float (optional)</span>
<span class="sd">        Duration of the computed SNR series in seconds. If omitted, it defaults</span>
<span class="sd">        to twice the Earth light travel time plus 10 ms of timing uncertainty.</span>

<span class="sd">    check_state : boolean</span>
<span class="sd">        If True, and the detector was offline or flagged for bad data quality</span>
<span class="sd">        at any point during the inspiral, then return (None, None) instead.</span>

<span class="sd">    coinc_window : float (optional)</span>
<span class="sd">        Maximum possible time between coincident triggers at different</span>
<span class="sd">        detectors. This is needed to properly determine data padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    snr : TimeSeries</span>
<span class="sd">        The portion of SNR around the trigger. None if the detector is offline</span>
<span class="sd">        or has bad data quality, and check_state is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">check_state</span><span class="p">:</span>
        <span class="c1"># was the detector observing for the full amount of involved data?</span>
        <span class="n">state_start_time</span> <span class="o">=</span> <span class="n">trig_time</span> <span class="o">-</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">htilde</span><span class="o">.</span><span class="n">length_in_time</span>
        <span class="n">state_end_time</span> <span class="o">=</span> <span class="n">trig_time</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">state_duration</span> <span class="o">=</span> <span class="n">state_end_time</span> <span class="o">-</span> <span class="n">state_start_time</span>
        <span class="k">if</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">is_extent_valid</span><span class="p">(</span><span class="n">state_start_time</span><span class="p">,</span>
                                                     <span class="n">state_duration</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># was the data quality ok for the full amount of involved data?</span>
        <span class="n">dq_start_time</span> <span class="o">=</span> <span class="n">state_start_time</span> <span class="o">-</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq_padding</span>
        <span class="n">dq_duration</span> <span class="o">=</span> <span class="n">state_duration</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq_padding</span>
        <span class="k">if</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">dq</span><span class="o">.</span><span class="n">is_extent_valid</span><span class="p">(</span><span class="n">dq_start_time</span><span class="p">,</span> <span class="n">dq_duration</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>

    <span class="n">stilde</span> <span class="o">=</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">overwhitened_data</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
    <span class="n">snr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">matched_filter_core</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">stilde</span><span class="p">,</span>
                                          <span class="n">h_norm</span><span class="o">=</span><span class="n">htilde</span><span class="o">.</span><span class="n">sigmasq</span><span class="p">(</span><span class="n">stilde</span><span class="o">.</span><span class="n">psd</span><span class="p">))</span>

    <span class="n">valid_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span> <span class="o">-</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">trim_padding</span><span class="p">)</span>
    <span class="n">valid_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">valid_end</span> <span class="o">-</span> <span class="n">data_reader</span><span class="o">.</span><span class="n">blocksize</span> <span class="o">*</span> <span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>

    <span class="n">half_dur_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">coinc_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">coinc_window</span><span class="p">)</span>
    <span class="n">valid_start</span> <span class="o">-=</span> <span class="n">half_dur_samples</span> <span class="o">+</span> <span class="n">coinc_samples</span>
    <span class="n">valid_end</span> <span class="o">+=</span> <span class="n">half_dur_samples</span>
    <span class="k">if</span> <span class="n">valid_start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">valid_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Requested SNR duration (</span><span class="si">{0}</span><span class="s1"> s)&#39;</span>
                          <span class="s1">&#39; too long&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duration</span><span class="p">))</span>

    <span class="c1"># Onsource slice for Bayestar followup</span>
    <span class="n">onsource_idx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">trig_time</span> <span class="o">-</span> <span class="n">snr</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">snr</span><span class="o">.</span><span class="n">sample_rate</span>
    <span class="n">onsource_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">onsource_idx</span><span class="p">))</span>
    <span class="n">onsource_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">onsource_idx</span> <span class="o">-</span> <span class="n">half_dur_samples</span><span class="p">,</span>
                           <span class="n">onsource_idx</span> <span class="o">+</span> <span class="n">half_dur_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">snr</span><span class="p">[</span><span class="n">onsource_slice</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="optimized_match">
<a class="viewcode-back" href="../../../pycbc.filter.html#pycbc.filter.matchedfilter.optimized_match">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">optimized_match</span><span class="p">(</span>
    <span class="n">vec1</span><span class="p">,</span>
    <span class="n">vec2</span><span class="p">,</span>
    <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">v1_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">v2_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given two waveforms (as numpy arrays),</span>
<span class="sd">    compute the optimized match between them, making use</span>
<span class="sd">    of scipy.minimize_scalar.</span>

<span class="sd">    This function computes the same quantities as &quot;match&quot;;</span>
<span class="sd">    it is more accurate and slower.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vec1 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    vec2 : TimeSeries or FrequencySeries</span>
<span class="sd">        The input vector containing a waveform.</span>
<span class="sd">    psd : FrequencySeries</span>
<span class="sd">        A power spectral density to weight the overlap.</span>
<span class="sd">    low_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to begin the match.</span>
<span class="sd">    high_frequency_cutoff : {None, float}, optional</span>
<span class="sd">        The frequency to stop the match.</span>
<span class="sd">    v1_norm : {None, float}, optional</span>
<span class="sd">        The normalization of the first waveform. This is equivalent to its</span>
<span class="sd">        sigmasq value. If None, it is internally calculated.</span>
<span class="sd">    v2_norm : {None, float}, optional</span>
<span class="sd">        The normalization of the second waveform. This is equivalent to its</span>
<span class="sd">        sigmasq value. If None, it is internally calculated.</span>
<span class="sd">    return_phase : {False, bool}, optional</span>
<span class="sd">        If True, also return the phase shift that gives the match.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    match: float</span>
<span class="sd">    index: int</span>
<span class="sd">        The number of samples to shift to get the match.</span>
<span class="sd">    phi: float</span>
<span class="sd">        Phase to rotate complex waveform to get the match, if desired.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize_scalar</span>

    <span class="n">htilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">stilde</span> <span class="o">=</span> <span class="n">make_frequency_series</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
    <span class="n">delta_f</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_f</span>

    <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">htilde</span><span class="o">.</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_t</span><span class="p">)</span>
    <span class="n">delta_t</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">delta_t</span>

    <span class="c1"># a first time shift to get in the nearby region;</span>
    <span class="c1"># then the optimization is only used to move to the</span>
    <span class="c1"># correct subsample-timeshift witin (-delta_t, delta_t)</span>
    <span class="c1"># of this</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">max_id</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span>
        <span class="n">htilde</span><span class="p">,</span>
        <span class="n">stilde</span><span class="p">,</span>
        <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
        <span class="n">low_frequency_cutoff</span><span class="o">=</span><span class="n">low_frequency_cutoff</span><span class="p">,</span>
        <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">high_frequency_cutoff</span><span class="p">,</span>
        <span class="n">return_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">stilde</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">cyclic_time_shift</span><span class="p">(</span><span class="o">-</span><span class="n">max_id</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)</span>

    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">sample_frequencies</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">waveform_1</span> <span class="o">=</span> <span class="n">htilde</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">waveform_2</span> <span class="o">=</span> <span class="n">stilde</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stilde</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">=</span> <span class="n">get_cutoff_indices</span><span class="p">(</span>
        <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">,</span> <span class="n">delta_f</span><span class="p">,</span> <span class="n">N</span>
    <span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span><span class="p">)</span>

    <span class="n">waveform_1</span> <span class="o">=</span> <span class="n">waveform_1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">waveform_2</span> <span class="o">=</span> <span class="n">waveform_2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">psd_arr</span> <span class="o">=</span> <span class="n">psd</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="n">mask</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psd_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">waveform_1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">psd_arr</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta_f</span>
        <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">integral</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">integral</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">product_offset</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">frequencies</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="n">waveform_1</span><span class="p">,</span> <span class="n">waveform_2</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_minimize</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">product_offset</span><span class="p">(</span><span class="n">dt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">norm_1</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sigmasq</span><span class="p">(</span><span class="n">htilde</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v1_norm</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">v1_norm</span>
    <span class="p">)</span>
    <span class="n">norm_2</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sigmasq</span><span class="p">(</span><span class="n">stilde</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">low_frequency_cutoff</span><span class="p">,</span> <span class="n">high_frequency_cutoff</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v2_norm</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">v2_norm</span>
    <span class="p">)</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_1</span> <span class="o">*</span> <span class="n">norm_2</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span>
        <span class="n">to_minimize</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;brent&quot;</span><span class="p">,</span>
        <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">product_offset</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_phase</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">delta_t</span> <span class="o">+</span> <span class="n">max_id</span><span class="p">,</span> <span class="o">-</span><span class="n">angle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">delta_t</span> <span class="o">+</span> <span class="n">max_id</span></div>



<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;match&#39;</span><span class="p">,</span> <span class="s1">&#39;optimized_match&#39;</span><span class="p">,</span> <span class="s1">&#39;matched_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmasq&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;get_cutoff_indices&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sigmasq_series&#39;</span><span class="p">,</span> <span class="s1">&#39;make_frequency_series&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">,</span>
           <span class="s1">&#39;overlap_cplx&#39;</span><span class="p">,</span> <span class="s1">&#39;matched_filter_core&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MatchedFilterControl&#39;</span><span class="p">,</span> <span class="s1">&#39;LiveBatchMatchedFilter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MatchedFilterSkyMaxControl&#39;</span><span class="p">,</span> <span class="s1">&#39;MatchedFilterSkyMaxControlNoPhase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;compute_max_snr_over_sky_loc_stat_no_phase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;compute_max_snr_over_sky_loc_stat&#39;</span><span class="p">,</span>
           <span class="s1">&#39;compute_followup_snr_series&#39;</span><span class="p">,</span>
           <span class="s1">&#39;compute_u_val_for_sky_loc_stat_no_phase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;compute_u_val_for_sky_loc_stat&#39;</span><span class="p">,</span>
           <span class="s1">&#39;followup_event_significance&#39;</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, 2016, 2017, Alexander Nitz, Ian Harry, Christopher M. Biwer, Duncan A.  Brown, Josh Willis, and Tito Dal Canton.
      <span class="lastupdated">Last updated on Feb 06, 2026.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>