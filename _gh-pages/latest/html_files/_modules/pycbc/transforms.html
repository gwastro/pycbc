<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pycbc.transforms &mdash; PyCBC 0.0a8230 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/terminal.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/typed.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PyCBC
          </a>
              <div class="version">
                1.18.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../credit.html">Use of PyCBC in Scientific Publications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../docker.html">Running PyCBC under Docker</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">PyCBC inference documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.inference</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../workflow/pycbc_make_psd_estimation_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_psd_estimation_workflow</span></code>: A workflow generator for noise estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflow/pycbc_make_coinc_search_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_coinc_search_workflow</span></code>: A workflow to search for gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflow/pygrb.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_offline_grb_workflow</span></code>: A GRB triggered CBC analysis workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tmpltbank.html">PyCBC template bank generation documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.tmpltbank</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwinj.html">Hardware injection waveform generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../banksim.html">Calculating the Effectualness (Fitting Factor) of Template Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faithsim.html">Dag Generator for Doing Faithfulness Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../upload_to_gracedb.html">Uploading triggers to gracedb</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../waveform_plugin.html">Making new waveform approximants available to PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../catalog.html">Catalog of Observed Gravitational-wave Mergers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataquality.html">Query times of valid data, hardware injections, and more.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../frame.html">Reading Gravitational-wave Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fft.html">Performing FFTs in PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gw150914.html">Signal Processing with GW150914</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../detector.html">Gravitational-wave Detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../psd.html">Handling PSDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../noise.html">Generating Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../waveform.html">Waveforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filter.html">Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Using PyCBC Distributions from PyCBC Inference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../building_bundled_executables.html">Building Bundled Executables</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documenting PyCBC code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release.html">Creating Releases of PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../formats/hdf_format.html">HDF files within the PyCBC workflow</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../workflow.html">Workflow: the inspiral analysis workflow generator (<code class="docutils literal notranslate"><span class="pre">pycbc.workflow</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pycbc</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyCBC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
          <li><a href="../pycbc.html">pycbc</a> &raquo;</li>
      <li>pycbc.transforms</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pycbc.transforms</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2017  Christopher M. Biwer</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU General Public License as published by the</span>
<span class="c1"># Free Software Foundation; either version 3 of the License, or (at your</span>
<span class="c1"># option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but</span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c1"># Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This modules provides classes and functions for transforming parameters.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">pycbc</span> <span class="kn">import</span> <span class="n">conversions</span>
<span class="kn">from</span> <span class="nn">pycbc</span> <span class="kn">import</span> <span class="n">coordinates</span>
<span class="kn">from</span> <span class="nn">pycbc</span> <span class="kn">import</span> <span class="n">cosmology</span>
<span class="kn">from</span> <span class="nn">pycbc.io</span> <span class="kn">import</span> <span class="n">record</span>
<span class="kn">from</span> <span class="nn">pycbc.waveform</span> <span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">pycbc.boundaries</span> <span class="kn">import</span> <span class="n">Bounds</span>
<span class="kn">from</span> <span class="nn">pycbc</span> <span class="kn">import</span> <span class="n">VARARGS_DELIM</span>

<div class="viewcode-block" id="BaseTransform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform">[docs]</a><span class="k">class</span> <span class="nc">BaseTransform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A base class for transforming between two sets of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>

<div class="viewcode-block" id="BaseTransform.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from inputs to outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not added.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseTransform.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The inverse conversions of transform. This function transforms from</span>
<span class="sd">        outputs to inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not added.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseTransform.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Jacobian for the inputs to outputs transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Jacobian transform not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseTransform.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Jacobian for the outputs to inputs transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Jacobian transform not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseTransform.format_output"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.format_output">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">format_output</span><span class="p">(</span><span class="n">old_maps</span><span class="p">,</span> <span class="n">new_maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function takes the returned dict from `transform` and converts</span>
<span class="sd">        it to the same datatype as the input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old_maps : {FieldArray, dict}</span>
<span class="sd">            The mapping object to add new maps to.</span>
<span class="sd">        new_maps : dict</span>
<span class="sd">            A dict with key as parameter name and value is numpy.array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        {FieldArray, dict}</span>
<span class="sd">            The old_maps object with new keys from new_maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if input is FieldArray then return FieldArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_maps</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">FieldArray</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">new_maps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_maps</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">old_maps</span> <span class="o">=</span> <span class="n">old_maps</span><span class="o">.</span><span class="n">add_fields</span><span class="p">([</span><span class="n">vals</span><span class="p">],</span> <span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">old_maps</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">return</span> <span class="n">old_maps</span>

        <span class="c1"># if input is dict then return dict</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_maps</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">old_maps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_maps</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1"># else error</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input type must be FieldArray or dict.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseTransform.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.BaseTransform.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">additional_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes a transform from the given section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cp : pycbc.workflow.WorkflowConfigParser</span>
<span class="sd">            A parsed configuration file that contains the transform options.</span>
<span class="sd">        section : str</span>
<span class="sd">            Name of the section in the configuration file.</span>
<span class="sd">        outputs : str</span>
<span class="sd">            The names of the parameters that are output by this transformation,</span>
<span class="sd">            separated by `VARARGS_DELIM`. These must appear in the &quot;tag&quot; part</span>
<span class="sd">            of the section header.</span>
<span class="sd">        skip_opts : list, optional</span>
<span class="sd">            Do not read options in the given list.</span>
<span class="sd">        additional_opts : dict, optional</span>
<span class="sd">            Any additional arguments to pass to the class. If an option is</span>
<span class="sd">            provided that also exists in the config file, the value provided</span>
<span class="sd">            will be used instead of being read from the file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls</span>
<span class="sd">            An instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="k">if</span> <span class="n">skip_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">additional_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="n">additional_opts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">VARARGS_DELIM</span><span class="p">))</span>
        <span class="n">special_args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">skip_opts</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">additional_opts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># get any extra arguments to pass to init</span>
        <span class="n">extra_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">tag</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">special_args</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># check if option can be cast as a float</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c1"># add option</span>
            <span class="n">extra_args</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">opt</span><span class="p">:</span><span class="n">val</span><span class="p">})</span>
        <span class="n">extra_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">additional_opts</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">extra_args</span><span class="p">)</span>
        <span class="c1"># check that the outputs matches</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="o">-</span><span class="n">out</span><span class="o">.</span><span class="n">outputs</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">out</span><span class="o">.</span><span class="n">outputs</span><span class="o">-</span><span class="n">outputs</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;outputs of class do not match outputs specified &quot;</span>
                             <span class="s2">&quot;in section&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CustomTransform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CustomTransform">[docs]</a><span class="k">class</span> <span class="nc">CustomTransform</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allows for any transform to be defined.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_args : (list of) str</span>
<span class="sd">        The names of the input parameters.</span>
<span class="sd">    output_args : (list of) str</span>
<span class="sd">        The names of the output parameters.</span>
<span class="sd">    transform_functions : dict</span>
<span class="sd">        Dictionary mapping input args to a string giving a function call;</span>
<span class="sd">        e.g., ``{&#39;q&#39;: &#39;q_from_mass1_mass2(mass1, mass2)&#39;}``.</span>
<span class="sd">    jacobian : str, optional</span>
<span class="sd">        String giving a jacobian function. The function must be in terms of</span>
<span class="sd">        the input arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a custom transform that converts mass1, mass2 to mtotal, q:</span>

<span class="sd">    &gt;&gt;&gt; t = transforms.CustomTransform([&#39;mass1&#39;, &#39;mass2&#39;], [&#39;mtotal&#39;, &#39;q&#39;], {&#39;mtotal&#39;: &#39;mass1+mass2&#39;, &#39;q&#39;: &#39;mass1/mass2&#39;}, &#39;(mass1 + mass2) / mass2**2&#39;)</span>

<span class="sd">    Evaluate a pair of masses:</span>

<span class="sd">    &gt;&gt;&gt; t.transform({&#39;mass1&#39;: 10., &#39;mass2&#39;: 5.})</span>
<span class="sd">    {&#39;mass1&#39;: 10.0, &#39;mass2&#39;: 5.0, &#39;mtotal&#39;: 15.0, &#39;q&#39;: 2.0}</span>

<span class="sd">    The Jacobian for the same pair of masses:</span>

<span class="sd">    &gt;&gt;&gt; t.jacobian({&#39;mass1&#39;: 10., &#39;mass2&#39;: 5.})</span>
<span class="sd">    0.59999999999999998</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;custom&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_args</span><span class="p">,</span> <span class="n">output_args</span><span class="p">,</span> <span class="n">transform_functions</span><span class="p">,</span>
                 <span class="n">jacobian</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_args</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">input_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_args</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_args</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">output_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_args</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">input_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">output_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_functions</span> <span class="o">=</span> <span class="n">transform_functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian</span> <span class="o">=</span> <span class="n">jacobian</span>
        <span class="c1"># we&#39;ll create a scratch FieldArray space to do transforms on</span>
        <span class="c1"># we&#39;ll default to length 1; this will be changed if a map is passed</span>
        <span class="c1"># with more than one value in it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createscratch</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_createscratch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a scratch FieldArray to use for transforms.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scratch</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">FieldArray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_copytoscratch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the data in maps to the scratch space.</span>

<span class="sd">        If the maps contain arrays that are not the same shape as the scratch</span>
<span class="sd">        space, a new scratch space will be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scratch</span><span class="p">[</span><span class="n">p</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># we&#39;ll get a ValueError if the scratch space isn&#39;t the same size</span>
            <span class="c1"># as the maps; in that case, re-create the scratch space with the</span>
            <span class="c1"># appropriate size and try again</span>
            <span class="n">invals</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">invals</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">invals</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">invals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_createscratch</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scratch</span><span class="p">[</span><span class="n">p</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines how to slice the scratch for returning values.&quot;&quot;&quot;</span>
        <span class="n">invals</span> <span class="o">=</span>  <span class="n">maps</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">invals</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">getslice</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getslice</span>

<div class="viewcode-block" id="CustomTransform.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CustomTransform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the transform functions to the given maps object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict, or FieldArray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or FieldArray</span>
<span class="sd">            A map object containing the transformed variables, along with the</span>
<span class="sd">            original variables. The type of the output will be the same as the</span>
<span class="sd">            input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_functions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no transform function(s) provided&quot;</span><span class="p">)</span>
        <span class="c1"># copy values to scratch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copytoscratch</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
        <span class="c1"># ensure that we return the same data type in each dict</span>
        <span class="n">getslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getslice</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
        <span class="c1"># evaluate the functions</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scratch</span><span class="p">[</span><span class="n">func</span><span class="p">][</span><span class="n">getslice</span><span class="p">]</span>
               <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="CustomTransform.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CustomTransform.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no jacobian provided&quot;</span><span class="p">)</span>
        <span class="c1"># copy values to scratch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copytoscratch</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scratch</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_jacobian</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_getslice</span><span class="p">(</span><span class="n">maps</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="CustomTransform.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CustomTransform.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads a CustomTransform from the given config file.</span>

<span class="sd">        Example section:</span>

<span class="sd">        .. code-block:: ini</span>

<span class="sd">            [{section}-outvar1+outvar2]</span>
<span class="sd">            name = custom</span>
<span class="sd">            inputs = inputvar1, inputvar2</span>
<span class="sd">            outvar1 = func1(inputs)</span>
<span class="sd">            outvar2 = func2(inputs)</span>
<span class="sd">            jacobian = func(inputs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">VARARGS_DELIM</span><span class="p">))</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span>
                     <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>
        <span class="c1"># get the functions for each output</span>
        <span class="n">transform_functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="c1"># check if option can be cast as a float</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
            <span class="n">transform_functions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">tag</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;jacobian&#39;</span><span class="p">):</span>
            <span class="n">jacobian</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s1">&#39;jacobian&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jacobian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">transform_functions</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="n">jacobian</span><span class="p">)</span></div></div>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                             Forward Transforms</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>

<div class="viewcode-block" id="MchirpQToMass1Mass2"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpQToMass1Mass2">[docs]</a><span class="k">class</span> <span class="nc">MchirpQToMass1Mass2</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts chirp mass and mass ratio to component masses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mchirp_q_to_mass1_mass2&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass1_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mass2_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mchirp_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">q_param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mass1_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass1_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span>
        <span class="k">if</span> <span class="n">mass2_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass2_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span>
        <span class="k">if</span> <span class="n">mchirp_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mchirp_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span>
        <span class="k">if</span> <span class="n">q_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span> <span class="o">=</span> <span class="n">mass1_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span> <span class="o">=</span> <span class="n">mass2_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span> <span class="o">=</span> <span class="n">mchirp_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_param</span> <span class="o">=</span> <span class="n">q_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MchirpQToMass1Mass2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="MchirpQToMass1Mass2.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpQToMass1Mass2.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from chirp mass and mass ratio to component</span>
<span class="sd">        masses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.MchirpQToMass1Mass2()</span>
<span class="sd">        &gt;&gt;&gt; t.transform({&#39;mchirp&#39;: numpy.array([10.]), &#39;q&#39;: numpy.array([2.])})</span>
<span class="sd">        {&#39;mass1&#39;: array([ 16.4375183]), &#39;mass2&#39;: array([ 8.21875915]),</span>
<span class="sd">         &#39;mchirp&#39;: array([ 10.]), &#39;q&#39;: array([ 2.])}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass1_from_mchirp_q</span><span class="p">(</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">],</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass2_from_mchirp_q</span><span class="p">(</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">],</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MchirpQToMass1Mass2.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpQToMass1Mass2.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from component masses to chirp mass and</span>
<span class="sd">        mass ratio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.MchirpQToMass1Mass2()</span>
<span class="sd">        &gt;&gt;&gt; t.inverse_transform({&#39;mass1&#39;: numpy.array([16.4]), &#39;mass2&#39;: numpy.array([8.2])})</span>
<span class="sd">            {&#39;mass1&#39;: array([ 16.4]), &#39;mass2&#39;: array([ 8.2]),</span>
<span class="sd">             &#39;mchirp&#39;: array([ 9.97717521]), &#39;q&#39;: 2.0}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span><span class="p">]</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mchirp_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">/</span> <span class="n">m2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MchirpQToMass1Mass2.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpQToMass1Mass2.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming mchirp and q to mass1 and</span>
<span class="sd">        mass2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mchirp</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mchirp</span> <span class="o">*</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="n">q</span><span class="o">**</span><span class="mf">3.</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span></div>

<div class="viewcode-block" id="MchirpQToMass1Mass2.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpQToMass1Mass2.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming mass1 and mass2 to</span>
<span class="sd">        mchirp and q.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span><span class="p">]</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mchirp_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span><span class="o">/</span><span class="n">m2</span><span class="o">**</span><span class="mf">2.</span></div></div>


<div class="viewcode-block" id="MchirpEtaToMass1Mass2"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpEtaToMass1Mass2">[docs]</a><span class="k">class</span> <span class="nc">MchirpEtaToMass1Mass2</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts chirp mass and symmetric mass ratio to component masses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mchirp_eta_to_mass1_mass2&quot;</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span>

<div class="viewcode-block" id="MchirpEtaToMass1Mass2.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpEtaToMass1Mass2.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from chirp mass and symmetric mass ratio to</span>
<span class="sd">        component masses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.MchirpEtaToMass1Mass2()</span>
<span class="sd">        &gt;&gt;&gt; t.transform({&#39;mchirp&#39;: numpy.array([10.]), &#39;eta&#39;: numpy.array([0.25])})</span>
<span class="sd">        {&#39;mass1&#39;: array([ 16.4375183]), &#39;mass2&#39;: array([ 8.21875915]),</span>
<span class="sd">         &#39;mchirp&#39;: array([ 10.]), &#39;eta&#39;: array([ 0.25])}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass1_from_mchirp_eta</span><span class="p">(</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">],</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass2_from_mchirp_eta</span><span class="p">(</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">],</span>
                                                <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MchirpEtaToMass1Mass2.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpEtaToMass1Mass2.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from component masses to chirp mass and</span>
<span class="sd">        symmetric mass ratio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.MchirpQToMass1Mass2()</span>
<span class="sd">        &gt;&gt;&gt; t.inverse_transform({&#39;mass1&#39;: numpy.array([8.2]), &#39;mass2&#39;: numpy.array([8.2])})</span>
<span class="sd">            {&#39;mass1&#39;: array([ 8.2]), &#39;mass2&#39;: array([ 8.2]),</span>
<span class="sd">             &#39;mchirp&#39;: array([ 9.97717521]), &#39;eta&#39;: 0.25}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">]</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mchirp_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">eta_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MchirpEtaToMass1Mass2.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpEtaToMass1Mass2.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming mchirp and eta to mass1 and</span>
<span class="sd">        mass2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mchirp</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">]</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">]</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass1_from_mchirp_eta</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mass2_from_mchirp_eta</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mchirp</span> <span class="o">*</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span></div>

<div class="viewcode-block" id="MchirpEtaToMass1Mass2.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.MchirpEtaToMass1Mass2.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming mass1 and mass2 to</span>
<span class="sd">        mchirp and eta.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">]</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span>
        <span class="n">mchirp</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mchirp_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">eta_from_mass1_mass2</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">mchirp</span> <span class="o">/</span> <span class="n">eta</span><span class="o">**</span><span class="p">(</span><span class="mf">6.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="ChirpDistanceToDistance"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChirpDistanceToDistance">[docs]</a><span class="k">class</span> <span class="nc">ChirpDistanceToDistance</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts chirp distance to luminosity distance, given the chirp mass.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;chirp_distance_to_distance&quot;</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chirp_distance</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_mass</span><span class="o">=</span><span class="mf">1.4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_mass</span> <span class="o">=</span> <span class="n">ref_mass</span>

<div class="viewcode-block" id="ChirpDistanceToDistance.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChirpDistanceToDistance.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from chirp distance to luminosity distance,</span>
<span class="sd">        given the chirp mass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.ChirpDistanceToDistance()</span>
<span class="sd">        &gt;&gt;&gt; t.transform({&#39;chirp_distance&#39;: np.array([40.]), &#39;mchirp&#39;: np.array([1.2])})</span>
<span class="sd">        {&#39;mchirp&#39;: array([ 1.2]), &#39;chirp_distance&#39;: array([ 40.]), &#39;distance&#39;: array([ 39.48595679])}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">conversions</span><span class="o">.</span><span class="n">distance_from_chirp_distance_mchirp</span><span class="p">(</span>
                                                    <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chirp_distance</span><span class="p">],</span>
                                                    <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">],</span>
                                                    <span class="n">ref_mass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_mass</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpDistanceToDistance.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChirpDistanceToDistance.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from luminosity distance to chirp distance,</span>
<span class="sd">        given the chirp mass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.ChirpDistanceToDistance()</span>
<span class="sd">        &gt;&gt;&gt; t.inverse_transform({&#39;distance&#39;: np.array([40.]), &#39;mchirp&#39;: np.array([1.2])})</span>
<span class="sd">        {&#39;distance&#39;: array([ 40.]), &#39;chirp_distance&#39;: array([ 40.52073522]), &#39;mchirp&#39;: array([ 1.2])}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chirp_distance</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">conversions</span><span class="o">.</span><span class="n">chirp_distance</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">],</span>
                                            <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">],</span> <span class="n">ref_mass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_mass</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpDistanceToDistance.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChirpDistanceToDistance.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming chirp distance to</span>
<span class="sd">        luminosity distance, given the chirp mass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_mass</span><span class="o">=</span><span class="mf">1.4</span>
        <span class="n">mchirp</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="s1">&#39;mchirp&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_mass</span> <span class="o">/</span> <span class="n">mchirp</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">5.</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpDistanceToDistance.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChirpDistanceToDistance.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jacobian for transforming luminosity distance to</span>
<span class="sd">        chirp distance, given the chirp mass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_mass</span><span class="o">=</span><span class="mf">1.4</span>
        <span class="n">mchirp</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="s1">&#39;mchirp&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_mass</span> <span class="o">/</span> <span class="n">mchirp</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">5.</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SphericalToCartesian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.SphericalToCartesian">[docs]</a><span class="k">class</span> <span class="nc">SphericalToCartesian</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts spherical coordinates to cartesian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : str</span>
<span class="sd">        The name of the x parameter.</span>
<span class="sd">    y : str</span>
<span class="sd">        The name of the y parameter.</span>
<span class="sd">    z : str</span>
<span class="sd">        The name of the z parameter.</span>
<span class="sd">    radial : str</span>
<span class="sd">        The name of the radial parameter.</span>
<span class="sd">    azimuthal : str</span>
<span class="sd">        The name of the azimuthal angle parameter.</span>
<span class="sd">    polar : str</span>
<span class="sd">        The name of the polar angle parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;spherical_to_cartesian&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">radial</span><span class="p">,</span> <span class="n">azimuthal</span><span class="p">,</span> <span class="n">polar</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="o">=</span> <span class="n">radial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal</span> <span class="o">=</span> <span class="n">azimuthal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalToCartesian</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="SphericalToCartesian.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.SphericalToCartesian.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from spherical to cartesian spins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.SphericalToCartesian(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;,</span>
<span class="sd">                                                &#39;a&#39;, &#39;phi&#39;, &#39;theta&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t.transform({&#39;a&#39;: numpy.array([0.1]), &#39;phi&#39;: numpy.array([0.1]),</span>
<span class="sd">                        &#39;theta&#39;: numpy.array([0.1])})</span>
<span class="sd">            {&#39;a&#39;: array([ 0.1]), &#39;phi&#39;: array([ 0.1]), &#39;theta&#39;: array([ 0.1]),</span>
<span class="sd">             &#39;x&#39;: array([ 0.00993347]), &#39;y&#39;: array([ 0.00099667]),</span>
<span class="sd">             &#39;z&#39;: array([ 0.09950042])}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span>
        <span class="n">az</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal</span>
        <span class="n">po</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">spherical_to_cartesian</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">az</span><span class="p">],</span>
                                                     <span class="n">maps</span><span class="p">[</span><span class="n">po</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalToCartesian.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.SphericalToCartesian.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function transforms from cartesian to spherical spins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">po</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">y</span><span class="p">],</span>
                                                       <span class="n">maps</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal</span><span class="p">:</span> <span class="n">az</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">:</span> <span class="n">po</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SphericalSpin1ToCartesianSpin1"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.SphericalSpin1ToCartesianSpin1">[docs]</a><span class="k">class</span> <span class="nc">SphericalSpin1ToCartesianSpin1</span><span class="p">(</span><span class="n">SphericalToCartesian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts spherical spin parameters (radial and two angles) to</span>
<span class="sd">    catesian spin parameters. This class only transforms spsins for the first</span>
<span class="sd">    component mass.</span>

<span class="sd">    **Deprecation Warning:** This will be removed in a future update. Use</span>
<span class="sd">    :py:class:`SphericalToCartesian` with spin-parameter names passed in</span>
<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;spherical_spin_1_to_cartesian_spin_1&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: the </span><span class="si">{}</span><span class="s2"> transform will be &quot;</span>
                        <span class="s2">&quot;removed in a future update. Please use </span><span class="si">{}</span><span class="s2"> instead, &quot;</span>
                        <span class="s2">&quot;passing spin1x, spin1y, spin1z, spin1_a, &quot;</span>
                        <span class="s2">&quot;spin1_azimuthal, spin1_polar as arguments.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">SphericalToCartesian</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalSpin1ToCartesianSpin1</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;spin1x&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1y&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1z&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1_a&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1_azimuthal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spin1_polar&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SphericalSpin2ToCartesianSpin2"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.SphericalSpin2ToCartesianSpin2">[docs]</a><span class="k">class</span> <span class="nc">SphericalSpin2ToCartesianSpin2</span><span class="p">(</span><span class="n">SphericalToCartesian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts spherical spin parameters (radial and two angles) to</span>
<span class="sd">    catesian spin parameters. This class only transforms spsins for the first</span>
<span class="sd">    component mass.</span>

<span class="sd">    **Deprecation Warning:** This will be removed in a future update. Use</span>
<span class="sd">    :py:class:`SphericalToCartesian` with spin-parameter names passed in</span>
<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;spherical_spin_2_to_cartesian_spin_2&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: the </span><span class="si">{}</span><span class="s2"> transform will be &quot;</span>
                        <span class="s2">&quot;removed in a future update. Please use </span><span class="si">{}</span><span class="s2"> instead, &quot;</span>
                        <span class="s2">&quot;passing spin2x, spin2y, spin2z, spin2_a, &quot;</span>
                        <span class="s2">&quot;spin2_azimuthal, spin2_polar as arguments.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">SphericalToCartesian</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalSpin2ToCartesianSpin2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;spin2x&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2y&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2z&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2_a&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2_azimuthal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spin2_polar&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DistanceToRedshift"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.DistanceToRedshift">[docs]</a><span class="k">class</span> <span class="nc">DistanceToRedshift</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts distance to redshift.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;distance_to_redshift&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">redshift</span><span class="p">]</span>

<div class="viewcode-block" id="DistanceToRedshift.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.DistanceToRedshift.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from distance to redshift.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from pycbc import transforms</span>
<span class="sd">        &gt;&gt;&gt; t = transforms.DistanceToRedshift()</span>
<span class="sd">        &gt;&gt;&gt; t.transform({&#39;distance&#39;: numpy.array([1000])})</span>
<span class="sd">            {&#39;distance&#39;: array([1000]), &#39;redshift&#39;: 0.19650987609144363}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">parameters</span><span class="o">.</span><span class="n">redshift</span> <span class="p">:</span> <span class="n">cosmology</span><span class="o">.</span><span class="n">redshift</span><span class="p">(</span>
                                                    <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">])}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AlignedMassSpinToCartesianSpin"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.AlignedMassSpinToCartesianSpin">[docs]</a><span class="k">class</span> <span class="nc">AlignedMassSpinToCartesianSpin</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts mass-weighted spins to cartesian z-axis spins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;aligned_mass_spin_to_cartesian_spin&quot;</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">,</span> <span class="s2">&quot;chi_a&quot;</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span>
               <span class="n">parameters</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2z</span><span class="p">]</span>

<div class="viewcode-block" id="AlignedMassSpinToCartesianSpin.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.AlignedMassSpinToCartesianSpin.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from aligned mass-weighted spins to</span>
<span class="sd">        cartesian spins aligned along the z-axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mass1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">]</span>
        <span class="n">mass2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1z</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="n">conversions</span><span class="o">.</span><span class="n">spin1z_from_mass1_mass2_chi_eff_chi_a</span><span class="p">(</span>
                               <span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span><span class="p">,</span>
                               <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;chi_a&quot;</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2z</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="n">conversions</span><span class="o">.</span><span class="n">spin2z_from_mass1_mass2_chi_eff_chi_a</span><span class="p">(</span>
                               <span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span><span class="p">,</span>
                               <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;chi_a&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignedMassSpinToCartesianSpin.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.AlignedMassSpinToCartesianSpin.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from component masses and cartesian spins</span>
<span class="sd">        to mass-weighted spin parameters aligned with the angular momentum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mass1</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">]</span>
        <span class="n">spin1z</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1z</span><span class="p">]</span>
        <span class="n">mass2</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]</span>
        <span class="n">spin2z</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2z</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">chi_eff</span> <span class="p">:</span> <span class="n">conversions</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">(</span><span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span><span class="p">,</span>
                                                     <span class="n">spin1z</span><span class="p">,</span> <span class="n">spin2z</span><span class="p">),</span>
            <span class="s2">&quot;chi_a&quot;</span> <span class="p">:</span> <span class="n">conversions</span><span class="o">.</span><span class="n">chi_a</span><span class="p">(</span><span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span><span class="p">,</span> <span class="n">spin1z</span><span class="p">,</span> <span class="n">spin2z</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PrecessionMassSpinToCartesianSpin"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.PrecessionMassSpinToCartesianSpin">[docs]</a><span class="k">class</span> <span class="nc">PrecessionMassSpinToCartesianSpin</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts mass-weighted spins to cartesian x-y plane spins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;precession_mass_spin_to_cartesian_spin&quot;</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span>
               <span class="s2">&quot;xi1&quot;</span><span class="p">,</span> <span class="s2">&quot;xi2&quot;</span><span class="p">,</span> <span class="s2">&quot;phi_a&quot;</span><span class="p">,</span> <span class="s2">&quot;phi_s&quot;</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">]</span>

<div class="viewcode-block" id="PrecessionMassSpinToCartesianSpin.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.PrecessionMassSpinToCartesianSpin.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from mass-weighted spins to caretsian spins</span>
<span class="sd">        in the x-y plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># find primary and secondary masses</span>
        <span class="c1"># since functions in conversions.py map to primary/secondary masses</span>
        <span class="n">m_p</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_mass</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">])</span>
        <span class="n">m_s</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_mass</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">])</span>

        <span class="c1"># find primary and secondary xi</span>
        <span class="c1"># can re-purpose spin functions for just a generic variable</span>
        <span class="n">xi_p</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_spin</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">],</span>
                                        <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;xi1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;xi2&quot;</span><span class="p">])</span>
        <span class="n">xi_s</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_spin</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">],</span>
                                          <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;xi1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;xi2&quot;</span><span class="p">])</span>

        <span class="c1"># convert using convention of conversions.py that is mass1 &gt; mass2</span>
        <span class="n">spinx_p</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">spin1x_from_xi1_phi_a_phi_s</span><span class="p">(</span>
                           <span class="n">xi_p</span><span class="p">,</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_a&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_s&quot;</span><span class="p">])</span>
        <span class="n">spiny_p</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">spin1y_from_xi1_phi_a_phi_s</span><span class="p">(</span>
                           <span class="n">xi_p</span><span class="p">,</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_a&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_s&quot;</span><span class="p">])</span>
        <span class="n">spinx_s</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">spin2x_from_mass1_mass2_xi2_phi_a_phi_s</span><span class="p">(</span>
                           <span class="n">m_p</span><span class="p">,</span> <span class="n">m_s</span><span class="p">,</span> <span class="n">xi_s</span><span class="p">,</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_a&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_s&quot;</span><span class="p">])</span>
        <span class="n">spiny_s</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">spin2y_from_mass1_mass2_xi2_phi_a_phi_s</span><span class="p">(</span>
                           <span class="n">m_p</span><span class="p">,</span> <span class="n">m_s</span><span class="p">,</span> <span class="n">xi_s</span><span class="p">,</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_a&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;phi_s&quot;</span><span class="p">])</span>

        <span class="c1"># map parameters from primary/secondary to indices</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_p</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="p">[</span><span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">]])</span>
            <span class="n">mask_mass1_gte_mass2</span> <span class="o">=</span> <span class="n">mass1</span> <span class="o">&gt;=</span> <span class="n">mass2</span>
            <span class="n">mask_mass1_lt_mass2</span> <span class="o">=</span> <span class="n">mass1</span> <span class="o">&lt;</span> <span class="n">mass2</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">spinx_p</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">],</span>
                                        <span class="n">spinx_s</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">]))</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">spiny_p</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">],</span>
                                        <span class="n">spiny_s</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">]))</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">spinx_p</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">],</span>
                                        <span class="n">spinx_s</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">]))</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">spinx_p</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">],</span>
                                        <span class="n">spinx_s</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">]:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">]</span> <span class="o">=</span> <span class="n">spinx_p</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">]</span> <span class="o">=</span> <span class="n">spiny_p</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">]</span> <span class="o">=</span> <span class="n">spinx_s</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">]</span> <span class="o">=</span> <span class="n">spiny_s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">]</span> <span class="o">=</span> <span class="n">spinx_s</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">]</span> <span class="o">=</span> <span class="n">spiny_s</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">]</span> <span class="o">=</span> <span class="n">spinx_p</span>
            <span class="n">out</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">]</span> <span class="o">=</span> <span class="n">spiny_p</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrecessionMassSpinToCartesianSpin.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.PrecessionMassSpinToCartesianSpin.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from component masses and cartesian spins to</span>
<span class="sd">        mass-weighted spin parameters perpendicular with the angular momentum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xi1</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_xi</span><span class="p">(</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">])</span>
        <span class="n">xi2</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_xi</span><span class="p">(</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;phi_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">phi_a</span><span class="p">(</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;phi_s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">phi_s</span><span class="p">(</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">])</span>

        <span class="c1"># map parameters from primary/secondary to indices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xi1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">mass1</span><span class="p">,</span> <span class="n">mass2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="p">[</span><span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">],</span>
                                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">]])</span>
            <span class="n">mask_mass1_gte_mass2</span> <span class="o">=</span> <span class="n">mass1</span> <span class="o">&gt;=</span> <span class="n">mass2</span>
            <span class="n">mask_mass1_lt_mass2</span> <span class="o">=</span> <span class="n">mass1</span> <span class="o">&lt;</span> <span class="n">mass2</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">xi1</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">],</span>
                                        <span class="n">xi2</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">]))</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                                        <span class="n">xi1</span><span class="p">[</span><span class="n">mask_mass1_gte_mass2</span><span class="p">],</span>
                                        <span class="n">xi2</span><span class="p">[</span><span class="n">mask_mass1_lt_mass2</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass1&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maps</span><span class="p">[</span><span class="s2">&quot;mass2&quot;</span><span class="p">]:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi1</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi2</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;xi2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CartesianSpinToChiP"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpinToChiP">[docs]</a><span class="k">class</span> <span class="nc">CartesianSpinToChiP</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts cartesian spins to `chi_p`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_to_chi_p&quot;</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chi_p&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="CartesianSpinToChiP.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpinToChiP.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function transforms from component masses and caretsian spins</span>
<span class="sd">        to chi_p.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : a mapping object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a dict of numpy.array:</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict</span>
<span class="sd">            A dict with key as parameter name and value as numpy.array or float</span>
<span class="sd">            of transformed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;chi_p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conversions</span><span class="o">.</span><span class="n">chi_p</span><span class="p">(</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">],</span>
                             <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">],</span> <span class="n">maps</span><span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LambdaFromTOVFile"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromTOVFile">[docs]</a><span class="k">class</span> <span class="nc">LambdaFromTOVFile</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transforms mass values corresponding to Lambda values for a given EOS</span>
<span class="sd">    interpolating from the mass-Lambda data for that EOS read in from an</span>
<span class="sd">    external ASCII file.</span>

<span class="sd">    The interpolation of the mass-Lambda data is a one-dimensional piecewise</span>
<span class="sd">    linear interpolation. If the ``redshift_mass`` keyword argument is ``True``</span>
<span class="sd">    (the default), the mass values to be transformed are assumed to be detector</span>
<span class="sd">    frame masses. In that case, a distance should be provided along with the</span>
<span class="sd">    mass for transformation to the source frame mass before the Lambda values</span>
<span class="sd">    are extracted from the interpolation. If the transform is read in from a</span>
<span class="sd">    config file, an example code block would be:</span>

<span class="sd">    .. code-block:: ini</span>

<span class="sd">        [{section}-lambda1]</span>
<span class="sd">        name = lambda_from_tov_file</span>
<span class="sd">        mass_param = mass1</span>
<span class="sd">        lambda_param = lambda1</span>
<span class="sd">        distance = 40</span>
<span class="sd">        mass_lambda_file = {filepath}</span>

<span class="sd">    If this transform is used in a parameter estimation analysis where</span>
<span class="sd">    distance is a variable parameter, the distance to be used will vary</span>
<span class="sd">    with each draw. In that case, the example code block will be:</span>

<span class="sd">    .. code-block:: ini</span>

<span class="sd">        [{section}-lambda1]</span>
<span class="sd">        name = lambda_from_tov_file</span>
<span class="sd">        mass_param = mass1</span>
<span class="sd">        lambda_param = lambda1</span>
<span class="sd">        mass_lambda_file = filepath</span>

<span class="sd">    If your prior is in terms of the source-frame masses (``srcmass``), then</span>
<span class="sd">    you can shut off the redshifting by adding ``do-not-redshift-mass`` to the</span>
<span class="sd">    config file. In this case you do not need to worry about a distance.</span>
<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: ini</span>

<span class="sd">        [{section}-lambda1]</span>
<span class="sd">        name = lambda_from_tov_file</span>
<span class="sd">        mass_param = srcmass1</span>
<span class="sd">        lambda_param = lambda1</span>
<span class="sd">        mass_lambda_file = filepath</span>
<span class="sd">        do-not-redshift-mass =</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mass_param : str</span>
<span class="sd">        The name of the mass parameter to transform.</span>
<span class="sd">    lambda_param : str</span>
<span class="sd">        The name of the tidal deformability parameter that mass_param is to</span>
<span class="sd">        be converted to interpolating from the data in the mass-Lambda file.</span>
<span class="sd">    mass_lambda_file : str</span>
<span class="sd">        Path of the mass-Lambda data file. The first column in the data file</span>
<span class="sd">        should contain mass values, and the second column Lambda values.</span>
<span class="sd">    distance : float, optional</span>
<span class="sd">        The distance (in Mpc) of the source. Used to redshift the mass. Needed</span>
<span class="sd">        if ``redshift_mass`` is True and no distance parameter exists If</span>
<span class="sd">        None, then a distance must be provided to the transform.</span>
<span class="sd">    redshift_mass : bool, optional</span>
<span class="sd">        Redshift the mass parameters when computing the lambdas. Default is</span>
<span class="sd">        False.</span>
<span class="sd">    file_columns : list of str, optional</span>
<span class="sd">        The names and order of columns in the ``mass_lambda_file``. Must</span>
<span class="sd">        contain at least &#39;mass&#39; and &#39;lambda&#39;. If not provided, will assume the</span>
<span class="sd">        order is (&#39;mass&#39;, &#39;lambda&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;lambda_from_tov_file&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass_param</span><span class="p">,</span> <span class="n">lambda_param</span><span class="p">,</span> <span class="n">mass_lambda_file</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_mass</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">file_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass_lambda_file</span> <span class="o">=</span> <span class="n">mass_lambda_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span> <span class="o">=</span> <span class="n">mass_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span> <span class="o">=</span> <span class="n">lambda_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift_mass</span> <span class="o">=</span> <span class="n">redshift_mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mass_param</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lambda_param</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">file_columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda&#39;</span><span class="p">]</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">file_columns</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mass_lambda_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LambdaFromTOVFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the input mass parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lambda_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the output lambda parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the mass data read from the mass-Lambda data file for</span>
<span class="sd">        an EOS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lambda_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Lambda data read from the mass-Lambda data file for</span>
<span class="sd">        an EOS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fixed distance to transform mass samples from detector</span>
<span class="sd">        to source frame if one is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="LambdaFromTOVFile.lambda_from_tov_data"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromTOVFile.lambda_from_tov_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">lambda_from_tov_data</span><span class="p">(</span><span class="n">m_src</span><span class="p">,</span> <span class="n">mass_data</span><span class="p">,</span> <span class="n">lambda_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Lambda corresponding to a given mass interpolating from the</span>
<span class="sd">        TOV data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : float</span>
<span class="sd">            Value of the mass.</span>
<span class="sd">        mass_data : array</span>
<span class="sd">            Mass array from the Lambda-M curve of an EOS.</span>
<span class="sd">        lambda_data : array</span>
<span class="sd">            Lambda array from the Lambda-M curve of an EOS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lambdav : float</span>
<span class="sd">            The Lambda corresponding to the mass `m` for the EOS considered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">m_src</span> <span class="o">&gt;</span> <span class="n">mass_data</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="c1"># assume black hole</span>
            <span class="n">lambdav</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lambdav</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">m_src</span><span class="p">,</span> <span class="n">mass_data</span><span class="p">,</span> <span class="n">lambda_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lambdav</span></div>

<div class="viewcode-block" id="LambdaFromTOVFile.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromTOVFile.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the transformation of mass to Lambda.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict or FieldArray</span>
<span class="sd">            A map between the transformed variable name and value(s), along</span>
<span class="sd">            with the original variable name and value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_mass</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Either provide distance samples in the &quot;</span>
                                    <span class="s2">&quot;list of samples to be transformed, or &quot;</span>
                                    <span class="s2">&quot;provide a fixed distance value as input &quot;</span>
                                    <span class="s2">&quot;when initializing LambdaFromTOVFile.&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">cosmology</span><span class="o">.</span><span class="n">redshift</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_from_tov_data</span><span class="p">(</span>
            <span class="n">m</span><span class="o">*</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">])}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="LambdaFromTOVFile.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromTOVFile.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="c1"># see if we&#39;re redshifting masses</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">]),</span> <span class="s1">&#39;do-not-redshift-mass&#39;</span><span class="p">):</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;redshift_mass&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;do-not-redshift-mass&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">LambdaFromTOVFile</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span>
            <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="o">=</span><span class="n">skip_opts</span><span class="p">,</span>
            <span class="n">additional_opts</span><span class="o">=</span><span class="n">additional_opts</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LambdaFromMultipleTOVFiles"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromMultipleTOVFiles">[docs]</a><span class="k">class</span> <span class="nc">LambdaFromMultipleTOVFiles</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses multiple equation of states.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mass_param : str</span>
<span class="sd">        The name of the mass parameter to transform.</span>
<span class="sd">    lambda_param : str</span>
<span class="sd">        The name of the tidal deformability parameter that mass_param is to</span>
<span class="sd">        be converted to interpolating from the data in the mass-Lambda file.</span>
<span class="sd">    mass_lambda_file : str</span>
<span class="sd">        Path of the mass-Lambda data file. The first column in the data file</span>
<span class="sd">        should contain mass values, and the second column Lambda values.</span>
<span class="sd">    distance : float, optional</span>
<span class="sd">        The distance (in Mpc) of the source. Used to redshift the mass. If</span>
<span class="sd">        None, then a distance must be provided to the transform.</span>
<span class="sd">    file_columns : list of str, optional</span>
<span class="sd">        The names and order of columns in the ``mass_lambda_file``. Must</span>
<span class="sd">        contain at least &#39;mass&#39; and &#39;lambda&#39;. If not provided, will assume the</span>
<span class="sd">        order is (&#39;radius&#39;, &#39;mass&#39;, &#39;lambda&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;lambda_from_multiple_tov_files&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass_param</span><span class="p">,</span> <span class="n">lambda_param</span><span class="p">,</span> <span class="n">map_file</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">redshift_mass</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">file_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_file</span> <span class="o">=</span> <span class="n">map_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span> <span class="o">=</span> <span class="n">mass_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span> <span class="o">=</span> <span class="n">lambda_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift_mass</span> <span class="o">=</span> <span class="n">redshift_mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mass_param</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lambda_param</span><span class="p">]</span>
        <span class="c1"># create a dictionary of the EOS files from the map_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eos_files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">eosidx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eos_files</span><span class="p">[</span><span class="n">eosidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1"># create an eos cache for fast load later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eos_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">file_columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_columns</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_columns</span> <span class="o">=</span> <span class="n">file_columns</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LambdaFromMultipleTOVFiles</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the input mass parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lambda_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the output lambda parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the mass data read from the mass-Lambda data file for</span>
<span class="sd">        an EOS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_file</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the fixed distance to transform mass samples from detector</span>
<span class="sd">        to source frame if one is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="LambdaFromMultipleTOVFiles.get_eos"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromMultipleTOVFiles.get_eos">[docs]</a>    <span class="k">def</span> <span class="nf">get_eos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eos_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets the EOS for the given index.</span>

<span class="sd">        If the index is not in range returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eos_cache</span><span class="p">[</span><span class="n">eos_index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eos_files</span><span class="p">[</span><span class="n">eos_index</span><span class="p">]</span>
                <span class="n">eos</span> <span class="o">=</span> <span class="n">LambdaFromTOVFile</span><span class="p">(</span><span class="n">mass_param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span><span class="p">,</span>
                                        <span class="n">lambda_param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span><span class="p">,</span>
                                        <span class="n">mass_lambda_file</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
                                        <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">,</span>
                                        <span class="n">redshift_mass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift_mass</span><span class="p">,</span>
                                        <span class="n">file_columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_columns</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eos_cache</span><span class="p">[</span><span class="n">eos_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">eos</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">eos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">eos</span></div>

<div class="viewcode-block" id="LambdaFromMultipleTOVFiles.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromMultipleTOVFiles.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms mass value and eos index into a lambda value &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mass_param</span><span class="p">]</span>
        <span class="c1"># floor</span>
        <span class="n">eos_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="s1">&#39;eos&#39;</span><span class="p">])</span>
        <span class="n">eos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_eos</span><span class="p">(</span><span class="n">eos_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eos</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no eos, just return nan</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lambda_param</span> <span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="LambdaFromMultipleTOVFiles.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.LambdaFromMultipleTOVFiles.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="c1"># see if we&#39;re redshifting masses</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">]),</span> <span class="s1">&#39;do-not-redshift-mass&#39;</span><span class="p">):</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;redshift_mass&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;do-not-redshift-mass&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">LambdaFromMultipleTOVFiles</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span>
            <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="o">=</span><span class="n">skip_opts</span><span class="p">,</span>
            <span class="n">additional_opts</span><span class="o">=</span><span class="n">additional_opts</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Log"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Log">[docs]</a><span class="k">class</span> <span class="nc">Log</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a log transform from an `inputvar` parameter to an `outputvar`</span>
<span class="sd">    parameter. This is the inverse of the exponent transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputvar : str</span>
<span class="sd">        The name of the parameter to transform.</span>
<span class="sd">    outputvar : str</span>
<span class="sd">        The name of the transformed parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;log&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">,</span> <span class="n">outputvar</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span> <span class="o">=</span> <span class="n">inputvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span> <span class="o">=</span> <span class="n">outputvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputvar</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputvar</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Log</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the input parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the output parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span>

<div class="viewcode-block" id="Log.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Log.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes :math:`\log(x)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict or FieldArray</span>
<span class="sd">            A map between the transformed variable name and value(s), along</span>
<span class="sd">            with the original variable name and value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span> <span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Log.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Log.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes :math:`y = e^{x}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict or FieldArray</span>
<span class="sd">            A map between the transformed variable name and value(s), along</span>
<span class="sd">            with the original variable name and value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span> <span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Log.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Log.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the Jacobian of :math:`y = \log(x)`.</span>

<span class="sd">        This is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\mathrm{d}y}{\mathrm{d}x} = \frac{1}{x}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the jacobian at the given point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span><span class="p">]</span>
        <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">x</span></div>

<div class="viewcode-block" id="Log.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Log.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the Jacobian of :math:`y = e^{x}`.</span>

<span class="sd">        This is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\mathrm{d}y}{\mathrm{d}x} = e^{x}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the jacobian at the given point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Logit"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit">[docs]</a><span class="k">class</span> <span class="nc">Logit</span><span class="p">(</span><span class="n">BaseTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a logit transform from an `inputvar` parameter to an `outputvar`</span>
<span class="sd">    parameter. This is the inverse of the logistic transform.</span>

<span class="sd">    Typically, the input of the logit function is assumed to have domain</span>
<span class="sd">    :math:`\in (0, 1)`. However, the `domain` argument can be used to expand</span>
<span class="sd">    this to any finite real interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputvar : str</span>
<span class="sd">        The name of the parameter to transform.</span>
<span class="sd">    outputvar : str</span>
<span class="sd">        The name of the transformed parameter.</span>
<span class="sd">    domain : tuple or distributions.bounds.Bounds, optional</span>
<span class="sd">        The domain of the input parameter. Can be any finite</span>
<span class="sd">        interval. Default is (0., 1.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;logit&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">,</span> <span class="n">outputvar</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span> <span class="o">=</span> <span class="n">inputvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span> <span class="o">=</span> <span class="n">outputvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputvar</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputvar</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">btype_min</span><span class="o">=</span><span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="n">btype_max</span><span class="o">=</span><span class="s1">&#39;open&#39;</span><span class="p">)</span>
        <span class="c1"># shortcuts for quick access later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Logit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the input parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the output parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the domain of the input parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

<div class="viewcode-block" id="Logit.logit"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.logit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">logit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the logit function with domain :math:`x \in (a, b)`.</span>

<span class="sd">        This is given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathrm{logit}(x; a, b) = \log\left(\frac{x-a}{b-x}\right).</span>

<span class="sd">        Note that this is also the inverse of the logistic function with range</span>
<span class="sd">        :math:`(a, b)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            The value to evaluate.</span>
<span class="sd">        a : float, optional</span>
<span class="sd">            The minimum bound of the domain of x. Default is 0.</span>
<span class="sd">        b : float, optional</span>
<span class="sd">            The maximum bound of the domain of x. Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The logit of x.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.logistic"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.logistic">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">logistic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the logistic function with range :math:`\in (a, b)`.</span>

<span class="sd">        This is given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathrm{logistic}(x; a, b) = \frac{a + b e^x}{1 + e^x}.</span>

<span class="sd">        Note that this is also the inverse of the logit function with domain</span>
<span class="sd">        :math:`(a, b)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            The value to evaluate.</span>
<span class="sd">        a : float, optional</span>
<span class="sd">            The minimum bound of the range of the logistic function. Default</span>
<span class="sd">            is 0.</span>
<span class="sd">        b : float, optional</span>
<span class="sd">            The maximum bound of the range of the logistic function. Default</span>
<span class="sd">            is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The logistic of x.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">expx</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">expx</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes :math:`\mathrm{logit}(x; a, b)`.</span>

<span class="sd">        The domain :math:`a, b` of :math:`x` are given by the class&#39;s bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict or FieldArray</span>
<span class="sd">            A map between the transformed variable name and value(s), along</span>
<span class="sd">            with the original variable name and value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span><span class="p">]</span>
        <span class="c1"># check that x is in bounds</span>
        <span class="n">isin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isin</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">isin</span> <span class="o">=</span> <span class="n">isin</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one or more values are not in bounds&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.inverse_transform"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes :math:`y = \mathrm{logistic}(x; a,b)`.</span>

<span class="sd">        The codomain :math:`a, b` of :math:`y` are given by the class&#39;s bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dict or FieldArray</span>
<span class="sd">            A map between the transformed variable name and value(s), along</span>
<span class="sd">            with the original variable name and value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logistic</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_output</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the Jacobian of :math:`y = \mathrm{logit}(x; a,b)`.</span>

<span class="sd">        This is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\mathrm{d}y}{\mathrm{d}x} = \frac{b -a}{(x-a)(b-x)},</span>

<span class="sd">        where :math:`x \in (a, b)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the jacobian at the given point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputvar</span><span class="p">]</span>
        <span class="c1"># check that x is in bounds</span>
        <span class="n">isin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isin</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isin</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one or more values are not in bounds&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not in bounds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span></div>

<div class="viewcode-block" id="Logit.inverse_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.inverse_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the Jacobian of :math:`y = \mathrm{logistic}(x; a,b)`.</span>

<span class="sd">        This is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\mathrm{d}y}{\mathrm{d}x} = \frac{e^x (b-a)}{(1+e^y)^2},</span>

<span class="sd">        where :math:`y \in (a, b)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maps : dict or FieldArray</span>
<span class="sd">            A dictionary or FieldArray which provides a map between the</span>
<span class="sd">            parameter name of the variable to transform and its value(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the jacobian at the given point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputvar</span><span class="p">]</span>
        <span class="n">expx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">expx</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span></div>

<div class="viewcode-block" id="Logit.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logit.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">additional_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes a Logit transform from the given section.</span>

<span class="sd">        The section must specify an input and output variable name. The domain</span>
<span class="sd">        of the input may be specified using `min-{input}`, `max-{input}`.</span>
<span class="sd">        Example:</span>

<span class="sd">        .. code-block:: ini</span>

<span class="sd">            [{section}-logitq]</span>
<span class="sd">            name = logit</span>
<span class="sd">            inputvar = q</span>
<span class="sd">            outputvar = logitq</span>
<span class="sd">            min-q = 1</span>
<span class="sd">            max-q = 8</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cp : pycbc.workflow.WorkflowConfigParser</span>
<span class="sd">            A parsed configuration file that contains the transform options.</span>
<span class="sd">        section : str</span>
<span class="sd">            Name of the section in the configuration file.</span>
<span class="sd">        outputs : str</span>
<span class="sd">            The names of the parameters that are output by this transformation,</span>
<span class="sd">            separated by `VARARGS_DELIM`. These must appear in the &quot;tag&quot; part</span>
<span class="sd">            of the section header.</span>
<span class="sd">        skip_opts : list, optional</span>
<span class="sd">            Do not read options in the given list.</span>
<span class="sd">        additional_opts : dict, optional</span>
<span class="sd">            Any additional arguments to pass to the class. If an option is</span>
<span class="sd">            provided that also exists in the config file, the value provided</span>
<span class="sd">            will be used instead of being read from the file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls</span>
<span class="sd">            An instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pull out the minimum, maximum values of the input variable</span>
        <span class="n">inputvar</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s1">&#39;inputvar&#39;</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">])</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="s1">&#39;min-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputvar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">additional_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="n">additional_opts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">opt</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="n">skip_opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="s1">&#39;max-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputvar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">opt</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="n">skip_opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if providing a min(max)-</span><span class="si">{}</span><span class="s2">, must also provide &quot;</span>
                             <span class="s2">&quot;a max(min)-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputvar</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_opts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">))})</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Logit</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="p">,</span>
                                             <span class="n">additional_opts</span><span class="p">)</span></div></div>

<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                             Inverse Transforms</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<div class="viewcode-block" id="Mass1Mass2ToMchirpQ"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Mass1Mass2ToMchirpQ">[docs]</a><span class="k">class</span> <span class="nc">Mass1Mass2ToMchirpQ</span><span class="p">(</span><span class="n">MchirpQToMass1Mass2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of MchirpQToMass1Mass2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mass1_mass2_to_mchirp_q&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">MchirpQToMass1Mass2</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass1_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mass2_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mchirp_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">q_param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mass1_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass1_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass1</span>
        <span class="k">if</span> <span class="n">mass2_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass2_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mass2</span>
        <span class="k">if</span> <span class="n">mchirp_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mchirp_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span>
        <span class="k">if</span> <span class="n">q_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q_param</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span> <span class="o">=</span> <span class="n">mass1_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span> <span class="o">=</span> <span class="n">mass2_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span> <span class="o">=</span> <span class="n">mchirp_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_param</span> <span class="o">=</span> <span class="n">q_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2_param</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mchirp_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_param</span><span class="p">]</span>
        <span class="n">BaseTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mass1Mass2ToMchirpEta"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Mass1Mass2ToMchirpEta">[docs]</a><span class="k">class</span> <span class="nc">Mass1Mass2ToMchirpEta</span><span class="p">(</span><span class="n">MchirpEtaToMass1Mass2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of MchirpEtaToMass1Mass2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mass1_mass2_to_mchirp_eta&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">MchirpEtaToMass1Mass2</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_outputs</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_inputs</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span></div>

<div class="viewcode-block" id="DistanceToChirpDistance"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.DistanceToChirpDistance">[docs]</a><span class="k">class</span> <span class="nc">DistanceToChirpDistance</span><span class="p">(</span><span class="n">ChirpDistanceToDistance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of ChirpDistanceToDistance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;distance_to_chirp_distance&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">ChirpDistanceToDistance</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">]</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="o">.</span><span class="n">chirp_distance</span><span class="p">]</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span></div>


<div class="viewcode-block" id="CartesianToSpherical"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianToSpherical">[docs]</a><span class="k">class</span> <span class="nc">CartesianToSpherical</span><span class="p">(</span><span class="n">SphericalToCartesian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts spherical coordinates to cartesian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : str</span>
<span class="sd">        The name of the x parameter.</span>
<span class="sd">    y : str</span>
<span class="sd">        The name of the y parameter.</span>
<span class="sd">    z : str</span>
<span class="sd">        The name of the z parameter.</span>
<span class="sd">    radial : str</span>
<span class="sd">        The name of the radial parameter.</span>
<span class="sd">    azimuthal : str</span>
<span class="sd">        The name of the azimuthal angle parameter.</span>
<span class="sd">    polar : str</span>
<span class="sd">        The name of the polar angle parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_to_spherical&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">SphericalToCartesian</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianToSpherical</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># swap inputs and outputs</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianSpin1ToSphericalSpin1"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpin1ToSphericalSpin1">[docs]</a><span class="k">class</span> <span class="nc">CartesianSpin1ToSphericalSpin1</span><span class="p">(</span><span class="n">CartesianToSpherical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of SphericalSpin1ToCartesianSpin1.</span>

<span class="sd">    **Deprecation Warning:** This will be removed in a future update. Use</span>
<span class="sd">    :py:class:`CartesianToSpherical` with spin-parameter names passed in</span>
<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_1_to_spherical_spin_1&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: the </span><span class="si">{}</span><span class="s2"> transform will be &quot;</span>
                        <span class="s2">&quot;removed in a future update. Please use </span><span class="si">{}</span><span class="s2"> instead, &quot;</span>
                        <span class="s2">&quot;passing spin1x, spin1y, spin1z, spin1_a, &quot;</span>
                        <span class="s2">&quot;spin1_azimuthal, spin1_polar as arguments.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">CartesianToSpherical</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianSpin1ToSphericalSpin1</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;spin1x&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1y&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1z&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1_a&quot;</span><span class="p">,</span> <span class="s2">&quot;spin1_azimuthal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spin1_polar&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianSpin2ToSphericalSpin2"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpin2ToSphericalSpin2">[docs]</a><span class="k">class</span> <span class="nc">CartesianSpin2ToSphericalSpin2</span><span class="p">(</span><span class="n">CartesianToSpherical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of SphericalSpin2ToCartesianSpin2.</span>

<span class="sd">    **Deprecation Warning:** This will be removed in a future update. Use</span>
<span class="sd">    :py:class:`CartesianToSpherical` with spin-parameter names passed in</span>
<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_2_to_spherical_spin_2&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: the </span><span class="si">{}</span><span class="s2"> transform will be &quot;</span>
                        <span class="s2">&quot;removed in a future update. Please use </span><span class="si">{}</span><span class="s2"> instead, &quot;</span>
                        <span class="s2">&quot;passing spin2x, spin2y, spin2z, spin2_a, &quot;</span>
                        <span class="s2">&quot;spin2_azimuthal, spin2_polar as arguments.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">CartesianToSpherical</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianSpin2ToSphericalSpin2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;spin2x&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2y&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2z&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2_a&quot;</span><span class="p">,</span> <span class="s2">&quot;spin2_azimuthal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spin2_polar&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianSpinToAlignedMassSpin"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpinToAlignedMassSpin">[docs]</a><span class="k">class</span> <span class="nc">CartesianSpinToAlignedMassSpin</span><span class="p">(</span><span class="n">AlignedMassSpinToCartesianSpin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of AlignedMassSpinToCartesianSpin.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_to_aligned_mass_spin&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">AlignedMassSpinToCartesianSpin</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_outputs</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_inputs</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span></div>


<div class="viewcode-block" id="CartesianSpinToPrecessionMassSpin"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.CartesianSpinToPrecessionMassSpin">[docs]</a><span class="k">class</span> <span class="nc">CartesianSpinToPrecessionMassSpin</span><span class="p">(</span><span class="n">PrecessionMassSpinToCartesianSpin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of PrecessionMassSpinToCartesianSpin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_to_precession_mass_spin&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">PrecessionMassSpinToCartesianSpin</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_outputs</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_inputs</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span></div>


<div class="viewcode-block" id="ChiPToCartesianSpin"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.ChiPToCartesianSpin">[docs]</a><span class="k">class</span> <span class="nc">ChiPToCartesianSpin</span><span class="p">(</span><span class="n">CartesianSpinToChiP</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of `CartesianSpinToChiP`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cartesian_spin_to_chi_p&quot;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpinToChiP</span>
    <span class="n">_inputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_outputs</span>
    <span class="n">_outputs</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">_inputs</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span></div>


<div class="viewcode-block" id="Exponent"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Exponent">[docs]</a><span class="k">class</span> <span class="nc">Exponent</span><span class="p">(</span><span class="n">Log</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies an exponent transform to an `inputvar` parameter.</span>

<span class="sd">    This is the inverse of the log transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputvar : str</span>
<span class="sd">        The name of the parameter to transform.</span>
<span class="sd">    outputvar : str</span>
<span class="sd">        The name of the transformed parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;exponent&#39;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">Log</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">,</span> <span class="n">outputvar</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Exponent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">outputvar</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">)</span></div>


<div class="viewcode-block" id="Logistic"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logistic">[docs]</a><span class="k">class</span> <span class="nc">Logistic</span><span class="p">(</span><span class="n">Logit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a logistic transform from an `input` parameter to an `output`</span>
<span class="sd">    parameter. This is the inverse of the logit transform.</span>

<span class="sd">    Typically, the output of the logistic function has range :math:`\in [0,1)`.</span>
<span class="sd">    However, the `codomain` argument can be used to expand this to any</span>
<span class="sd">    finite real interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputvar : str</span>
<span class="sd">        The name of the parameter to transform.</span>
<span class="sd">    outputvar : str</span>
<span class="sd">        The name of the transformed parameter.</span>
<span class="sd">    frange : tuple or distributions.bounds.Bounds, optional</span>
<span class="sd">        The range of the output parameter. Can be any finite</span>
<span class="sd">        interval. Default is (0., 1.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;logistic&#39;</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">Logit</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_transform</span>
    <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">transform</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">inverse_jacobian</span>
    <span class="n">inverse_jacobian</span> <span class="o">=</span> <span class="n">inverse</span><span class="o">.</span><span class="n">jacobian</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">,</span> <span class="n">outputvar</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Logistic</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">outputvar</span><span class="p">,</span> <span class="n">inputvar</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">codomain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the range of the output parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

<div class="viewcode-block" id="Logistic.from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.Logistic.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">skip_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">additional_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes a Logistic transform from the given section.</span>

<span class="sd">        The section must specify an input and output variable name. The</span>
<span class="sd">        codomain of the output may be specified using `min-{output}`,</span>
<span class="sd">        `max-{output}`. Example:</span>

<span class="sd">        .. code-block:: ini</span>

<span class="sd">            [{section}-q]</span>
<span class="sd">            name = logistic</span>
<span class="sd">            inputvar = logitq</span>
<span class="sd">            outputvar = q</span>
<span class="sd">            min-q = 1</span>
<span class="sd">            max-q = 8</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cp : pycbc.workflow.WorkflowConfigParser</span>
<span class="sd">            A parsed configuration file that contains the transform options.</span>
<span class="sd">        section : str</span>
<span class="sd">            Name of the section in the configuration file.</span>
<span class="sd">        outputs : str</span>
<span class="sd">            The names of the parameters that are output by this transformation,</span>
<span class="sd">            separated by `VARARGS_DELIM`. These must appear in the &quot;tag&quot; part</span>
<span class="sd">            of the section header.</span>
<span class="sd">        skip_opts : list, optional</span>
<span class="sd">            Do not read options in the given list.</span>
<span class="sd">        additional_opts : dict, optional</span>
<span class="sd">            Any additional arguments to pass to the class. If an option is</span>
<span class="sd">            provided that also exists in the config file, the value provided</span>
<span class="sd">            will be used instead of being read from the file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls</span>
<span class="sd">            An instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pull out the minimum, maximum values of the output variable</span>
        <span class="n">outputvar</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_opts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">additional_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_opts</span> <span class="o">=</span> <span class="n">additional_opts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">])</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="s1">&#39;min-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outputvar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">opt</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="n">skip_opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="s1">&#39;max-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outputvar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">opt</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="n">skip_opts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if providing a min(max)-</span><span class="si">{}</span><span class="s2">, must also provide &quot;</span>
                             <span class="s2">&quot;a max(min)-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outputvar</span><span class="p">,</span> <span class="n">outputvar</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_opts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;codomain&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">))})</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Logistic</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span>
                                                <span class="n">skip_opts</span><span class="p">,</span> <span class="n">additional_opts</span><span class="p">)</span></div></div>


<span class="c1"># set the inverse of the forward transforms to the inverse transforms</span>
<span class="n">MchirpQToMass1Mass2</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">Mass1Mass2ToMchirpQ</span>
<span class="n">ChirpDistanceToDistance</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">DistanceToChirpDistance</span>
<span class="n">SphericalToCartesian</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianToSpherical</span>
<span class="n">SphericalSpin1ToCartesianSpin1</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpin1ToSphericalSpin1</span>
<span class="n">SphericalSpin2ToCartesianSpin2</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpin2ToSphericalSpin2</span>
<span class="n">AlignedMassSpinToCartesianSpin</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpinToAlignedMassSpin</span>
<span class="n">PrecessionMassSpinToCartesianSpin</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpinToPrecessionMassSpin</span>
<span class="n">ChiPToCartesianSpin</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">CartesianSpinToChiP</span>
<span class="n">Log</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">Exponent</span>
<span class="n">Logit</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">Logistic</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                      Collections of transforms</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>

<span class="c1"># dictionary of all transforms</span>
<span class="n">transforms</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">CustomTransform</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CustomTransform</span><span class="p">,</span>
    <span class="n">MchirpQToMass1Mass2</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">MchirpQToMass1Mass2</span><span class="p">,</span>
    <span class="n">Mass1Mass2ToMchirpQ</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Mass1Mass2ToMchirpQ</span><span class="p">,</span>
    <span class="n">MchirpEtaToMass1Mass2</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">MchirpEtaToMass1Mass2</span><span class="p">,</span>
    <span class="n">Mass1Mass2ToMchirpEta</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Mass1Mass2ToMchirpEta</span><span class="p">,</span>
    <span class="n">ChirpDistanceToDistance</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">ChirpDistanceToDistance</span><span class="p">,</span>
    <span class="n">DistanceToChirpDistance</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">DistanceToChirpDistance</span><span class="p">,</span>
    <span class="n">SphericalToCartesian</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">SphericalToCartesian</span><span class="p">,</span>
    <span class="n">CartesianToSpherical</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianToSpherical</span><span class="p">,</span>
    <span class="n">SphericalSpin1ToCartesianSpin1</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">SphericalSpin1ToCartesianSpin1</span><span class="p">,</span>
    <span class="n">CartesianSpin1ToSphericalSpin1</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianSpin1ToSphericalSpin1</span><span class="p">,</span>
    <span class="n">SphericalSpin2ToCartesianSpin2</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">SphericalSpin2ToCartesianSpin2</span><span class="p">,</span>
    <span class="n">CartesianSpin2ToSphericalSpin2</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianSpin2ToSphericalSpin2</span><span class="p">,</span>
    <span class="n">DistanceToRedshift</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">DistanceToRedshift</span><span class="p">,</span>
    <span class="n">AlignedMassSpinToCartesianSpin</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">AlignedMassSpinToCartesianSpin</span><span class="p">,</span>
    <span class="n">CartesianSpinToAlignedMassSpin</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianSpinToAlignedMassSpin</span><span class="p">,</span>
    <span class="n">PrecessionMassSpinToCartesianSpin</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">PrecessionMassSpinToCartesianSpin</span><span class="p">,</span>
    <span class="n">CartesianSpinToPrecessionMassSpin</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianSpinToPrecessionMassSpin</span><span class="p">,</span>
    <span class="n">ChiPToCartesianSpin</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">ChiPToCartesianSpin</span><span class="p">,</span>
    <span class="n">CartesianSpinToChiP</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">CartesianSpinToChiP</span><span class="p">,</span>
    <span class="n">Log</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Log</span><span class="p">,</span>
    <span class="n">Exponent</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Exponent</span><span class="p">,</span>
    <span class="n">Logit</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Logit</span><span class="p">,</span>
    <span class="n">Logistic</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">Logistic</span><span class="p">,</span>
    <span class="n">LambdaFromTOVFile</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">LambdaFromTOVFile</span><span class="p">,</span>
    <span class="n">LambdaFromMultipleTOVFiles</span><span class="o">.</span><span class="n">name</span> <span class="p">:</span> <span class="n">LambdaFromMultipleTOVFiles</span>
<span class="p">}</span>

<span class="c1"># standard CBC transforms: these are transforms that do not require input</span>
<span class="c1"># arguments; they are typically used in CBC parameter estimation to transform</span>
<span class="c1"># to coordinates understood by the waveform generator</span>
<span class="n">common_cbc_forward_transforms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">MchirpQToMass1Mass2</span><span class="p">(),</span> <span class="n">DistanceToRedshift</span><span class="p">(),</span>
    <span class="n">SphericalToCartesian</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_a</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_polar</span><span class="p">),</span>
    <span class="n">SphericalToCartesian</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin2z</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_a</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_polar</span><span class="p">),</span>
    <span class="n">AlignedMassSpinToCartesianSpin</span><span class="p">(),</span> <span class="n">PrecessionMassSpinToCartesianSpin</span><span class="p">(),</span>
    <span class="n">ChiPToCartesianSpin</span><span class="p">(),</span> <span class="n">ChirpDistanceToDistance</span><span class="p">()</span>
<span class="p">]</span>
<span class="n">common_cbc_inverse_transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_t</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
                                 <span class="k">for</span> <span class="n">_t</span> <span class="ow">in</span> <span class="n">common_cbc_forward_transforms</span>
                                 <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_t</span><span class="o">.</span><span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                                         <span class="n">_t</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;spherical_to_cartesian&#39;</span><span class="p">)]</span>
<span class="n">common_cbc_inverse_transforms</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
    <span class="n">CartesianToSpherical</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_a</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_polar</span><span class="p">),</span>
    <span class="n">CartesianToSpherical</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2y</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin2z</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_a</span><span class="p">,</span>
                         <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_polar</span><span class="p">)])</span>

<span class="n">common_cbc_transforms</span> <span class="o">=</span> <span class="n">common_cbc_forward_transforms</span> <span class="o">+</span> \
                        <span class="n">common_cbc_inverse_transforms</span>


<div class="viewcode-block" id="get_common_cbc_transforms"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.get_common_cbc_transforms">[docs]</a><span class="k">def</span> <span class="nf">get_common_cbc_transforms</span><span class="p">(</span><span class="n">requested_params</span><span class="p">,</span> <span class="n">variable_args</span><span class="p">,</span>
                              <span class="n">valid_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines if any additional parameters from the InferenceFile are</span>
<span class="sd">    needed to get derived parameters that user has asked for.</span>

<span class="sd">    First it will try to add any base parameters that are required to calculate</span>
<span class="sd">    the derived parameters. Then it will add any sampling parameters that are</span>
<span class="sd">    required to calculate the base parameters needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    requested_params : list</span>
<span class="sd">        List of parameters that user wants.</span>
<span class="sd">    variable_args : list</span>
<span class="sd">        List of parameters that InferenceFile has.</span>
<span class="sd">    valid_params : list</span>
<span class="sd">        List of parameters that can be accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    requested_params : list</span>
<span class="sd">        Updated list of parameters that user wants.</span>
<span class="sd">    all_c : list</span>
<span class="sd">        List of BaseTransforms to apply.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variable_args</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable_args</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> \
                                    <span class="k">else</span> <span class="n">variable_args</span>

    <span class="c1"># try to parse any equations by putting all strings together</span>
    <span class="c1"># this will get some garbage but ensures all alphanumeric/underscored</span>
    <span class="c1"># parameter names are added</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">requested_params</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">opt</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">ch</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span>
        <span class="n">new_params</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">requested_params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">requested_params</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_params</span><span class="p">))</span>

    <span class="c1"># can pass a list of valid parameters to remove garbage from parsing above</span>
    <span class="k">if</span> <span class="n">valid_params</span><span class="p">:</span>
        <span class="n">valid_params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span>
        <span class="n">requested_params</span> <span class="o">=</span> <span class="n">requested_params</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">valid_params</span><span class="p">)</span>

    <span class="c1"># find all the transforms for the requested derived parameters</span>
    <span class="c1"># calculated from base parameters</span>
    <span class="n">from_base_c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">converter</span> <span class="ow">in</span> <span class="n">common_cbc_inverse_transforms</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">variable_args</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">converter</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">requested_params</span><span class="p">)):</span>
            <span class="k">continue</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">requested_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">intersect</span> <span class="ow">or</span> <span class="n">intersect</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">intersect</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">variable_args</span><span class="p">)):</span>
            <span class="k">continue</span>
        <span class="n">requested_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">from_base_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="p">)</span>

    <span class="c1"># find all the tranforms for the required base parameters</span>
    <span class="c1"># calculated from sampling parameters</span>
    <span class="n">to_base_c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">converter</span> <span class="ow">in</span> <span class="n">common_cbc_forward_transforms</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">variable_args</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">requested_params</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">requested_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">to_base_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="p">)</span>
            <span class="n">variable_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="c1"># get list of transforms that converts sampling parameters to the base</span>
    <span class="c1"># parameters and then converts base parameters to the derived parameters</span>
    <span class="n">all_c</span> <span class="o">=</span> <span class="n">to_base_c</span> <span class="o">+</span> <span class="n">from_base_c</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">requested_params</span><span class="p">),</span> <span class="n">all_c</span></div>


<div class="viewcode-block" id="apply_transforms"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.apply_transforms">[docs]</a><span class="k">def</span> <span class="nf">apply_transforms</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a list of BaseTransform instances on a mapping object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : {FieldArray, dict}</span>
<span class="sd">        Mapping object to apply transforms to.</span>
<span class="sd">    transforms : list</span>
<span class="sd">        List of BaseTransform instances to apply. Nested transforms are assumed</span>
<span class="sd">        to be in order for forward transforms.</span>
<span class="sd">    inverse : bool, optional</span>
<span class="sd">        Apply inverse transforms. In this case transforms will be applied in</span>
<span class="sd">        the opposite order. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : {FieldArray, dict}</span>
<span class="sd">        Mapping object with transforms applied. Same type as input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="k">return</span> <span class="n">samples</span></div>


<div class="viewcode-block" id="compute_jacobian"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.compute_jacobian">[docs]</a><span class="k">def</span> <span class="nf">compute_jacobian</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the jacobian of the list of transforms at the given sample</span>
<span class="sd">    points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : {FieldArray, dict}</span>
<span class="sd">        Mapping object specifying points at which to compute jacobians.</span>
<span class="sd">    transforms : list</span>
<span class="sd">        List of BaseTransform instances to apply. Nested transforms are assumed</span>
<span class="sd">        to be in order for forward transforms.</span>
<span class="sd">    inverse : bool, optional</span>
<span class="sd">        Compute inverse jacobians. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float :</span>
<span class="sd">        The product of the jacobians of all fo the transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">*=</span> <span class="n">t</span><span class="o">.</span><span class="n">inverse_jacobian</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">*=</span> <span class="n">t</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">j</span></div>


<div class="viewcode-block" id="order_transforms"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.order_transforms">[docs]</a><span class="k">def</span> <span class="nf">order_transforms</span><span class="p">(</span><span class="n">transforms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Orders transforms to ensure proper chaining.</span>

<span class="sd">    For example, if `transforms = [B, A, C]`, and `A` produces outputs needed</span>
<span class="sd">    by `B`, the transforms will be re-rorderd to `[A, B, C]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transforms : list</span>
<span class="sd">        List of transform instances to order.</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    list :</span>
<span class="sd">        List of transformed ordered such that forward transforms can be carried</span>
<span class="sd">        out without error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get a set of all inputs and all outputs</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
        <span class="c1"># pull out transforms that have no inputs in the set of outputs</span>
        <span class="n">leftover</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">outputs</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">outputs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">leftover</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="n">leftover</span>
    <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="read_transforms_from_config"><a class="viewcode-back" href="../../pycbc.html#pycbc.transforms.read_transforms_from_config">[docs]</a><span class="k">def</span> <span class="nf">read_transforms_from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;transforms&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of PyCBC transform instances for a section in the</span>
<span class="sd">    given configuration file.</span>

<span class="sd">    If the transforms are nested (i.e., the output of one transform is the</span>
<span class="sd">    input of another), the returned list will be sorted by the order of the</span>
<span class="sd">    nests.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cp : WorflowConfigParser</span>
<span class="sd">        An open config file to read.</span>
<span class="sd">    section : {&quot;transforms&quot;, string}</span>
<span class="sd">        Prefix on section names from which to retrieve the transforms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of the parsed transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subsection</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_subsections</span><span class="p">(</span><span class="n">section</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_opt_tag</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">subsection</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">subsection</span><span class="p">)</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">order_transforms</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, 2016, 2017, Alexander Nitz, Ian Harry, Christopher M. Biwer, Duncan A.  Brown, Josh Willis, and Tito Dal Canton.
      <span class="lastupdated">Last updated on Oct 20, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>