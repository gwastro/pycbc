<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pycbc.io.record &mdash; PyCBC 0.0a8230 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/terminal.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/typed.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> PyCBC
          </a>
              <div class="version">
                1.18.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credit.html">Use of PyCBC in Scientific Publications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docker.html">Running PyCBC under Docker</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../inference.html">PyCBC inference documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.inference</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow/pycbc_make_psd_estimation_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_psd_estimation_workflow</span></code>: A workflow generator for noise estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow/pycbc_make_coinc_search_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_coinc_search_workflow</span></code>: A workflow to search for gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow/pygrb.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_offline_grb_workflow</span></code>: A GRB triggered CBC analysis workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tmpltbank.html">PyCBC template bank generation documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.tmpltbank</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hwinj.html">Hardware injection waveform generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../banksim.html">Calculating the Effectualness (Fitting Factor) of Template Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faithsim.html">Dag Generator for Doing Faithfulness Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../upload_to_gracedb.html">Uploading triggers to gracedb</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../waveform_plugin.html">Making new waveform approximants available to PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../catalog.html">Catalog of Observed Gravitational-wave Mergers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dataquality.html">Query times of valid data, hardware injections, and more.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../frame.html">Reading Gravitational-wave Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fft.html">Performing FFTs in PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gw150914.html">Signal Processing with GW150914</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detector.html">Gravitational-wave Detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../psd.html">Handling PSDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../noise.html">Generating Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../waveform.html">Waveforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filter.html">Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distributions.html">Using PyCBC Distributions from PyCBC Inference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../building_bundled_executables.html">Building Bundled Executables</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documenting PyCBC code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Creating Releases of PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../formats/hdf_format.html">HDF files within the PyCBC workflow</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow.html">Workflow: the inspiral analysis workflow generator (<code class="docutils literal notranslate"><span class="pre">pycbc.workflow</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">pycbc</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyCBC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
          <li><a href="../../pycbc.html">pycbc</a> &raquo;</li>
          <li><a href="../io.html">pycbc.io</a> &raquo;</li>
      <li>pycbc.io.record</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pycbc.io.record</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2015  Collin Capano</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU General Public License as published by the</span>
<span class="c1"># Free Software Foundation; either version 3 of the License, or (at your</span>
<span class="c1"># option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but</span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General</span>
<span class="c1"># Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           Preamble</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This modules provides definitions of, and helper functions for, FieldArray.</span>
<span class="sd">FieldArray are wrappers of numpy recarrays with additional functionality</span>
<span class="sd">useful for storing and retrieving data created by a search for gravitationa</span>
<span class="sd">waves.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">types</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">glue.ligolw</span> <span class="kn">import</span> <span class="n">types</span> <span class="k">as</span> <span class="n">ligolw_types</span>
<span class="kn">from</span> <span class="nn">pycbc</span> <span class="kn">import</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">conversions</span><span class="p">,</span> <span class="n">cosmology</span>
<span class="kn">from</span> <span class="nn">pycbc.detector</span> <span class="kn">import</span> <span class="n">Detector</span>
<span class="kn">from</span> <span class="nn">pycbc.waveform</span> <span class="kn">import</span> <span class="n">parameters</span>

<span class="c1"># what functions are given to the eval in FieldArray&#39;s __getitem__:</span>
<span class="n">_numpy_function_lib</span> <span class="o">=</span> <span class="p">{</span><span class="n">_x</span><span class="p">:</span> <span class="n">_y</span> <span class="k">for</span> <span class="n">_x</span><span class="p">,</span><span class="n">_y</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                       <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_y</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ufunc</span><span class="p">,</span> <span class="nb">float</span><span class="p">))}</span>

<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           Data type mappings</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1"># add ligolw_types to numpy typeDict</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">typeDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ligolw_types</span><span class="o">.</span><span class="n">ToNumPyType</span><span class="p">)</span>

<span class="c1"># Annoyingly, numpy has no way to store NaNs in an integer field to indicate</span>
<span class="c1"># the equivalent of None. This can be problematic for fields that store ids:</span>
<span class="c1"># if an array has an id field with value 0, it isn&#39;t clear if this is because</span>
<span class="c1"># the id is the first element, or if no id was set. To clear up the ambiguity,</span>
<span class="c1"># we define here an integer to indicate &#39;id not set&#39;.</span>
<span class="n">ID_NOT_SET</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">EMPTY_OBJECT</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">VIRTUALFIELD_DTYPE</span> <span class="o">=</span> <span class="s1">&#39;VIRTUAL&#39;</span>

<span class="k">def</span> <span class="nf">set_default_empty</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># scalar dtype, just set</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># integer, set to ID_NOT_SET</span>
            <span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ID_NOT_SET</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
            <span class="c1"># object, set to EMPTY_OBJECT</span>
            <span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">EMPTY_OBJECT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">set_default_empty</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">default_empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Numpy&#39;s empty array can have random values in it. To prevent that, we</span>
<span class="sd">    define here a default emtpy array. This default empty is a numpy.zeros</span>
<span class="sd">    array, except that objects are set to None, and all ints to ID_NOT_SET.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">set_default_empty</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">default</span>

<span class="c1"># set default data types</span>
<span class="n">_default_types_status</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;default_strlen&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
    <span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="s1">&#39;lstring_as_obj&#39;</span><span class="p">:</span> <span class="kc">False</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">lstring_as_obj</span><span class="p">(</span><span class="n">true_or_false</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Toggles whether lstrings should be treated as strings or as objects.</span>
<span class="sd">    When FieldArrays is first loaded, the default is True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true_or_false : {None|bool}</span>
<span class="sd">        Pass True to map lstrings to objects; False otherwise. If None</span>
<span class="sd">        provided, just returns the current state.</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    current_stat : bool</span>
<span class="sd">        The current state of lstring_as_obj.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pycbc.io import FieldArray</span>
<span class="sd">    &gt;&gt;&gt; FieldArray.lstring_as_obj()</span>
<span class="sd">        True</span>
<span class="sd">    &gt;&gt;&gt; FieldArray.FieldArray.from_arrays([numpy.zeros(10)], dtype=[(&#39;foo&#39;, &#39;lstring&#39;)])</span>
<span class="sd">    FieldArray([(0.0,), (0.0,), (0.0,), (0.0,), (0.0,), (0.0,), (0.0,), (0.0,),</span>
<span class="sd">           (0.0,), (0.0,)],</span>
<span class="sd">          dtype=[(&#39;foo&#39;, &#39;O&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; FieldArray.lstring_as_obj(False)</span>
<span class="sd">        False</span>
<span class="sd">    &gt;&gt;&gt; FieldArray.FieldArray.from_arrays([numpy.zeros(10)], dtype=[(&#39;foo&#39;, &#39;lstring&#39;)])</span>
<span class="sd">    FieldArray([(&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,),</span>
<span class="sd">           (&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,), (&#39;0.0&#39;,)],</span>
<span class="sd">          dtype=[(&#39;foo&#39;, &#39;S50&#39;)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">true_or_false</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;lstring_as_obj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_or_false</span>
        <span class="c1"># update the typeDict</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="sa">u</span><span class="s1">&#39;lstring&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">object_</span> \
            <span class="k">if</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;lstring_as_obj&#39;</span><span class="p">]</span> \
            <span class="k">else</span> <span class="s1">&#39;S</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;default_strlen&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;lstring_as_obj&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">ilwd_as_int</span><span class="p">(</span><span class="n">true_or_false</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to lstring_as_obj, sets whether or not ilwd:chars should be</span>
<span class="sd">    treated as strings or as ints. Default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">true_or_false</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_or_false</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="sa">u</span><span class="s1">&#39;ilwd:char&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span> \
            <span class="k">if</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">]</span> \
            <span class="k">else</span> <span class="s1">&#39;S</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">default_strlen</span>
    <span class="k">return</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">default_strlen</span><span class="p">(</span><span class="n">strlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets the default string length for lstring and ilwd:char, if they are</span>
<span class="sd">    treated as strings. Default is 50.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">strlen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;default_strlen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strlen</span>
        <span class="c1"># update the typeDicts as needed</span>
        <span class="n">lstring_as_obj</span><span class="p">(</span><span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;lstring_as_obj&#39;</span><span class="p">])</span>
        <span class="n">ilwd_as_int</span><span class="p">(</span><span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;default_strlen&#39;</span><span class="p">]</span>

<span class="c1"># set the defaults</span>
<span class="n">lstring_as_obj</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ilwd_as_int</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           Helper functions</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>


<span class="c1">#</span>
<span class="c1">#   Argument syntax parsing</span>
<span class="c1">#</span>
<span class="c1"># this parser will pull out sufields as separate identifiers from their parent</span>
<span class="c1"># field; e.g., foo.bar --&gt; [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="n">_pyparser</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;identifier&gt;[\w_][\w\d_]*)&#39;</span><span class="p">)</span>
<span class="c1"># this parser treats subfields as one identifier with their parent field;</span>
<span class="c1"># e.g., foo.bar --&gt; [&#39;foo.bar&#39;]</span>
<span class="n">_fieldparser</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;identifier&gt;[\w_][.\w\d_]*)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_vars_from_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a python string, gets the names of any identifiers use in it.</span>
<span class="sd">    For example, if ``arg = &#39;3*narf/foo.bar&#39;``, this will return</span>
<span class="sd">    ``set([&#39;narf&#39;, &#39;foo&#39;, &#39;bar&#39;])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_pyparser</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">get_fields_from_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a python string, gets FieldArray field names used in it. This</span>
<span class="sd">    differs from get_vars_from_arg in that any identifier with a &#39;.&#39; in it</span>
<span class="sd">    will be treated as one identifier. For example, if</span>
<span class="sd">    ``arg = &#39;3*narf/foo.bar&#39;``, this will return ``set([&#39;narf&#39;, &#39;foo.bar&#39;])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_fieldparser</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="c1"># this parser looks for fields inside a class method function. This is done by</span>
<span class="c1"># looking for variables that start with self.{x} or self[&quot;{x}&quot;]; e.g.,</span>
<span class="c1"># self.a.b*3 + self.c, self[&#39;a.b&#39;]*3 + self.c, self.a.b*3 + self[&quot;c&quot;], all</span>
<span class="c1"># return set(&#39;a.b&#39;, &#39;c&#39;).</span>
<span class="n">_instfieldparser</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;self(?:\.|(?:\[[&#39;&quot;]))(?P&lt;identifier&gt;[\w_][.\w\d_]*)&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_instance_fields_from_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a python string definining a method function on an instance of an</span>
<span class="sd">    FieldArray, returns the field names used in it. This differs from</span>
<span class="sd">    get_fields_from_arg in that it looks for variables that start with &#39;self&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_instfieldparser</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">get_needed_fieldnames</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a FieldArray-like array and a list of names, determines what</span>
<span class="sd">    fields are needed from the array so that using the names does not result</span>
<span class="sd">    in an error.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : instance of a FieldArray or similar</span>
<span class="sd">        The array from which to determine what fields to get.</span>
<span class="sd">    names : (list of) strings</span>
<span class="sd">        A list of the names that are desired. The names may be either a field,</span>
<span class="sd">        a virtualfield, a property, a method of ``arr``, or any function of</span>
<span class="sd">        these. If a virtualfield/property or a method, the source code of that</span>
<span class="sd">        property/method will be analyzed to pull out what fields are used in</span>
<span class="sd">        it.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set</span>
<span class="sd">        The set of the fields needed to evaluate the names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fieldnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="c1"># we&#39;ll need the class that the array is an instance of to evaluate some</span>
    <span class="c1"># things</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
    <span class="c1"># parse names for variables, incase some of them are functions of fields</span>
    <span class="n">parsed_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">parsed_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_fields_from_arg</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="c1"># only include things that are in the array&#39;s namespace</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parsed_names</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="c1"># is a field, just add the name</span>
            <span class="n">fieldnames</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the name is either a virtualfield, a method, or some other</span>
            <span class="c1"># property; we need to evaluate the source code to figure out what</span>
            <span class="c1"># fields we need</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># the underlying functions of properties need to be retrieved</span>
                <span class="c1"># using their fget attribute</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">fget</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># no fget attribute, assume is an instance method</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="c1"># evaluate the source code of the function</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sourcecode</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># not a function, just pass</span>
                <span class="k">continue</span>
            <span class="c1"># evaluate the source code for the fields</span>
            <span class="n">possible_fields</span> <span class="o">=</span> <span class="n">get_instance_fields_from_arg</span><span class="p">(</span><span class="n">sourcecode</span><span class="p">)</span>
            <span class="c1"># some of the variables returned by possible fields may themselves</span>
            <span class="c1"># be methods/properties that depend on other fields. For instance,</span>
            <span class="c1"># mchirp relies on eta and mtotal, which each use mass1 and mass2;</span>
            <span class="c1"># we therefore need to anayze each of the possible fields</span>
            <span class="n">fieldnames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_needed_fieldnames</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">possible_fields</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fieldnames</span>


<span class="k">def</span> <span class="nf">get_dtype_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Numpy&#39;s ``dtype.descr`` will return empty void fields if a dtype has</span>
<span class="sd">    offsets specified. This function tries to fix that by not including</span>
<span class="sd">    fields that have no names and are void types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Downstream codes (numpy, etc) can&#39;t handle metadata in dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dts</span>


<span class="k">def</span> <span class="nf">combine_fields</span><span class="p">(</span><span class="n">dtypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combines the fields in the list of given dtypes into a single dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtypes : (list of) numpy.dtype(s)</span>
<span class="sd">        Either a numpy.dtype, or a list of numpy.dtypes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.dtype</span>
<span class="sd">        A new dtype combining the fields in the list of dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtypes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span><span class="p">]</span>
    <span class="c1"># Note: incase any of the dtypes have offsets, we won&#39;t include any fields</span>
    <span class="c1"># that have no names and are void</span>
    <span class="n">new_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">([</span><span class="n">dt</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">dtypes</span> \
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">get_dtype_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">new_dt</span>


<span class="k">def</span> <span class="nf">_ensure_array_list</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensures that every element in a list is an instance of a numpy array.&quot;&quot;&quot;</span>
    <span class="c1"># Note: the isinstance test is needed below so that instances of FieldArray</span>
    <span class="c1"># are not converted to numpy arrays</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">arr</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">merge_arrays</span><span class="p">(</span><span class="n">merge_list</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges the given arrays into a single array. The arrays must all have</span>
<span class="sd">    the same shape. If one or more of the given arrays has multiple fields,</span>
<span class="sd">    all of the fields will be included as separate fields in the new array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    merge_list : list of arrays</span>
<span class="sd">        The list of arrays to merge.</span>
<span class="sd">    names : {None | sequence of strings}</span>
<span class="sd">        Optional, the names of the fields in the output array. If flatten is</span>
<span class="sd">        True, must be the same length as the total number of fields in</span>
<span class="sd">        merge_list.  Otherise, must be the same length as the number of</span>
<span class="sd">        arrays in merge_list.  If None provided, and flatten is True, names</span>
<span class="sd">        used will be the same as the name of the fields in the given arrays.</span>
<span class="sd">        If the datatype has no name, or flatten is False, the new field will</span>
<span class="sd">        be `fi` where i is the index of the array in arrays.</span>
<span class="sd">    flatten : bool</span>
<span class="sd">        Make all of the fields in the given arrays separate fields in the</span>
<span class="sd">        new array. Otherwise, each array will be added as a field. If an</span>
<span class="sd">        array has fields, they will be subfields in the output array. Default</span>
<span class="sd">        is True.</span>
<span class="sd">    outtype : {None | class}</span>
<span class="sd">        Cast the new array to the given type. Default is to return a</span>
<span class="sd">        numpy structured array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new array : {numpy.ndarray | outtype}</span>
<span class="sd">        A new array with all of the fields in all of the arrays merged into</span>
<span class="sd">        a single array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure everything in merge_list is an array</span>
    <span class="n">merge_list</span> <span class="o">=</span> <span class="n">_ensure_array_list</span><span class="p">(</span><span class="n">merge_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">merge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">merge_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all of the arrays in merge_list must have the &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;same shape&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
        <span class="n">new_dt</span> <span class="o">=</span> <span class="n">combine_fields</span><span class="p">([</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">merge_list</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;f</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">ii</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span> \
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">merge_list</span><span class="p">)])</span>
    <span class="n">new_arr</span> <span class="o">=</span> <span class="n">merge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">merge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dt</span><span class="p">)</span>
    <span class="c1"># ii is a counter to keep track of which fields from the new array</span>
    <span class="c1"># go with which arrays in merge list</span>
    <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">merge_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_arr</span><span class="p">[</span><span class="n">new_dt</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arr</span>
            <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">new_arr</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># set the names if desired</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
    <span class="c1"># ditto the outtype</span>
    <span class="k">if</span> <span class="n">outtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_arr</span> <span class="o">=</span> <span class="n">new_arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">outtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_arr</span>

<span class="k">def</span> <span class="nf">add_fields</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assubarray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the given array(s) as new field(s) to the given input array.</span>
<span class="sd">    Returns a new instance of the input_array with the new fields added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_array : instance of a numpy.ndarray or numpy recarray</span>
<span class="sd">        The array to to add the fields to.</span>
<span class="sd">    arrays : (list of) numpy array(s)</span>
<span class="sd">        The arrays to add. If adding multiple arrays, must be a list;</span>
<span class="sd">        if adding a single array, can just be that array.</span>
<span class="sd">    names : (list of) strings</span>
<span class="sd">        Optional, the name(s) of the new fields in the output array. If</span>
<span class="sd">        adding multiple fields, must be a list of strings with the same</span>
<span class="sd">        length as the list of arrays. If None provided, names used will</span>
<span class="sd">        be the same as the name of the datatype in the given arrays.</span>
<span class="sd">        If the datatype has no name, the new field will be ``&#39;fi&#39;`` where</span>
<span class="sd">        i is the index of the array in arrays.</span>
<span class="sd">    assubarray : bool</span>
<span class="sd">        Add the list of arrays as a single subarray field. If True, and names</span>
<span class="sd">        provided, names should be a string or a length-1 sequence. Default is</span>
<span class="sd">        False, in which case each array will be added as a separate field.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_array : new instance of `input_array`</span>
<span class="sd">        A copy of the `input_array` with the desired fields added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="c1"># ensure that all arrays in arrays are arrays</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">_ensure_array_list</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1"># set the names</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="c1"># check if any names are subarray names; if so, we have to add them</span>
        <span class="c1"># separately</span>
        <span class="n">subarray_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subarray_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">subarray_names</span><span class="p">):</span>
        <span class="n">subarrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> \
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">subarray_names</span><span class="p">]</span>
        <span class="c1"># group together by subarray</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subarray_names</span><span class="p">,</span> <span class="n">subarrays</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">subkey</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">subkey</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">subkey</span><span class="p">,</span> <span class="n">arr</span><span class="p">)]</span>
        <span class="c1"># now cycle over the groups, adding all of the fields in each group</span>
        <span class="c1"># as a subarray</span>
        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="c1"># we&#39;ll create a dictionary out of the subarray field names -&gt;</span>
            <span class="c1"># subarrays</span>
            <span class="n">thisdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span>
            <span class="c1"># check if the input array has this field; if so, remove it, then</span>
            <span class="c1"># add it back with the other new arrays</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">input_array</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
                <span class="c1"># get the data</span>
                <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">input_array</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
                <span class="c1"># add the new fields to the subarray</span>
                <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">add_fields</span><span class="p">(</span><span class="n">new_subarray</span><span class="p">,</span> <span class="n">thisdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                    <span class="n">thisdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="c1"># remove the original from the input array</span>
                <span class="n">input_array</span> <span class="o">=</span> <span class="n">input_array</span><span class="o">.</span><span class="n">without_fields</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">thisdict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="c1"># add the new subarray to input_array as a subarray</span>
            <span class="n">input_array</span> <span class="o">=</span> <span class="n">add_fields</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">new_subarray</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">group_name</span><span class="p">,</span> <span class="n">assubarray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># set the subarray names</span>
            <span class="n">input_array</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">thisdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># remove the subarray names from names</span>
        <span class="n">keep_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> \
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subarray_names</span><span class="p">]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
        <span class="c1"># if there&#39;s nothing left, just return</span>
        <span class="k">if</span> <span class="n">names</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">input_array</span>
        <span class="c1"># also remove the subarray arrays</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">assubarray</span><span class="p">:</span>
        <span class="c1"># merge all of the arrays into a single array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">merge_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="c1"># now merge all the fields as a single subarray</span>
        <span class="n">merged_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)])</span>
        <span class="n">merged_arr</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">merged_arr</span><span class="p">]</span>
    <span class="n">merge_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_array</span><span class="p">]</span> <span class="o">+</span> <span class="n">arrays</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">+</span> <span class="n">names</span>
    <span class="c1"># merge into a single array</span>
    <span class="k">return</span> <span class="n">merge_arrays</span><span class="p">(</span><span class="n">merge_list</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">outtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">input_array</span><span class="p">))</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           Base FieldArray definitions</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>

<span class="c1"># We&#39;ll include functions in various pycbc modules in FieldArray&#39;s function</span>
<span class="c1"># library. All modules used must have an __all__ list defined.</span>
<span class="n">_modules_for_functionlib</span> <span class="o">=</span> <span class="p">[</span><span class="n">conversions</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">cosmology</span><span class="p">]</span>
<span class="n">_fieldarray_functionlib</span> <span class="o">=</span> <span class="p">{</span><span class="n">_funcname</span> <span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_mod</span><span class="p">,</span> <span class="n">_funcname</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">_mod</span> <span class="ow">in</span> <span class="n">_modules_for_functionlib</span>
                              <span class="k">for</span> <span class="n">_funcname</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_mod</span><span class="p">,</span> <span class="s1">&#39;__all__&#39;</span><span class="p">)}</span>

<div class="viewcode-block" id="FieldArray"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray">[docs]</a><span class="k">class</span> <span class="nc">FieldArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of numpy.recarray that adds additional functionality.</span>

<span class="sd">    Initialization is done the same way as numpy.recarray, with the addition</span>
<span class="sd">    that a &quot;name&quot; attribute can be passed to name the output array. When you</span>
<span class="sd">    initialize an array it creates a new zeroed array. This is similar to</span>
<span class="sd">    numpy.recarray, except that ``numpy.recarray(shape)`` will create an empty</span>
<span class="sd">    array, whereas here the default is to zero all of the elements (see</span>
<span class="sd">    ``default_zero`` for definition of zero for different data types). If you</span>
<span class="sd">    prefer an empty array, set ``zero=False`` when initializing.</span>

<span class="sd">    You cannot pass an array or sequence as input as you do with numpy.array.</span>
<span class="sd">    To initialize an FieldArray from an already existing arrays, use the</span>
<span class="sd">    ``FieldArray.from_arrays`` class method. To initialize from a list of</span>
<span class="sd">    tuples, use ``FieldArray.from_records``. See the docstring for those methods</span>
<span class="sd">    for details. For more information on initalizing an empty array, see</span>
<span class="sd">    ``numpy.recarray`` help.</span>

<span class="sd">    Some additional features:</span>

<span class="sd">    * **Arbitrary functions**:</span>

<span class="sd">      You can retrive functions on fields in the same manner that you access</span>
<span class="sd">      individual fields. For example, if you have a FieldArray ``x`` with</span>
<span class="sd">      fields ``a`` and ``b``, you can access each field with</span>
<span class="sd">      ``x[&#39;a&#39;], x[&#39;b&#39;]``.  You can also do ``x[&#39;a*b/(a+b)**2.&#39;]``,</span>
<span class="sd">      ``x[cos(a)*sin(b)]``, etc. Boolean operations are also possible, e.g.,</span>
<span class="sd">      ``x[&#39;(a &lt; 3) &amp; (b &lt; 2)&#39;]``. Syntax for functions is python. Any numpy</span>
<span class="sd">      ufunc, as well as all functions listed in the functionlib attribute, may</span>
<span class="sd">      be used. Note that while fields may be accessed as attributes (e.g,</span>
<span class="sd">      field ``a`` can be accessed via ``x[&#39;a&#39;]`` or ``x.a``), functions on</span>
<span class="sd">      multiple fields may not (``x.a+b`` does not work, for obvious reasons).</span>

<span class="sd">    * **Subfields and &#39;.&#39; indexing**:</span>
<span class="sd">      Structured arrays, which are the base class for recarrays and, by</span>
<span class="sd">      inheritance, FieldArray, allows for fields to themselves have fields. For</span>
<span class="sd">      example, an array ``x`` may have fields ``a`` and ``b``, with ``b`` having</span>
<span class="sd">      subfields ``c`` and ``d``. You can access subfields using other index</span>
<span class="sd">      notation or attribute notation. So, the subfields ``d`` may be retrieved</span>
<span class="sd">      via ``x[&#39;b&#39;][&#39;d&#39;]``, ``x.b.d``, ``x[&#39;b&#39;].d`` or ``x[&#39;b.d&#39;]``. Likewise,</span>
<span class="sd">      functions can be carried out on the subfields, as they can on fields. If</span>
<span class="sd">      ``d`` is a float field, we could get the log of it via ``x[&#39;log(b.d)&#39;]``.</span>
<span class="sd">      There is no limit to the number of subfields. So, ``c`` could also have</span>
<span class="sd">      subfield ``c0``, which would be accessed via ``x.c.c0``, or any of the</span>
<span class="sd">      other methods.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       Record arrays also allow you to set values of a field using attribute</span>
<span class="sd">       notation. However, this can lead to unexpected results if you</span>
<span class="sd">       accidently misspell the attribute. For example, if ``x`` has field</span>
<span class="sd">       ``foo``, and you misspell this when setting, e.g., you try to do</span>
<span class="sd">       ``x.fooo = numpy.arange(x.size)``, ``foo`` will not be set, nor will</span>
<span class="sd">       you get an error. Instead, the attribute ``fooo`` will be added to</span>
<span class="sd">       ``x``. If you tried to do this using index notation, however ---</span>
<span class="sd">       ``x[&#39;fooo&#39;] = numpy.arange(x.size)`` --- you will</span>
<span class="sd">       get an ``AttributeError`` as you might expect. For this reason, it is</span>
<span class="sd">       recommended that you always use index notation when *setting* values;</span>
<span class="sd">       you can use either index or attribute notation when *retrieving*</span>
<span class="sd">       values.</span>

<span class="sd">    * **Properties and methods as fields**:</span>
<span class="sd">      If a propety or instance method is defined for a class that inherits from</span>
<span class="sd">      FieldArray, those can be accessed in the same way as fields are. For</span>
<span class="sd">      example, define ``Foo`` as:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        class Foo(FieldArray):</span>
<span class="sd">            @property</span>
<span class="sd">            def bar(self):</span>
<span class="sd">                return self[&#39;a&#39;]**2.</span>

<span class="sd">            def narf(self, y):</span>
<span class="sd">                return self[&#39;a&#39;] + y</span>

<span class="sd">    Then if we have an instance: ``foo = Foo(100, dtype=[(&#39;a&#39;, float)])``.</span>
<span class="sd">    The ``bar`` and ``narf`` attributes may be accessed via field notation:</span>
<span class="sd">    ``foo.bar``, ``foo[&#39;bar&#39;]``, ``foo.narf(10)`` and ``foo[&#39;narf(10)&#39;]``.</span>

<span class="sd">    * **Virtual fields**:</span>
<span class="sd">      Virtual fields are methods wrapped as properties that operate on one or</span>
<span class="sd">      more fields, thus returning an array of values. To outside code virtual</span>
<span class="sd">      fields look the same as fields, and can be called similarily. Internally,</span>
<span class="sd">      no additional data is stored; the operation is performed on the fly when</span>
<span class="sd">      the virtual field is called. Virtual fields can be added to an array</span>
<span class="sd">      instance with the add_virtualfields method. Alternatively, virtual fields</span>
<span class="sd">      can be defined by sub-classing FieldArray:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        class Foo(FieldArray):</span>
<span class="sd">            _virtualfields = [&#39;bar&#39;]</span>
<span class="sd">            @property</span>
<span class="sd">            def bar(self):</span>
<span class="sd">                return self[&#39;a&#39;]**2.</span>

<span class="sd">    The fields property returns the names of both fields and virtual fields.</span>

<span class="sd">    .. note::</span>

<span class="sd">        It can happen that a field, virtual field, or function in the</span>
<span class="sd">        functionlib have that same name. In that case, precedence is: field,</span>
<span class="sd">        virtual field, function. For example, if a function called &#39;foo&#39; is in</span>
<span class="sd">        the function library, and a virtual field is added call &#39;foo&#39;, then</span>
<span class="sd">        `a[&#39;foo&#39;]` will return the virtual field rather than the function.</span>
<span class="sd">        Likewise, if the array is initialized with a field called `foo`, or a</span>
<span class="sd">        field with that name is added, `a[&#39;foo&#39;]` will return that field</span>
<span class="sd">        rather than the virtual field and/or the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : {int | tuple}</span>
<span class="sd">        The shape of the new array.</span>
<span class="sd">    name : {None | str}</span>
<span class="sd">        Optional, what to name the new array. The array&#39;s ``name`` attribute</span>
<span class="sd">        is set to this.</span>

<span class="sd">    For details on other keyword arguments, see ``numpy.recarray`` help.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Instance attribute. The name of the array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. note:: For some predefined arrays with default fields, see the other</span>
<span class="sd">        array classes defined below.</span>

<span class="sd">    Create an empty array with four rows and two fields called `foo` and</span>
<span class="sd">    `bar`, both of which are floats:</span>

<span class="sd">    &gt;&gt;&gt; x = FieldArray(4, dtype=[(&#39;foo&#39;, float), (&#39;bar&#39;, float)])</span>

<span class="sd">    Set/retrieve a fields using index or attribute syntax:</span>

<span class="sd">    &gt;&gt;&gt; x[&#39;foo&#39;] = [1.,2.,3.,4.]</span>
<span class="sd">    &gt;&gt;&gt; x[&#39;bar&#39;] = [5.,6.,7.,8.]</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    FieldArray([(1.0, 5.0), (2.0, 6.0), (3.0, 7.0), (4.0, 8.0)],</span>
<span class="sd">          dtype=[(&#39;foo&#39;, &#39;&lt;f8&#39;), (&#39;bar&#39;, &#39;&lt;f8&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; x.foo</span>
<span class="sd">        array([ 1.,  2.,  3.,  4.])</span>
<span class="sd">    &gt;&gt;&gt; x[&#39;bar&#39;]</span>
<span class="sd">        array([ 5.,  6.,  7.,  8.])</span>

<span class="sd">    Get the names of the fields:</span>

<span class="sd">    &gt;&gt;&gt; x.fieldnames</span>
<span class="sd">        (&#39;foo&#39;, &#39;bar&#39;)</span>

<span class="sd">    Rename the fields to `a` and `b`:</span>

<span class="sd">    &gt;&gt;&gt; x.dtype.names = [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; x.fieldnames</span>
<span class="sd">        (&#39;a&#39;, &#39;b&#39;)</span>

<span class="sd">    Retrieve a function of the fields as if it were a field:</span>

<span class="sd">    &gt;&gt;&gt; x[&#39;sin(a/b)&#39;]</span>
<span class="sd">    array([ 0.19866933,  0.3271947 ,  0.41557185,  0.47942554])</span>

<span class="sd">    Add a virtual field:</span>

<span class="sd">    &gt;&gt;&gt; def c(self):</span>
<span class="sd">    ...     return self[&#39;a&#39;] + self[&#39;b&#39;]</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; x = x.add_virtualfields(&#39;c&#39;, c)</span>
<span class="sd">    &gt;&gt;&gt; x.fields</span>
<span class="sd">    (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x[&#39;c&#39;]</span>
<span class="sd">    array([  6.,   8.,  10.,  12.])</span>

<span class="sd">    Create an array with subfields:</span>

<span class="sd">    &gt;&gt;&gt; x = FieldArray(4, dtype=[(&#39;foo&#39;, [(&#39;cat&#39;, float), (&#39;hat&#39;, int)]), (&#39;bar&#39;, float)])</span>
<span class="sd">    &gt;&gt;&gt; x.fieldnames</span>
<span class="sd">        [&#39;foo.cat&#39;, &#39;foo.hat&#39;, &#39;bar&#39;]</span>

<span class="sd">    Load from a list of arrays (in this case, from an hdf5 file):</span>

<span class="sd">    &gt;&gt;&gt; bankhdf = h5py.File(&#39;bank/H1L1-BANK2HDF-1117400416-928800.hdf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; bankhdf.keys()</span>
<span class="sd">        [u&#39;mass1&#39;, u&#39;mass2&#39;, u&#39;spin1z&#39;, u&#39;spin2z&#39;, u&#39;template_hash&#39;]</span>
<span class="sd">    &gt;&gt;&gt; templates = FieldArray.from_arrays(bankhdf.values(), names=bankhdf.keys())</span>
<span class="sd">    &gt;&gt;&gt; templates.fieldnames</span>
<span class="sd">        (&#39;mass1&#39;, &#39;mass2&#39;, &#39;spin1z&#39;, &#39;spin2z&#39;, &#39;template_hash&#39;)</span>
<span class="sd">    &gt;&gt;&gt; templates.mass1</span>
<span class="sd">    array([ 1.71731389,  1.10231435,  2.99999857, ...,  1.67488706,</span>
<span class="sd">            1.00531888,  2.11106491], dtype=float32)</span>

<span class="sd">    Sort by a field without having to worry about also sorting the other</span>
<span class="sd">    fields:</span>

<span class="sd">    &gt;&gt;&gt; templates[[&#39;mass1&#39;, &#39;mass2&#39;]]</span>
<span class="sd">    array([(1.7173138856887817, 1.2124452590942383),</span>
<span class="sd">           (1.1023143529891968, 1.0074082612991333),</span>
<span class="sd">           (2.9999985694885254, 1.0578444004058838), ...,</span>
<span class="sd">           (1.6748870611190796, 1.1758257150650024),</span>
<span class="sd">           (1.0053188800811768, 1.0020891427993774),</span>
<span class="sd">           (2.111064910888672, 1.0143394470214844)],</span>
<span class="sd">          dtype=[(&#39;mass1&#39;, &#39;&lt;f4&#39;), (&#39;mass2&#39;, &#39;&lt;f4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; templates.sort(order=&#39;mass1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; templates[[&#39;mass1&#39;, &#39;mass2&#39;]]</span>
<span class="sd">    array([(1.000025987625122, 1.0000133514404297),</span>
<span class="sd">           (1.0002814531326294, 1.0002814531326294),</span>
<span class="sd">           (1.0005437135696411, 1.0005437135696411), ...,</span>
<span class="sd">           (2.999999523162842, 1.371169090270996),</span>
<span class="sd">           (2.999999523162842, 1.4072519540786743), (3.0, 1.4617927074432373)],</span>
<span class="sd">          dtype=[(&#39;mass1&#39;, &#39;&lt;f4&#39;), (&#39;mass2&#39;, &#39;&lt;f4&#39;)])</span>

<span class="sd">    Convert a LIGOLW xml table:</span>

<span class="sd">    &gt;&gt;&gt; type(sim_table)</span>
<span class="sd">        glue.ligolw.lsctables.SimInspiralTable</span>
<span class="sd">    &gt;&gt;&gt; sim_array = FieldArray.from_ligolw_table(sim_table)</span>
<span class="sd">    &gt;&gt;&gt; sim_array.mass1</span>
<span class="sd">    array([ 2.27440691,  1.85058105,  1.61507106, ...,  2.0504961 ,</span>
<span class="sd">            2.33554196,  2.02732205], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; sim_array.waveform</span>
<span class="sd">    array([u&#39;SpinTaylorT2&#39;, u&#39;SpinTaylorT2&#39;, u&#39;SpinTaylorT2&#39;, ...,</span>
<span class="sd">           u&#39;SpinTaylorT2&#39;, u&#39;SpinTaylorT2&#39;, u&#39;SpinTaylorT2&#39;], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; sim_array = FieldArray.from_ligolw_table(sim_table, columns=[&#39;simulation_id&#39;, &#39;mass1&#39;, &#39;mass2&#39;])</span>
<span class="sd">    &gt;&gt;&gt; sim_array</span>
<span class="sd">    FieldArray([(0, 2.274406909942627, 2.6340370178222656),</span>
<span class="sd">           (1, 1.8505810499191284, 2.8336880207061768),</span>
<span class="sd">           (2, 1.6150710582733154, 2.2336490154266357), ...,</span>
<span class="sd">           (11607, 2.0504961013793945, 2.6019821166992188),</span>
<span class="sd">           (11608, 2.3355419635772705, 1.2164380550384521),</span>
<span class="sd">           (11609, 2.0273220539093018, 2.2453839778900146)],</span>
<span class="sd">          dtype=[(&#39;simulation_id&#39;, &#39;&lt;i8&#39;), (&#39;mass1&#39;, &#39;&lt;f4&#39;), (&#39;mass2&#39;, &#39;&lt;f4&#39;)])</span>

<span class="sd">    Add a field to the array:</span>

<span class="sd">    &gt;&gt;&gt; optimal_snrs = numpy.random.uniform(4.,40., size=len(sim_array))</span>
<span class="sd">    &gt;&gt;&gt; sim_array = sim_array.add_fields(optimal_snrs, &#39;optimal_snrs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sim_array.fieldnames</span>
<span class="sd">        (&#39;simulation_id&#39;, &#39;mass1&#39;, &#39;mass2&#39;, &#39;optimal_snrs&#39;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Input arrays with variable-length strings in one or more fields can be</span>
<span class="sd">    tricky to deal with. Numpy arrays are designed to use fixed-length</span>
<span class="sd">    datasets, so that quick memory access can be achieved. To deal with</span>
<span class="sd">    variable-length strings, there are two options: 1. set the data type to</span>
<span class="sd">    object, or 2. set the data type to a string with a fixed length larger</span>
<span class="sd">    than the longest string in the input array.</span>

<span class="sd">    The first option, using objects, essentially causes the array to store a</span>
<span class="sd">    pointer to the string.  This is the most flexible option, as it allows</span>
<span class="sd">    strings in the array to be updated to any length. However, operations on</span>
<span class="sd">    object fields are slower, as numpy cannot take advantage of its fast</span>
<span class="sd">    memory striding abilities (see `this question/answer on stackoverflow</span>
<span class="sd">    &lt;http://stackoverflow.com/a/14639568/1366472&gt;`_ for details). Also,</span>
<span class="sd">    numpy&#39;s support of object arrays is more limited.  In particular, prior</span>
<span class="sd">    to version 1.9.2, you cannot create a view of an array that changes the</span>
<span class="sd">    dtype if the array has any fields that are objects, even if the view does</span>
<span class="sd">    not affect the object fields. (This has since been relaxed.)</span>

<span class="sd">    The second option, using strings of a fixed length, solves the issues</span>
<span class="sd">    with object fields. However, if you try to change one of the strings</span>
<span class="sd">    after the array is created, the string will be truncated at whatever</span>
<span class="sd">    string length is used. Additionally, if you choose too large of a string</span>
<span class="sd">    length, you can substantially increase the memory overhead for large</span>
<span class="sd">    arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_virtualfields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_functionlib</span> <span class="o">=</span> <span class="n">_fieldarray_functionlib</span>
    <span class="n">__persistent_attributes__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;_virtualfields&#39;</span><span class="p">,</span> <span class="s1">&#39;_functionlib&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes a new empty array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FieldArray</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">__persistent_attributes__</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__persistent_attributes__</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_functionlib</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">func</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">func</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_functionlib</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_virtualfields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_virtualfields</span><span class="p">]</span>
        <span class="c1"># zero out the array if desired</span>
        <span class="k">if</span> <span class="n">zero</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">default_empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">obj</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default values are set here.</span>

<span class="sd">        See &lt;https://docs.scipy.org/doc/numpy/user/basics.subclassing.html&gt; for</span>
<span class="sd">        details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># copy persistent attributes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__copy_attributes__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># numpy has some issues with dtype field names that are unicode,</span>
        <span class="c1"># so we&#39;ll force them to strings here</span>
        <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="c1"># We don&#39;t want to do this in python3 because a str *is* unicode,</span>
            <span class="c1"># but maybe numpy in python3 is more lenient of this. Let&#39;s just</span>
            <span class="c1"># wait and see if this becomes a problem in python3</span>

    <span class="k">def</span> <span class="nf">__copy_attributes__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the values of all of the attributes listed in</span>
<span class="sd">        `self.__persistent_attributes__` to other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="nb">setattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="p">)))</span> \
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__persistent_attributes__</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">no_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allows fields to be accessed as attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first try to get the attribute</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># don&#39;t try getitem, which might get back here</span>
            <span class="k">if</span> <span class="n">no_fallback</span><span class="p">:</span>
                <span class="k">raise</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="c1"># might be a field, try to retrive it using getitem</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="c1"># otherwise, unrecognized</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap&#39;s recarray&#39;s setitem to allow attribute-like indexing when</span>
<span class="sd">        setting values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># numpy &gt;=1.14 only accepts tuples</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FieldArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># we&#39;ll get a ValueError if a subarray is being referenced using</span>
            <span class="c1"># &#39;.&#39;; so we&#39;ll try to parse it out here</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># now try again</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FieldArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getbaseitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets an item assuming item is either an index or a fieldname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We cast to a ndarray to avoid calling array_finalize, which can be</span>
        <span class="c1"># slow</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="n">item</span><span class="p">]</span>
        <span class="c1"># if there are no fields, then we can just return</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="c1"># if there are fields, but only a single entry, we&#39;d just get a</span>
        <span class="c1"># record by casting to self, so just cast immediately to recarray</span>
        <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="c1"># otherwise, cast back to an instance of self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getsubitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets a subfield using `field.subfield` notation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getbaseitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">subitems</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subitems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getbaseitem__</span><span class="p">(</span><span class="n">subitems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">__getsubitem__</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subitems</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraps recarray&#39;s  `__getitem__` so that math functions on fields and</span>
<span class="sd">        attributes can be retrieved. Any function in numpy&#39;s library may be</span>
<span class="sd">        used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getsubitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1">#   arg isn&#39;t a simple argument of row, so we&#39;ll have to eval it</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_code_cache&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_code_cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_code_cache</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;eval&#39;</span><span class="p">)</span>

                <span class="c1"># get the function library</span>
                <span class="n">item_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_numpy_function_lib</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="n">item_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_functionlib</span><span class="p">)</span>

                <span class="c1"># parse to get possible fields</span>
                <span class="n">itemvars_raw</span> <span class="o">=</span> <span class="n">get_fields_from_arg</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

                <span class="n">itemvars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">itemvars_raw</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                        <span class="n">is_num</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">is_num</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_num</span><span class="p">:</span>
                        <span class="n">itemvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_code_cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">itemvars</span><span class="p">,</span> <span class="n">item_dict</span><span class="p">)</span>

            <span class="n">code</span><span class="p">,</span> <span class="n">itemvars</span><span class="p">,</span> <span class="n">item_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_code_cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">itemvars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
                    <span class="c1"># pull out the fields: note, by getting the parent fields</span>
                    <span class="c1"># we also get the sub fields name</span>
                    <span class="n">item_dict</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getbaseitem__</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtualfields</span><span class="p">):</span>
                    <span class="c1"># pull out any needed attributes</span>
                    <span class="n">item_dict</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">no_fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># add any aliases</span>
                    <span class="n">aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">:</span>
                        <span class="n">item_dict</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getbaseitem__</span><span class="p">(</span><span class="n">aliases</span><span class="p">[</span><span class="n">it</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;__builtins__&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="n">item_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if the given field name is in self&#39;s fields.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span>

<div class="viewcode-block" id="FieldArray.sort"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort an array, in-place.</span>

<span class="sd">        This function extends the standard numpy record array in-place sort</span>
<span class="sd">        to allow the basic use of Field array virtual fields. Only a single</span>
<span class="sd">        field is currently supported when referencing a virtual field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort. Default is -1, which means sort along the</span>
<span class="sd">            last axis.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">            Sorting algorithm. Default is &#39;quicksort&#39;.</span>
<span class="sd">        order : list, optional</span>
<span class="sd">            When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">            which fields to compare first, second, etc.  Not all fields need be</span>
<span class="sd">            specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot process more than one order field&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">order</span><span class="p">])]</span></div>

<div class="viewcode-block" id="FieldArray.addattr"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.addattr">[docs]</a>    <span class="k">def</span> <span class="nf">addattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an attribute to self. If persistent is True, the attribute will</span>
<span class="sd">        be made a persistent attribute. Persistent attributes are copied</span>
<span class="sd">        whenever a view or copy of this array is created. Otherwise, new views</span>
<span class="sd">        or copies of this will not have the attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># add as persistent</span>
        <span class="k">if</span> <span class="n">persistent</span> <span class="ow">and</span> <span class="n">attrname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__persistent_attributes__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__persistent_attributes__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldArray.add_methods"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.add_methods">[docs]</a>    <span class="k">def</span> <span class="nf">add_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the given method(s) as instance method(s) of self. The</span>
<span class="sd">        method(s) must take `self` as a first argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">methods</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">method</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="FieldArray.add_properties"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.add_properties">[docs]</a>    <span class="k">def</span> <span class="nf">add_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a view of self with the given methods added as properties.</span>

<span class="sd">        From: &lt;http://stackoverflow.com/a/2954373/1366472&gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">methods</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">method</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldArray.add_virtualfields"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.add_virtualfields">[docs]</a>    <span class="k">def</span> <span class="nf">add_virtualfields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a view of this array with the given methods added as virtual</span>
<span class="sd">        fields. Specifically, the given methods are added using add_properties</span>
<span class="sd">        and their names are added to the list of virtual fields. Virtual fields</span>
<span class="sd">        are properties that are assumed to operate on one or more of self&#39;s</span>
<span class="sd">        fields, thus returning an array of values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">methods</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">methods</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">_virtualfields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_virtualfields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_virtualfields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="FieldArray.add_functions"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.add_functions">[docs]</a>    <span class="k">def</span> <span class="nf">add_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">functions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the given functions to the function library.</span>

<span class="sd">        Functions are added to this instance of the array; all copies of</span>
<span class="sd">        and slices of this array will also have the new functions included.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : (list of) string(s)</span>
<span class="sd">            Name or list of names of the functions.</span>
<span class="sd">        functions : (list of) function(s)</span>
<span class="sd">            The function(s) to call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of provided names must be same as number &quot;</span>
                             <span class="s2">&quot;of functions&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_functionlib</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">functions</span><span class="p">)))</span></div>

<div class="viewcode-block" id="FieldArray.del_functions"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.del_functions">[docs]</a>    <span class="k">def</span> <span class="nf">del_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified function names from the function library.</span>

<span class="sd">        Functions are removed from this instance of the array; all copies</span>
<span class="sd">        and slices of this array will also have the functions removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : (list of) string(s)</span>
<span class="sd">            Name or list of names of the functions to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_functionlib</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldArray.from_arrays"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.from_arrays">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_arrays</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new instance of self from the given (list of) array(s).</span>
<span class="sd">        This is done by calling numpy.rec.fromarrays on the given arrays with</span>
<span class="sd">        the given kwargs. The type of the returned array is cast to this</span>
<span class="sd">        class, and the name (if provided) is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arrays : (list of) numpy array(s)</span>
<span class="sd">            A list of the arrays to create the FieldArray from.</span>
<span class="sd">        name : {None|str}</span>
<span class="sd">            What the output array should be named.</span>

<span class="sd">        For other keyword parameters, see the numpy.rec.fromarrays help.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : instance of this class</span>
<span class="sd">            An array that is an instance of this class in which the field</span>
<span class="sd">            data is from the given array(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="FieldArray.from_records"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.from_records">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_records</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new instance of self from the given (list of) record(s).</span>

<span class="sd">        A &quot;record&quot; is a tuple in which each element is the value of one field</span>
<span class="sd">        in the resulting record array. This is done by calling</span>
<span class="sd">        `numpy.rec.fromrecords` on the given records with the given kwargs.</span>
<span class="sd">        The type of the returned array is cast to this class, and the name</span>
<span class="sd">        (if provided) is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        records : (list of) tuple(s)</span>
<span class="sd">            A list of the tuples to create the FieldArray from.</span>
<span class="sd">        name : {None|str}</span>
<span class="sd">            What the output array should be named.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        For other keyword parameters, see the `numpy.rec.fromrecords` help.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : instance of this class</span>
<span class="sd">            An array that is an instance of this class in which the field</span>
<span class="sd">            data is from the given record(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="FieldArray.from_kwargs"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.from_kwargs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kwargs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new instance of self from the given keyword arguments.</span>
<span class="sd">        Each argument will correspond to a field in the returned array, with</span>
<span class="sd">        the name of the field given by the keyword, and the value(s) whatever</span>
<span class="sd">        the keyword was set to. Each keyword may be set to a single value or</span>
<span class="sd">        a list of values. The number of values that each argument is set to</span>
<span class="sd">        must be the same; this will be the size of the returned array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create an array with fields &#39;mass1&#39; and &#39;mass2&#39;:</span>
<span class="sd">        &gt;&gt;&gt; a = FieldArray.from_kwargs(mass1=[1.1, 3.], mass2=[2., 3.])</span>
<span class="sd">        &gt;&gt;&gt; a.fieldnames</span>
<span class="sd">        (&#39;mass1&#39;, &#39;mass2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a.mass1, a.mass2</span>
<span class="sd">        (array([ 1.1,  3. ]), array([ 2.,  3.]))</span>

<span class="sd">        Create an array with only a single element in it:</span>
<span class="sd">        &gt;&gt;&gt; a = FieldArray.from_kwargs(mass1=1.1, mass2=2.)</span>
<span class="sd">        &gt;&gt;&gt; a.mass1, a.mass2</span>
<span class="sd">        (array([ 1.1]), array([ 2.]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="FieldArray.from_ligolw_table"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.from_ligolw_table">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ligolw_table</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cast_to_dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the given ligolw table into an FieldArray. The `tableName`</span>
<span class="sd">        attribute is copied to the array&#39;s `name`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table : LIGOLw table instance</span>
<span class="sd">            The table to convert.</span>
<span class="sd">        columns : {None|list}</span>
<span class="sd">            Optionally specify a list of columns to retrieve. All of the</span>
<span class="sd">            columns must be in the table&#39;s validcolumns attribute. If None</span>
<span class="sd">            provided, all the columns in the table will be converted.</span>
<span class="sd">        dtype : {None | dict}</span>
<span class="sd">            Override the columns&#39; dtypes using the given dictionary. The</span>
<span class="sd">            dictionary should be keyed by the column names, with the values</span>
<span class="sd">            a tuple that can be understood by numpy.dtype. For example, to</span>
<span class="sd">            cast a ligolw column called &quot;foo&quot; to a field called &quot;bar&quot; with</span>
<span class="sd">            type float, cast_to_dtypes would be: ``{&quot;foo&quot;: (&quot;bar&quot;, float)}``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : FieldArray</span>
<span class="sd">            The input table as an FieldArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">tableName</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get all the columns</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">validcolumns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># note: this will raise a KeyError if one or more columns is</span>
            <span class="c1"># not in the table&#39;s validcolumns</span>
            <span class="n">new_columns</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                <span class="n">new_columns</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">validcolumns</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">new_columns</span>
        <span class="k">if</span> <span class="n">cast_to_dtypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">cast_to_dtypes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="c1"># get the values</span>
        <span class="k">if</span> <span class="n">_default_types_status</span><span class="p">[</span><span class="s1">&#39;ilwd_as_int&#39;</span><span class="p">]:</span>
            <span class="n">input_array</span> <span class="o">=</span> \
                <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">if</span> <span class="n">dt</span> <span class="o">!=</span> <span class="s1">&#39;ilwd:char&#39;</span>
                       <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">col</span><span class="p">,</span><span class="n">dt</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_array</span> <span class="o">=</span> \
                <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
        <span class="c1"># return the values as an instance of cls</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldArray.to_array"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.to_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an `numpy.ndarray` of self in which the fields are included</span>
<span class="sd">        as an extra dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fields : {None, (list of) strings}</span>
<span class="sd">            The fields to get. All of the fields must have the same datatype.</span>
<span class="sd">            If None, will try to return all of the fields.</span>
<span class="sd">        axis : {0, int}</span>
<span class="sd">            Which dimension to put the fields in in the returned array. For</span>
<span class="sd">            example, if `self` has shape `(l,m,n)` and `k` fields, the</span>
<span class="sd">            returned array will have shape `(k,l,m,n)` if `axis=0`, `(l,k,m,n)`</span>
<span class="sd">            if `axis=1`, etc. Setting `axis=-1` will put the fields in the</span>
<span class="sd">            last dimension. Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The desired fields as a numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">fields</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fieldnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple listing the field names in self. Equivalent to</span>
<span class="sd">        `array.dtype.names`, where `array` is self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtualfields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple listing the names of virtual fields in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtualfields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vfs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_virtualfields</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functionlib</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the library of functions that are available when calling</span>
<span class="sd">        items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functionlib</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple listing the names of fields and virtual fields in</span>
<span class="sd">        self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">virtualfields</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary of the aliases, or &quot;titles&quot;, of the field names</span>
<span class="sd">        in self. An alias can be specified by passing a tuple in the name</span>
<span class="sd">        part of the dtype. For example, if an array is created with</span>
<span class="sd">        ``dtype=[((&#39;foo&#39;, &#39;bar&#39;), float)]``, the array will have a field</span>
<span class="sd">        called `bar` that has alias `foo` that can be accessed using</span>
<span class="sd">        either `arr[&#39;foo&#39;]` or `arr[&#39;bar&#39;]`. Note that the first string</span>
<span class="sd">        in the dtype is the alias, the second the name. This function returns</span>
<span class="sd">        a dictionary in which the aliases are the keys and the names are the</span>
<span class="sd">        values. Only fields that have aliases are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">))</span>

<div class="viewcode-block" id="FieldArray.add_fields"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.add_fields">[docs]</a>    <span class="k">def</span> <span class="nf">add_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assubarray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the given arrays as new fields to self.  Returns a new instance</span>
<span class="sd">        with the new fields added. Note: this array does not change; the</span>
<span class="sd">        returned array is a new copy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arrays : (list of) numpy array(s)</span>
<span class="sd">            The arrays to add. If adding multiple arrays, must be a list;</span>
<span class="sd">            if adding a single array, can just be that array.</span>
<span class="sd">        names : (list of) strings</span>
<span class="sd">            Optional, the name(s) of the new fields in the output array. If</span>
<span class="sd">            adding multiple fields, must be a list of strings with the same</span>
<span class="sd">            length as the list of arrays. If None provided, names used will</span>
<span class="sd">            be the same as the name of the datatype in the given arrays.</span>
<span class="sd">            If the datatype has no name, the new field will be ``&#39;fi&#39;`` where</span>
<span class="sd">            i is the index of the array in arrays.</span>
<span class="sd">        assubarray : bool</span>
<span class="sd">            Add the list of arrays as a single subarray field. If True, and</span>
<span class="sd">            names provided, names should be a string or a length-1 sequence.</span>
<span class="sd">            Default is False, in which case each array will be added as a</span>
<span class="sd">            separate field.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_array : new instance of this array</span>
<span class="sd">            A copy of this array with the desired fields added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newself</span> <span class="o">=</span> <span class="n">add_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">assubarray</span><span class="o">=</span><span class="n">assubarray</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__copy_attributes__</span><span class="p">(</span><span class="n">newself</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newself</span></div>

<div class="viewcode-block" id="FieldArray.parse_boolargs"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.parse_boolargs">[docs]</a>    <span class="k">def</span> <span class="nf">parse_boolargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array populated by given values, with the indices of</span>
<span class="sd">        those values dependent on given boolen tests on self.</span>

<span class="sd">        The given `args` should be a list of tuples, with the first element the</span>
<span class="sd">        return value and the second argument a string that evaluates to either</span>
<span class="sd">        True or False for each element in self.</span>

<span class="sd">        Each boolean argument is evaluated on elements for which every prior</span>
<span class="sd">        boolean argument was False. For example, if array `foo` has a field</span>
<span class="sd">        `bar`, and `args = [(1, &#39;bar &lt; 10&#39;), (2, &#39;bar &lt; 20&#39;), (3, &#39;bar &lt; 30&#39;)]`,</span>
<span class="sd">        then the returned array will have `1`s at the indices for</span>
<span class="sd">        which `foo.bar &lt; 10`, `2`s where `foo.bar &lt; 20 and not foo.bar &lt; 10`,</span>
<span class="sd">        and `3`s where `foo.bar &lt; 30 and not (foo.bar &lt; 10 or foo.bar &lt; 20)`.</span>

<span class="sd">        The last argument in the list may have &quot;else&quot;, an empty string, None,</span>
<span class="sd">        or simply list a return value. In any of these cases, any element not</span>
<span class="sd">        yet populated will be assigned the last return value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : {(list of) tuples, value}</span>
<span class="sd">            One or more return values and boolean argument determining where</span>
<span class="sd">            they should go.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        return_values : array</span>
<span class="sd">            An array with length equal to self, with values populated with the</span>
<span class="sd">            return values.</span>
<span class="sd">        leftover_indices : array</span>
<span class="sd">            An array of indices that evaluated to False for all arguments.</span>
<span class="sd">            These indices will not have been popluated with any value,</span>
<span class="sd">            defaulting to whatever numpy uses for a zero for the return</span>
<span class="sd">            values&#39; dtype. If there are no leftovers, an empty array is</span>
<span class="sd">            returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Given the following array:</span>

<span class="sd">        &gt;&gt;&gt; arr = FieldArray(5, dtype=[(&#39;mtotal&#39;, float)])</span>
<span class="sd">        &gt;&gt;&gt; arr[&#39;mtotal&#39;] = numpy.array([3., 5., 2., 1., 4.])</span>

<span class="sd">        Return `&quot;TaylorF2&quot;` for all elements with `mtotal &lt; 4` (note that the</span>
<span class="sd">        elements 1 and 4 are leftover):</span>

<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs((&#39;TaylorF2&#39;, &#39;mtotal&lt;4&#39;))</span>
<span class="sd">            (array([&#39;TaylorF2&#39;, &#39;&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;, &#39;&#39;],</span>
<span class="sd">            dtype=&#39;|S8&#39;),</span>
<span class="sd">            array([1, 4]))</span>

<span class="sd">        Return `&quot;TaylorF2&quot;` for all elements with `mtotal &lt; 4`,</span>
<span class="sd">        `&quot;SEOBNR_ROM_DoubleSpin&quot;` otherwise:</span>

<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs([(&#39;TaylorF2&#39;, &#39;mtotal&lt;4&#39;), (&#39;SEOBNRv2_ROM_DoubleSpin&#39;, &#39;else&#39;)])</span>
<span class="sd">            (array([&#39;TaylorF2&#39;, &#39;SEOBNRv2_ROM_DoubleSpin&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;,</span>
<span class="sd">            &#39;SEOBNRv2_ROM_DoubleSpin&#39;],</span>
<span class="sd">            dtype=&#39;|S23&#39;),</span>
<span class="sd">            array([], dtype=int64))</span>

<span class="sd">        The following will also return the same:</span>

<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs([(&#39;TaylorF2&#39;, &#39;mtotal&lt;4&#39;), (&#39;SEOBNRv2_ROM_DoubleSpin&#39;,)])</span>
<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs([(&#39;TaylorF2&#39;, &#39;mtotal&lt;4&#39;), (&#39;SEOBNRv2_ROM_DoubleSpin&#39;, &#39;&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs([(&#39;TaylorF2&#39;, &#39;mtotal&lt;4&#39;), &#39;SEOBNRv2_ROM_DoubleSpin&#39;])</span>

<span class="sd">        Return `&quot;TaylorF2&quot;` for all elements with `mtotal &lt; 3`, `&quot;IMRPhenomD&quot;`</span>
<span class="sd">        for all elements with `3 &lt;= mtotal &lt; 4`, `&quot;SEOBNRv2_ROM_DoubleSpin&quot;`</span>
<span class="sd">        otherwise:</span>

<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs([(&#39;TaylorF2&#39;, &#39;mtotal&lt;3&#39;), (&#39;IMRPhenomD&#39;, &#39;mtotal&lt;4&#39;), &#39;SEOBNRv2_ROM_DoubleSpin&#39;])</span>
<span class="sd">            (array([&#39;IMRPhenomD&#39;, &#39;SEOBNRv2_ROM_DoubleSpin&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;,</span>
<span class="sd">            &#39;SEOBNRv2_ROM_DoubleSpin&#39;],</span>
<span class="sd">            dtype=&#39;|S23&#39;),</span>
<span class="sd">            array([], dtype=int64))</span>

<span class="sd">        Just return `&quot;TaylorF2&quot;` for all elements:</span>

<span class="sd">        &gt;&gt;&gt; arr.parse_boolargs(&#39;TaylorF2&#39;)</span>
<span class="sd">            (array([&#39;TaylorF2&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;, &#39;TaylorF2&#39;],</span>
<span class="sd">            dtype=&#39;|S8&#39;),</span>
<span class="sd">            array([], dtype=int64))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="c1"># format the arguments</span>
        <span class="n">return_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bool_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">return_val</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="n">bool_arg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">return_val</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bool_arg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">return_val</span><span class="p">,</span> <span class="n">bool_arg</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;argument not formatted correctly&quot;</span><span class="p">)</span>
            <span class="n">return_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">return_val</span><span class="p">)</span>
            <span class="n">bool_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bool_arg</span><span class="p">)</span>
        <span class="c1"># get the output dtype</span>
        <span class="n">outdtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">return_vals</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">outdtype</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">leftovers</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,(</span><span class="n">boolarg</span><span class="p">,</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bool_args</span><span class="p">,</span> <span class="n">return_vals</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">boolarg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">boolarg</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">boolarg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;else&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bool_args</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only the last item may not provide &quot;</span>
                        <span class="s2">&quot;any boolean arguments&quot;</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">leftovers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">leftovers</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="p">[</span><span class="n">boolarg</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">leftovers</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">leftovers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="FieldArray.append"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends another array to this array.</span>

<span class="sd">        The returned array will have all of the class methods and virutal</span>
<span class="sd">        fields of this array, including any that were added using `add_method`</span>
<span class="sd">        or `add_virtualfield`. If this array and other array have one or more</span>
<span class="sd">        string fields, the dtype for those fields are updated to a string</span>
<span class="sd">        length that can encompass the longest string in both arrays.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Increasing the length of strings only works for fields, not</span>
<span class="sd">            sub-fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : array</span>
<span class="sd">            The array to append values from. It must have the same fields and</span>
<span class="sd">            dtype as this array, modulo the length of strings. If the other</span>
<span class="sd">            array does not have the same dtype, a TypeError is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            An array with others values appended to this array&#39;s values. The</span>
<span class="sd">            returned array is an instance of the same class as this array,</span>
<span class="sd">            including all methods and virtual fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># see if the dtype error was due to string fields having different</span>
            <span class="c1"># lengths; if so, we&#39;ll make the joint field the larger of the</span>
            <span class="c1"># two</span>
            <span class="n">str_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span>
                          <span class="k">if</span> <span class="n">_isstring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">])]</span>
            <span class="c1"># get the larger of the two</span>
            <span class="n">new_strlens</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">name</span><span class="p">,</span>
                  <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)]</span>
                 <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">str_fields</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># cast both to the new string lengths</span>
            <span class="n">new_dt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new_strlens</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">new_strlens</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="n">new_dt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">new_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">new_dt</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dt</span><span class="p">),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dt</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldArray.parse_parameters"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.FieldArray.parse_parameters">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">possible_fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses a list of parameters to get the list of fields needed in</span>
<span class="sd">        order to evaluate those parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : (list of) string(s)</span>
<span class="sd">            The list of desired parameters. These can be (functions of) fields</span>
<span class="sd">            or virtual fields.</span>
<span class="sd">        possible_fields : (list of) string(s)</span>
<span class="sd">            The list of possible fields.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list :</span>
<span class="sd">            The list of names of the fields that are needed in order to</span>
<span class="sd">            evaluate the given parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">possible_fields</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">possible_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">possible_fields</span><span class="p">]</span>
        <span class="n">possible_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">possible_fields</span><span class="p">))</span>
        <span class="c1"># we&#39;ll just use float as the dtype, as we just need this for names</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">possible_fields</span><span class="p">,</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">possible_fields</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="nb">float</span><span class="p">])))</span>
        <span class="c1"># try to perserve order</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_needed_fieldnames</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">parameters</span><span class="p">))</span></div></div>

<span class="k">def</span> <span class="nf">_isstring</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a numpy dtype, determines whether it is a string. Returns True</span>
<span class="sd">    if the dtype is string or unicode.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unicode_</span> <span class="ow">or</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">string_</span>


<span class="k">def</span> <span class="nf">aliases_from_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a dictionary of fields, will return a dictionary mapping the</span>
<span class="sd">    aliases to the names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">fields_from_names</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a dictionary of fields and a list of names, will return a</span>
<span class="sd">    dictionary consisting of the fields specified by names. Names can be</span>
<span class="sd">    either the names of fields, or their aliases.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fields</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
    <span class="n">aliases_to_names</span> <span class="o">=</span> <span class="n">aliases_from_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
    <span class="n">names_to_aliases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">aliases_to_names</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
        <span class="n">aliases_to_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">outfields</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outfields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">aliases_to_names</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">aliases_to_names</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_to_aliases</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">names_to_aliases</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;default fields has no field </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">outfields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">outfields</span>


<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           FieldArray with default fields</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>

<span class="k">class</span> <span class="nc">_FieldArrayWithDefaults</span><span class="p">(</span><span class="n">FieldArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclasses FieldArray, adding class attribute ``_staticfields``, and</span>
<span class="sd">    class method ``default_fields``. The ``_staticfields`` should be a</span>
<span class="sd">    dictionary that defines some field names and corresponding dtype. The</span>
<span class="sd">    ``default_fields`` method returns a dictionary of the static fields</span>
<span class="sd">    and any default virtualfields that were added. A field array can then</span>
<span class="sd">    be initialized in one of 3 ways:</span>

<span class="sd">     1. With just a shape. In this case, the returned array will have all</span>
<span class="sd">     of the default fields.</span>

<span class="sd">     2. With a shape and a list of names, given by the ``names`` keyword</span>
<span class="sd">     argument. The names may be default fields, virtual fields, a method or</span>
<span class="sd">     property of the class, or any python function of these things. If a</span>
<span class="sd">     virtual field, method, or property is in the names, the needed underlying</span>
<span class="sd">     fields will be included in the return array. For example, if the class</span>
<span class="sd">     has a virtual field called &#39;mchirp&#39;, which is a function of fields called</span>
<span class="sd">     &#39;mass1&#39; and &#39;mass2&#39;, then &#39;mchirp&#39; or any function of &#39;mchirp&#39; may be</span>
<span class="sd">     included in the list of names (e.g., names=[&#39;mchirp**(5/6)&#39;]). If so, the</span>
<span class="sd">     returned array will have fields &#39;mass1&#39; and &#39;mass2&#39; even if these were</span>
<span class="sd">     not specified in names, so that &#39;mchirp&#39; may be used without error.</span>
<span class="sd">     names must be names of either default fields or virtualfields, else a</span>
<span class="sd">     KeyError is raised.</span>

<span class="sd">     3. With a shape and a dtype. Any field specified by the dtype will be</span>
<span class="sd">     used. The fields need not be in the list of default fields, and/or the</span>
<span class="sd">     dtype can be different than that specified by the default fields.</span>

<span class="sd">    If additional fields are desired beyond the default fields, these can</span>
<span class="sd">    be specified using the ``additional_fields`` keyword argument; these should</span>
<span class="sd">    be provided in the same way as ``dtype``; i.e, as a list of (name, dtype)</span>
<span class="sd">    tuples.</span>

<span class="sd">    This class does not define any static fields, and ``default_fields`` just</span>
<span class="sd">    returns an empty dictionary. This class is mostly meant to be subclassed</span>
<span class="sd">    by other classes, so they can add their own defaults.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_staticfields</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">default_fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">include_virtual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The default fields and their dtypes. By default, this returns</span>
<span class="sd">        whatever the class&#39;s ``_staticfields`` and ``_virtualfields`` is set</span>
<span class="sd">        to as a dictionary of fieldname, dtype (the dtype of virtualfields is</span>
<span class="sd">        given by VIRTUALFIELD_DTYPE). This function should be overridden by</span>
<span class="sd">        subclasses to add dynamic fields; i.e., fields that require some input</span>
<span class="sd">        parameters at initialization. Keyword arguments can be passed to this</span>
<span class="sd">        to set such dynamic fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_staticfields</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_virtual</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">VIRTUALFIELD_DTYPE</span>
                           <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_virtualfields</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">field_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The ``additional_fields`` should be specified in the same way as</span>
<span class="sd">        ``dtype`` is normally given to FieldArray. The ``field_kwargs`` are</span>
<span class="sd">        passed to the class&#39;s default_fields method as keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;names&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide names or dtype, not both&quot;</span><span class="p">)</span>
        <span class="n">default_fields</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">default_fields</span><span class="p">(</span><span class="n">include_virtual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">field_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;names&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;names&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="c1"># evaluate the names to figure out what base fields are needed</span>
            <span class="c1"># to do this, we&#39;ll create a small default instance of self (since</span>
            <span class="c1"># no names are specified in the following initialization, this</span>
            <span class="c1"># block of code is skipped)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">field_kwargs</span><span class="o">=</span><span class="n">field_kwargs</span><span class="p">)</span>
            <span class="c1"># try to perserve order</span>
            <span class="n">sortdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([[</span><span class="n">nm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">nm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_needed_fieldnames</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>
            <span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sortdict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sortdict</span>
                <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="c1"># add the fields as the dtype argument for initializing</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">fld</span><span class="p">,</span> <span class="n">default_fields</span><span class="p">[</span><span class="n">fld</span><span class="p">])</span> <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">default_fields</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="c1"># add the additional fields</span>
        <span class="k">if</span> <span class="n">additional_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additional_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">additional_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">additional_fields</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">additional_fields</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_FieldArrayWithDefaults</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_default_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds one or more empty default fields to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : (list of) string(s)</span>
<span class="sd">            The names of the fields to add. Must be a field in self&#39;s default</span>
<span class="sd">            fields.</span>

<span class="sd">        Other keyword args are any arguments passed to self&#39;s default fields.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new array : instance of this array</span>
<span class="sd">            A copy of this array with the field added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="n">default_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_fields</span><span class="p">(</span><span class="n">include_virtual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># parse out any virtual fields</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">field_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># try to perserve order</span>
        <span class="n">sortdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([[</span><span class="n">nm</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">nm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)])</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_needed_fieldnames</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>
        <span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sortdict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sortdict</span>
            <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">default_fields</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">dt</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">dt</span><span class="p">)]))</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">possible_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses a list of parameters to get the list of fields needed in</span>
<span class="sd">        order to evaluate those parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : (list of) strings</span>
<span class="sd">            The list of desired parameters. These can be (functions of) fields</span>
<span class="sd">            or virtual fields.</span>
<span class="sd">        possible_fields : {None, dict}</span>
<span class="sd">            Specify the list of possible fields. Must be a dictionary given</span>
<span class="sd">            the names, and dtype of each possible field. If None, will use this</span>
<span class="sd">            class&#39;s `_staticfields`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list :</span>
<span class="sd">            The list of names of the fields that are needed in order to</span>
<span class="sd">            evaluate the given parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">possible_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># make sure field names are strings and not unicode</span>
            <span class="n">possible_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([[</span><span class="n">f</span><span class="p">,</span> <span class="n">dt</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">dt</span> <span class="ow">in</span> <span class="n">possible_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="k">class</span> <span class="nc">ModifiedArray</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="n">_staticfields</span> <span class="o">=</span> <span class="n">possible_fields</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">ModifiedArray</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">fieldnames</span>

<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1">#                           WaveformArray</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>

<div class="viewcode-block" id="WaveformArray"><a class="viewcode-back" href="../../../pycbc.io.html#pycbc.io.record.WaveformArray">[docs]</a><span class="k">class</span> <span class="nc">WaveformArray</span><span class="p">(</span><span class="n">_FieldArrayWithDefaults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A FieldArray with some default fields and properties commonly used</span>
<span class="sd">    by CBC waveforms. This may be initialized in one of 3 ways:</span>

<span class="sd">    1. With just the size of the array. In this case, the returned array will</span>
<span class="sd">    have all of the default field names. Example:</span>

<span class="sd">    &gt;&gt;&gt; warr = WaveformArray(10)</span>
<span class="sd">    &gt;&gt;&gt; warr.fieldnames</span>
<span class="sd">        (&#39;distance&#39;,</span>
<span class="sd">         &#39;spin2x&#39;,</span>
<span class="sd">         &#39;mass1&#39;,</span>
<span class="sd">         &#39;mass2&#39;,</span>
<span class="sd">         &#39;lambda1&#39;,</span>
<span class="sd">         &#39;polarization&#39;,</span>
<span class="sd">         &#39;spin2y&#39;,</span>
<span class="sd">         &#39;spin2z&#39;,</span>
<span class="sd">         &#39;spin1y&#39;,</span>
<span class="sd">         &#39;spin1x&#39;,</span>
<span class="sd">         &#39;spin1z&#39;,</span>
<span class="sd">         &#39;inclination&#39;,</span>
<span class="sd">         &#39;coa_phase&#39;,</span>
<span class="sd">         &#39;dec&#39;,</span>
<span class="sd">         &#39;tc&#39;,</span>
<span class="sd">         &#39;lambda2&#39;,</span>
<span class="sd">         &#39;ra&#39;)</span>

<span class="sd">    2. With some subset of the default field names. Example:</span>

<span class="sd">    &gt;&gt;&gt; warr = WaveformArray(10, names=[&#39;mass1&#39;, &#39;mass2&#39;])</span>
<span class="sd">    &gt;&gt;&gt; warr.fieldnames</span>
<span class="sd">        (&#39;mass1&#39;, &#39;mass2&#39;)</span>

<span class="sd">    The list of names may include virtual fields, and methods, as well as</span>
<span class="sd">    functions of these. If one or more virtual fields or methods are specified,</span>
<span class="sd">    the source code is analyzed to pull out whatever underlying fields are</span>
<span class="sd">    needed. Example:</span>

<span class="sd">    &gt;&gt;&gt; warr = WaveformArray(10, names=[&#39;mchirp**(5/6)&#39;, &#39;chi_eff&#39;, &#39;cos(coa_phase)&#39;])</span>
<span class="sd">    &gt;&gt;&gt; warr.fieldnames</span>
<span class="sd">        (&#39;spin2z&#39;, &#39;mass1&#39;, &#39;mass2&#39;, &#39;coa_phase&#39;, &#39;spin1z&#39;)</span>

<span class="sd">    3. By specifying a dtype. In this case, only the provided fields will</span>
<span class="sd">    be used, even if they are not in the defaults. Example:</span>

<span class="sd">    &gt;&gt;&gt; warr = WaveformArray(10, dtype=[(&#39;foo&#39;, float)])</span>
<span class="sd">    &gt;&gt;&gt; warr.fieldnames</span>
<span class="sd">        (&#39;foo&#39;,)</span>

<span class="sd">    Additional fields can also be specified using the additional_fields</span>
<span class="sd">    keyword argument. Example:</span>

<span class="sd">    &gt;&gt;&gt; warr = WaveformArray(10, names=[&#39;mass1&#39;, &#39;mass2&#39;], additional_fields=[(&#39;bar&#39;, float)])</span>
<span class="sd">    &gt;&gt;&gt; warr.fieldnames</span>
<span class="sd">        (&#39;mass1&#39;, &#39;mass2&#39;, &#39;bar&#39;)</span>

<span class="sd">    .. note::</span>
<span class="sd">        If an array is initialized with all of the default fields (case 1,</span>
<span class="sd">        above), then the names come from waveform.parameters; i.e., they</span>
<span class="sd">        are actually Parameter instances, not just strings. This means that the</span>
<span class="sd">        field names carry all of the metadata that a Parameter has. For</span>
<span class="sd">        example:</span>

<span class="sd">        &gt;&gt;&gt; warr = WaveformArray(10)</span>
<span class="sd">        &gt;&gt;&gt; warr.fields[0]</span>
<span class="sd">            &#39;distance&#39;</span>
<span class="sd">        &gt;&gt;&gt; warr.fields[0].description</span>
<span class="sd">            &#39;Luminosity distance to the binary (in Mpc).&#39;</span>
<span class="sd">        &gt;&gt;&gt; warr.fields[0].label</span>
<span class="sd">            &#39;$d_L$ (Mpc)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_staticfields</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">cbc_intrinsic_params</span> <span class="o">+</span>
                     <span class="n">parameters</span><span class="o">.</span><span class="n">extrinsic_params</span><span class="p">)</span><span class="o">.</span><span class="n">dtype_dict</span>

    <span class="n">_virtualfields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">mtotal</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">primary_mass</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">secondary_mass</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">spin_px</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin_py</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin_pz</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">spin_sx</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin_sy</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin_sz</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_a</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin1_polar</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_a</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_azimuthal</span><span class="p">,</span> <span class="n">parameters</span><span class="o">.</span><span class="n">spin2_polar</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">primary_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the larger of self.mass1 and self.mass2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_mass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">secondary_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the smaller of self.mass1 and self.mass2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_mass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mtotal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the total mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mtotal_from_mass1_mass2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the mass ratio m1/m2, where m1 &gt;= m2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">q_from_mass1_mass2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the symmetric mass ratio.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">eta_from_mass1_mass2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mchirp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the chirp mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">mchirp_from_mass1_mass2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chi_eff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the effective spin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">chi_eff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">spin2z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_px</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the x-component of the spin of the primary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2x</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_py</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the y-component of the spin of the primary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2y</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_pz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the z-component of the spin of the primary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">primary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_sx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the x-component of the spin of the secondary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2x</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_sy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the y-component of the spin of the secondary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2y</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin_sz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the z-component of the spin of the secondary mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">conversions</span><span class="o">.</span><span class="n">secondary_spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">spin2z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin1_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the dimensionless spin magnitude of mass 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_rho</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin1_azimuthal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the azimuthal spin angle of mass 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_azimuthal</span><span class="p">(</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin1_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the polar spin angle of mass 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_polar</span><span class="p">(</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin2_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the dimensionless spin magnitude of mass 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_rho</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">spin1x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin1z</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin2_azimuthal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the azimuthal spin angle of mass 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_azimuthal</span><span class="p">(</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin2y</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spin2_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the polar spin angle of mass 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">cartesian_to_spherical_polar</span><span class="p">(</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">spin2x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin2y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin2z</span><span class="p">)</span></div>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FieldArray&#39;</span><span class="p">,</span> <span class="s1">&#39;WaveformArray&#39;</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, 2016, 2017, Alexander Nitz, Ian Harry, Christopher M. Biwer, Duncan A.  Brown, Josh Willis, and Tito Dal Canton.
      <span class="lastupdated">Last updated on Oct 20, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>