<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pycbc.inference.sampler package &mdash; PyCBC 0.0a8230 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/terminal.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/typed.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pycbc.inject package" href="pycbc.inject.html" />
    <link rel="prev" title="pycbc.inference.models package" href="pycbc.inference.models.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> PyCBC
          </a>
              <div class="version">
                1.18.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="credit.html">Use of PyCBC in Scientific Publications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="docker.html">Running PyCBC under Docker</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="inference.html">PyCBC inference documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.inference</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_psd_estimation_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_psd_estimation_workflow</span></code>: A workflow generator for noise estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_coinc_search_workflow.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_coinc_search_workflow</span></code>: A workflow to search for gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pygrb.html"><code class="docutils literal notranslate"><span class="pre">pycbc_make_offline_grb_workflow</span></code>: A GRB triggered CBC analysis workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tmpltbank.html">PyCBC template bank generation documentation (<code class="docutils literal notranslate"><span class="pre">pycbc.tmpltbank</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwinj.html">Hardware injection waveform generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="banksim.html">Calculating the Effectualness (Fitting Factor) of Template Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="faithsim.html">Dag Generator for Doing Faithfulness Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="upload_to_gracedb.html">Uploading triggers to gracedb</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="waveform_plugin.html">Making new waveform approximants available to PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="catalog.html">Catalog of Observed Gravitational-wave Mergers</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataquality.html">Query times of valid data, hardware injections, and more.</a></li>
<li class="toctree-l1"><a class="reference internal" href="frame.html">Reading Gravitational-wave Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Performing FFTs in PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="gw150914.html">Signal Processing with GW150914</a></li>
<li class="toctree-l1"><a class="reference internal" href="detector.html">Gravitational-wave Detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="psd.html">Handling PSDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Generating Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="waveform.html">Waveforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">Using PyCBC Distributions from PyCBC Inference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="building_bundled_executables.html">Building Bundled Executables</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documenting PyCBC code</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Creating Releases of PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="formats/hdf_format.html">HDF files within the PyCBC workflow</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Workflow: the inspiral analysis workflow generator (<code class="docutils literal notranslate"><span class="pre">pycbc.workflow</span></code>)</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pycbc</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pycbc.html">pycbc package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pycbc.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pycbc.catalog.html">pycbc.catalog package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.distributions.html">pycbc.distributions package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.events.html">pycbc.events package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.fft.html">pycbc.fft package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.filter.html">pycbc.filter package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.frame.html">pycbc.frame package</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="pycbc.inference.html">pycbc.inference package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.inject.html">pycbc.inject package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.io.html">pycbc.io package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.noise.html">pycbc.noise package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.population.html">pycbc.population package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.psd.html">pycbc.psd package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.results.html">pycbc.results package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.strain.html">pycbc.strain package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.tmpltbank.html">pycbc.tmpltbank package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.types.html">pycbc.types package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.vetoes.html">pycbc.vetoes package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.waveform.html">pycbc.waveform package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.workflow.html">pycbc.workflow package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.bin_utils">pycbc.bin_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.boundaries">pycbc.boundaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.conversions">pycbc.conversions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.coordinates">pycbc.coordinates module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.cosmology">pycbc.cosmology module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.detector">pycbc.detector module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.dq">pycbc.dq module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.libutils">pycbc.libutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.mchirp_area">pycbc.mchirp_area module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.opt">pycbc.opt module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.pnutils">pycbc.pnutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.pool">pycbc.pool module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.rate">pycbc.rate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.scheme">pycbc.scheme module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.sensitivity">pycbc.sensitivity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.transforms">pycbc.transforms module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.version">pycbc.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyCBC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="modules.html">pycbc</a> &raquo;</li>
          <li><a href="pycbc.html">pycbc package</a> &raquo;</li>
          <li><a href="pycbc.inference.html">pycbc.inference package</a> &raquo;</li>
      <li>pycbc.inference.sampler package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pycbc.inference.sampler.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="pycbc-inference-sampler-package">
<h1>pycbc.inference.sampler package<a class="headerlink" href="#pycbc-inference-sampler-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pycbc.inference.sampler.base">
<span id="pycbc-inference-sampler-base-module"></span><h2>pycbc.inference.sampler.base module<a class="headerlink" href="#module-pycbc.inference.sampler.base" title="Permalink to this headline">¶</a></h2>
<p>Defines the base sampler class to be inherited by all samplers.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.base.BaseSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.base.</code><code class="descname">BaseSampler</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract base class for all inference samplers.</p>
<p>All sampler classes must inherit from this class and implement its abstract
methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model</strong> (<em>Model</em>) – An instance of a model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler.base.BaseSampler.checkpoint">
<code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler.checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The sampler must have a checkpoint method for dumping raw samples
and stats to the file type defined by <code class="docutils literal notranslate"><span class="pre">io</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base.BaseSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Do any finalization to the samples file before exiting.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base.BaseSampler.from_config">
<code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>This should initialize the sampler given a config file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping model’s metadata fields to arrays of values for
each sample in <code class="docutils literal notranslate"><span class="pre">raw_samples</span></code>.</p>
<p>The arrays may have any shape, and may or may not be thinned.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.name">
<code class="descname">name</code><em class="property"> = None</em><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base.BaseSampler.resume_from_checkpoint">
<code class="descname">resume_from_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler.resume_from_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.resume_from_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the sampler from the output file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base.BaseSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#BaseSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should run the sampler.</p>
<p>Any checkpointing should be done internally in this function.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping variable_params to arrays of samples currently
in memory. The dictionary may also contain sampling_params.</p>
<p>The sample arrays may have any shape, and may or may not be thinned.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.sampling_params">
<code class="descname">sampling_params</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.sampling_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sampling params used by the model.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.static_params">
<code class="descname">static_params</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.static_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model’s fixed parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base.BaseSampler.variable_params">
<code class="descname">variable_params</code><a class="headerlink" href="#pycbc.inference.sampler.base.BaseSampler.variable_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parameters varied in the model.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base.create_new_output_file">
<code class="descclassname">pycbc.inference.sampler.base.</code><code class="descname">create_new_output_file</code><span class="sig-paren">(</span><em>sampler</em>, <em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#create_new_output_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.create_new_output_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new output file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sampler</strong> (<em>sampler instance</em>) – Sampler</li>
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the file to create.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed through to the file’s
<code class="docutils literal notranslate"><span class="pre">write_metadata</span></code> function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base.initial_dist_from_config">
<code class="descclassname">pycbc.inference.sampler.base.</code><code class="descname">initial_dist_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>variable_params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#initial_dist_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.initial_dist_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a distribution for the sampler start from the given config file.</p>
<p>A distribution will only be loaded if the config file has a [initial-*]
section(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>Config parser</em>) – The config parser to try to load from.</li>
<li><strong>variable_params</strong> (<em>list of str</em>) – The variable parameters for the distribution.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The initial distribution. If no [initial-*] section found in the
config file, will just return None.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="pycbc.distributions.html#pycbc.distributions.joint.JointDistribution" title="pycbc.distributions.joint.JointDistribution">JointDistribution</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)">None</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base.setup_output">
<code class="descclassname">pycbc.inference.sampler.base.</code><code class="descname">setup_output</code><span class="sig-paren">(</span><em>sampler</em>, <em>output_file</em>, <em>check_nsamples=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base.html#setup_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base.setup_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the sampler’s checkpoint and output files.</p>
<p>The checkpoint file has the same name as the output file, but with
<code class="docutils literal notranslate"><span class="pre">.checkpoint</span></code> appended to the name. A backup file will also be
created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sampler</strong> (<em>sampler instance</em>) – Sampler</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.base_cube">
<span id="pycbc-inference-sampler-base-cube-module"></span><h2>pycbc.inference.sampler.base_cube module<a class="headerlink" href="#module-pycbc.inference.sampler.base_cube" title="Permalink to this headline">¶</a></h2>
<p>Common utilities for samplers that rely on transforming between a unit cube
and the prior space. This is typical of many nested sampling algorithms.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.base_cube.CubeModel">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.base_cube.</code><code class="descname">CubeModel</code><span class="sig-paren">(</span><em>model</em>, <em>loglikelihood_function=None</em>, <em>copy_prior=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#CubeModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.CubeModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class for making PyCBC Inference ‘model class’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model</strong> (<em>inference.BaseModel instance</em>) – A model instance from pycbc.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler.base_cube.CubeModel.log_likelihood">
<code class="descname">log_likelihood</code><span class="sig-paren">(</span><em>cube</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#CubeModel.log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.CubeModel.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>returns log likelihood function</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_cube.CubeModel.prior_transform">
<code class="descname">prior_transform</code><span class="sig-paren">(</span><em>cube</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#CubeModel.prior_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.CubeModel.prior_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>prior transform function for ultranest sampler
It takes unit cube as input parameter and apply
prior transforms</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_cube.call_global_loglikelihood">
<code class="descclassname">pycbc.inference.sampler.base_cube.</code><code class="descname">call_global_loglikelihood</code><span class="sig-paren">(</span><em>cube</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#call_global_loglikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.call_global_loglikelihood" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_cube.call_global_logprior">
<code class="descclassname">pycbc.inference.sampler.base_cube.</code><code class="descname">call_global_logprior</code><span class="sig-paren">(</span><em>cube</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#call_global_logprior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.call_global_logprior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_cube.setup_calls">
<code class="descclassname">pycbc.inference.sampler.base_cube.</code><code class="descname">setup_calls</code><span class="sig-paren">(</span><em>model</em>, <em>loglikelihood_function=None</em>, <em>copy_prior=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_cube.html#setup_calls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_cube.setup_calls" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure calls for MPI support</p>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.base_mcmc">
<span id="pycbc-inference-sampler-base-mcmc-module"></span><h2>pycbc.inference.sampler.base_mcmc module<a class="headerlink" href="#module-pycbc.inference.sampler.base_mcmc" title="Permalink to this headline">¶</a></h2>
<p>Provides constructor classes and convenience functions for MCMC samplers.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">BaseMCMC</code><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract base class that provides methods common to MCMCs.</p>
<p>This is not a sampler class itself. Sampler classes can inherit from this
along with <code class="docutils literal notranslate"><span class="pre">BaseSampler</span></code>.</p>
<p>This class provides <code class="docutils literal notranslate"><span class="pre">set_initial_conditions</span></code>, <code class="docutils literal notranslate"><span class="pre">run</span></code>, and <code class="docutils literal notranslate"><span class="pre">checkpoint</span></code>
methods, which are some of the abstract methods required by
<code class="docutils literal notranslate"><span class="pre">BaseSampler</span></code>.</p>
<p>This class introduces the following abstract properties and methods:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>base_shape</dt>
<dd>[<cite>property</cite>] Should give the shape of the samples arrays used by the
sampler, excluding the iteraitons dimension. Needed for writing
results.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>run_mcmc(niterations)</dt>
<dd>Should run the sampler for the given number of iterations. Called by
<code class="docutils literal notranslate"><span class="pre">run</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>clear_samples()</dt>
<dd>Should clear samples from memory. Called by <code class="docutils literal notranslate"><span class="pre">run</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>set_state_from_file(filename)</dt>
<dd>Should set the random state of the sampler using the given filename.
Called by <code class="docutils literal notranslate"><span class="pre">set_initial_conditions</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>write_results(filename)</dt>
<dd>Writes results to the given filename. Called by <code class="docutils literal notranslate"><span class="pre">checkpoint</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>compute_acf(filename, **kwargs)</dt>
<dd>[<cite>classmethod</cite>] Should compute the autocorrelation function using
the given filename. Also allows for other keyword arguments.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>compute_acl(filename, **kwargs)</dt>
<dd>[<cite>classmethod</cite>] Should compute the autocorrelation length using
the given filename. Also allows for other keyword arguments.</dd>
</dl>
</li>
</ul>
<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.p0">
<code class="descname">p0</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.p0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.pos">
<code class="descname">pos</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.nchains">
<code class="descname">nchains</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.nchains" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.niterations">
<code class="descname">niterations</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.niterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_interval">
<code class="descname">checkpoint_interval</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_signal">
<code class="descname">checkpoint_signal</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_signal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.target_niterations">
<code class="descname">target_niterations</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.target_niterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.target_eff_nsamples">
<code class="descname">target_eff_nsamples</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.target_eff_nsamples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.thin_interval">
<code class="descname">thin_interval</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.thin_interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.max_samples_per_chain">
<code class="descname">max_samples_per_chain</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.max_samples_per_chain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.thin_safety_factor">
<code class="descname">thin_safety_factor</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.thin_safety_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.burn_in">
<code class="descname">burn_in</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.burn_in" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.effective_nsamples">
<code class="descname">effective_nsamples</code><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.effective_nsamples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.effective_nsamples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.acl">
<code class="descname">acl</code><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.acl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.raw_acls">
<code class="descname">raw_acls</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.raw_acls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.act">
<code class="descname">act</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.act" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.raw_acts">
<code class="descname">raw_acts</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.raw_acts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">acl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.acl"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The autocorrelation length.</p>
<p>This method should convert the raw ACLs into an integer or array that
can be used to extract independent samples from a chain.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">act</code></dt>
<dd><p>The autocorrelation time(s).</p>
<p>The autocorrelation time is defined as the autocorrelation length times
the <code class="docutils literal notranslate"><span class="pre">thin_interval</span></code>. It gives the number of iterations between
independent samples. Depending on the sampler, this may either be
a single integer or an array of values.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if no ACLs have been calculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.base_shape">
<code class="descname">base_shape</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.base_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>What shape the sampler’s samples arrays are in, excluding
the iterations dimension.</p>
<p>For example, if a sampler uses 20 chains and 3 temperatures, this
would be <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">20)</span></code>. If a sampler only uses a single walker and no
temperatures this would be <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">burn_in</code></dt>
<dd><p>The class for doing burn-in tests (if specified).</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint">
<code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps current samples to the checkpoint file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_from_config">
<em class="property">static </em><code class="descname">checkpoint_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.checkpoint_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.checkpoint_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the checkpoint interval from the given config file.</p>
<p>This looks for ‘checkpoint-interval’ in the section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>ConfigParser</em>) – Open config parser to retrieve the argument from.</li>
<li><strong>section</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the section to retrieve from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The checkpoint interval, if it is in the section. Otherw</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)">int</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)">None</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">checkpoint_interval</code></dt>
<dd><p>The number of iterations to do between checkpoints.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">checkpoint_signal</code></dt>
<dd><p>The signal to use when checkpointing.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.ckpt_signal_from_config">
<em class="property">static </em><code class="descname">ckpt_signal_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.ckpt_signal_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.ckpt_signal_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the checkpoint signal from the given config file.</p>
<p>This looks for ‘checkpoint-signal’ in the section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>ConfigParser</em>) – Open config parser to retrieve the argument from.</li>
<li><strong>section</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the section to retrieve from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The checkpoint interval, if it is in the section. Otherw</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)">int</a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)">None</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.clear_samples">
<code class="descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.clear_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to clear samples from memory.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.compute_acf">
<code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to compute the autocorrelation function of samples in the
given file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.compute_acl">
<code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to compute the autocorrelation length of samples in the
given file.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">effective_nsamples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.effective_nsamples"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The effective number of samples post burn-in that the sampler has
acquired so far.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.get_thin_interval">
<code class="descname">get_thin_interval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.get_thin_interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.get_thin_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the thin interval to use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_samples_per_chain</span></code> is set, this will figure out what thin
interval is needed to satisfy that criteria. In that case, the thin
interval used must be a multiple of the currently used thin interval.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">max_samples_per_chain</code></dt>
<dd><p>The maximum number of samplers per chain that is written to disk.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nchains</code></dt>
<dd><p>The number of chains used.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">niterations</code></dt>
<dd><p>The current number of iterations.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">p0</code></dt>
<dd><p>A dictionary of the initial position of the chains.</p>
<p>This is set by using <code class="docutils literal notranslate"><span class="pre">set_p0</span></code>. If not set yet, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is
raised when the attribute is accessed.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">pos</code></dt>
<dd><p>A dictionary of the current walker positions.</p>
<p>If the sampler hasn’t been run yet, returns p0.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">raw_acls</code></dt>
<dd><p>Dictionary of parameter names -&gt; autocorrelation lengths.</p>
<p>Depending on the sampler, the ACLs may be an integer, or an arrray of
values per chain and/or per temperature.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if no ACLs have been calculated.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">raw_acts</code></dt>
<dd><p>Dictionary of parameter names -&gt; autocorrelation time(s).</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if no ACLs have been calculated.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.resume_from_checkpoint">
<code class="descname">resume_from_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.resume_from_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.resume_from_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the sampler from the checkpoint file</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the sampler.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.run_mcmc">
<code class="descname">run_mcmc</code><span class="sig-paren">(</span><em>niterations</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.run_mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.run_mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the MCMC for the given number of iterations.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_burn_in">
<code class="descname">set_burn_in</code><span class="sig-paren">(</span><em>burn_in</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_burn_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the object to use for doing burn-in tests.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_burn_in_from_config">
<code class="descname">set_burn_in_from_config</code><span class="sig-paren">(</span><em>cp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_burn_in_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_burn_in_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the burn in class from the given config file.</p>
<p>If no burn-in section exists in the file, then this just set the
burn-in class to None.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_p0">
<code class="descname">set_p0</code><span class="sig-paren">(</span><em>samples_file=None</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_p0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_p0" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial position of the chains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples_file</strong> (<em>InferenceFile</em><em>, </em><em>optional</em>) – If provided, use the last iteration in the given file for the
starting positions.</li>
<li><strong>prior</strong> (<a class="reference internal" href="pycbc.distributions.html#pycbc.distributions.joint.JointDistribution" title="pycbc.distributions.joint.JointDistribution"><em>JointDistribution</em></a><em>, </em><em>optional</em>) – Use the given prior to set the initial positions rather than
<code class="docutils literal notranslate"><span class="pre">model</span></code>’s prior.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p0</strong> – A dictionary maping sampling params to the starting positions.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_start_from_config">
<code class="descname">set_start_from_config</code><span class="sig-paren">(</span><em>cp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_start_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_start_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial state of the sampler from config file</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler to the instance saved in a file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_target">
<code class="descname">set_target</code><span class="sig-paren">(</span><em>niterations=None</em>, <em>eff_nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the target niterations/nsamples for the sampler.</p>
<p>One or the other must be provided, not both.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_target_from_config">
<code class="descname">set_target_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_target_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_target_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the target using the given config file.</p>
<p>This looks for <code class="docutils literal notranslate"><span class="pre">niterations</span></code> to set the <code class="docutils literal notranslate"><span class="pre">target_niterations</span></code>, and
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> to set the <code class="docutils literal notranslate"><span class="pre">target_eff_nsamples</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cp</strong> (<em>ConfigParser</em>) – Open config parser to retrieve the argument from.</li>
<li><strong>section</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the section to retrieve from.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.set_thin_interval_from_config">
<code class="descname">set_thin_interval_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.set_thin_interval_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.set_thin_interval_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets thinning options from the given config file.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">target_eff_nsamples</code></dt>
<dd><p>The target number of effective samples the sampler should get.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">target_niterations</code></dt>
<dd><p>The number of iterations the sampler should run for.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">thin_interval</code></dt>
<dd><p>Returns the thin interval being used.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">thin_safety_factor</code></dt>
<dd><p>The minimum value that <code class="docutils literal notranslate"><span class="pre">max_samples_per_chain</span></code> may be set to.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.base_mcmc.BaseMCMC.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#BaseMCMC.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Should write all samples currently in memory to the given file.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.sampler.base_mcmc.EnsembleSupport">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">EnsembleSupport</code><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#EnsembleSupport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Adds support for ensemble MCMC samplers.</p>
<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.EnsembleSupport.acl">
<code class="descname">acl</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport.acl" title="Permalink to this definition">¶</a></dt>
<dd><p>The autocorrelation length of the ensemble.</p>
<p>This is calculated by taking the maximum over all of the <code class="docutils literal notranslate"><span class="pre">raw_acls</span></code>.
This works for both single and parallel-tempered ensemble samplers.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if no ACLs have been set.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.EnsembleSupport.effective_nsamples">
<code class="descname">effective_nsamples</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport.effective_nsamples" title="Permalink to this definition">¶</a></dt>
<dd><p>The effective number of samples post burn-in that the sampler has
acquired so far.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_mcmc.EnsembleSupport.nwalkers">
<code class="descname">nwalkers</code><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport.nwalkers" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of walkers used.</p>
<p>Alias of <code class="docutils literal notranslate"><span class="pre">nchains</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_mcmc.blob_data_to_dict">
<code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">blob_data_to_dict</code><span class="sig-paren">(</span><em>stat_names</em>, <em>blobs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#blob_data_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.blob_data_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts list of “blobs” to a dictionary of model stats.</p>
<p>Samplers like <code class="docutils literal notranslate"><span class="pre">emcee</span></code> store the extra tuple returned by <code class="docutils literal notranslate"><span class="pre">CallModel</span></code> to
a list called blobs. This is a list of lists of tuples with shape
niterations x nwalkers x nstats, where nstats is the number of stats
returned by the model’s <code class="docutils literal notranslate"><span class="pre">default_stats</span></code>. This converts that list to a
dictionary of arrays keyed by the stat names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stat_names</strong> (<em>list of str</em>) – The list of the stat names.</li>
<li><strong>blobs</strong> (<em>list of list of tuples</em>) – The data to convert.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary mapping the model’s <code class="docutils literal notranslate"><span class="pre">default_stats</span></code> to arrays of values.
Each array will have shape <code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_mcmc.ensemble_compute_acf">
<code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">ensemble_compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>per_walker=False</em>, <em>walkers=None</em>, <em>parameters=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#ensemble_compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.ensemble_compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation function for an ensemble MCMC.</p>
<p>By default, parameter values are averaged over all walkers at each
iteration. The ACF is then calculated over the averaged chain. An
ACF per-walker will be returned instead if <code class="docutils literal notranslate"><span class="pre">per_walker=True</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>start_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The start index to compute the acl from. If None (the default), will
try to use the number of burn-in iterations in the file; otherwise,
will start at the first sample.</li>
<li><strong>end_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The end index to compute the acl to. If None (the default), will go to
the end of the current iteration.</li>
<li><strong>per_walker</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Return the ACF for each walker separately. Default is False.</li>
<li><strong>walkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>array</em><em>, </em><em>optional</em>) – Calculate the ACF using only the given walkers. If None (the
default) all walkers will be used.</li>
<li><strong>parameters</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em> or </em><em>array</em><em>, </em><em>optional</em>) – Calculate the ACF for only the given parameters. If None (the
default) will calculate the ACF for all of the model params.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. If
<code class="docutils literal notranslate"><span class="pre">per-walker</span></code> is True, the arrays will have shape
<code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_mcmc.ensemble_compute_acl">
<code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">ensemble_compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>min_nsamples=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#ensemble_compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.ensemble_compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation length for an ensemble MCMC.</p>
<p>Parameter values are averaged over all walkers at each iteration.
The ACL is then calculated over the averaged chain. If an ACL cannot
be calculated because there are not enough samples, it will be set
to <code class="docutils literal notranslate"><span class="pre">inf</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>start_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The start index to compute the acl from. If None, will try to use
the number of burn-in iterations in the file; otherwise, will start
at the first sample.</li>
<li><strong>end_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The end index to compute the acl to. If None, will go to the end
of the current iteration.</li>
<li><strong>min_nsamples</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Require a minimum number of samples to compute an ACL. If the
number of samples per walker is less than this, will just set to
<code class="docutils literal notranslate"><span class="pre">inf</span></code>. Default is 10.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary giving the ACL for each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_mcmc.get_optional_arg_from_config">
<code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">get_optional_arg_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>arg</em>, <em>dtype=&lt;class 'str'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#get_optional_arg_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.get_optional_arg_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to retrieve an optional argument from a config
file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>ConfigParser</em>) – Open config parser to retrieve the argument from.</li>
<li><strong>section</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the section to retrieve from.</li>
<li><strong>arg</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the argument to retrieve.</li>
<li><strong>dtype</strong> (<em>datatype</em><em>, </em><em>optional</em>) – Cast the retrieved value (if it exists) to the given datatype. Default
is <code class="docutils literal notranslate"><span class="pre">str</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>val</strong> – If the argument is present, the value. Otherwise, None.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)">None</a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)">str</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_mcmc.raw_samples_to_dict">
<code class="descclassname">pycbc.inference.sampler.base_mcmc.</code><code class="descname">raw_samples_to_dict</code><span class="sig-paren">(</span><em>sampler</em>, <em>raw_samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_mcmc.html#raw_samples_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_mcmc.raw_samples_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for converting ND array to a dict of samples.</p>
<p>The samples are assumed to have dimension
<code class="docutils literal notranslate"><span class="pre">[sampler.base_shape</span> <span class="pre">x]</span> <span class="pre">niterations</span> <span class="pre">x</span> <span class="pre">len(sampler.sampling_params)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sampler</strong> (<em>sampler instance</em>) – An instance of an MCMC sampler.</li>
<li><strong>raw_samples</strong> (<em>array</em>) – The array of samples to convert.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary mapping the raw samples to the variable params. If the
sampling params are not the same as the variable params, they will
also be included. Each array will have shape
<code class="docutils literal notranslate"><span class="pre">[sampler.base_shape</span> <span class="pre">x]</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.base_multitemper">
<span id="pycbc-inference-sampler-base-multitemper-module"></span><h2>pycbc.inference.sampler.base_multitemper module<a class="headerlink" href="#module-pycbc.inference.sampler.base_multitemper" title="Permalink to this headline">¶</a></h2>
<p>Provides constructor classes provide support for parallel tempered MCMC
samplers.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.base_multitemper.MultiTemperedSupport">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">MultiTemperedSupport</code><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#MultiTemperedSupport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.MultiTemperedSupport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Provides methods for supporting multi-tempered samplers.</p>
<dl class="staticmethod">
<dt id="pycbc.inference.sampler.base_multitemper.MultiTemperedSupport.betas_from_config">
<em class="property">static </em><code class="descname">betas_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#MultiTemperedSupport.betas_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.MultiTemperedSupport.betas_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads number of temperatures or betas from a config file.</p>
<p>This looks in the given section for:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ntemps</span></code> :</dt>
<dd>The number of temperatures to use. Either this, or
<code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> :</dt>
<dd>Path to an hdf file containing the inverse temperatures (“betas”)
to use. The betas will be retrieved from the file’s
<code class="docutils literal notranslate"><span class="pre">.attrs['betas']</span></code>. Either this or <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> must be provided
(but not both).</dd>
</dl>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>WorkflowConfigParser instance</em>) – Config file object to parse.</li>
<li><strong>section</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The name of the section to look in.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>ntemps</strong> (<em>int or None</em>) – The number of temperatures to use, if it was provided.</li>
<li><strong>betas</strong> (<em>array</em>) – The array of betas to use, if a inverse-temperatures-file was
provided.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.base_multitemper.MultiTemperedSupport.ntemps">
<code class="descname">ntemps</code><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.MultiTemperedSupport.ntemps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of temeratures that are set.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.acl_from_raw_acls">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">acl_from_raw_acls</code><span class="sig-paren">(</span><em>acls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#acl_from_raw_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.acl_from_raw_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the ACL for one or more chains from a dictionary of ACLs.</p>
<p>This is for parallel tempered MCMCs in which the chains are independent
of each other.</p>
<p>The ACL for each chain is maximized over the temperatures and parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>acls</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary of parameter names -&gt; ntemps x nchains arrays of ACLs (the
thing returned by <a class="reference internal" href="#pycbc.inference.sampler.base_multitemper.compute_acl" title="pycbc.inference.sampler.base_multitemper.compute_acl"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_acl()</span></code></a>).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The ACL of each chain.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.compute_acf">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>chains=None</em>, <em>parameters=None</em>, <em>temps=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation function for independent MCMC chains with
parallel tempering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>start_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The start index to compute the acl from. If None (the default),
will try to use the burn in iteration for each chain;
otherwise, will start at the first sample.</li>
<li><strong>end_index</strong> (<em>{None</em><em>, </em><em>int}</em>) – The end index to compute the acl to. If None, will go to the end
of the current iteration.</li>
<li><strong>chains</strong> (<em>optional</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>array</em>) – Calculate the ACF for only the given chains. If None (the
default) ACFs for all chains will be estimated.</li>
<li><strong>parameters</strong> (<em>optional</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em> or </em><em>array</em>) – Calculate the ACF for only the given parameters. If None (the
default) will calculate the ACF for all of the model params.</li>
<li><strong>temps</strong> (<em>optional</em><em>, </em><em>(</em><em>list of</em><em>) </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>'all'</em>) – The temperature index (or list of indices) to retrieve. If None
(the default), the ACF will only be computed for the coldest (= 0)
temperature chain. To compute an ACF for all temperates pass ‘all’,
or a list of all of the temperatures.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary parameter name -&gt; ACF arrays. The arrays have shape
<code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nchains</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.compute_acl">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>min_nsamples=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation length for independent MCMC chains with
parallel tempering.</p>
<p>ACLs are calculated separately for each chain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>start_index</strong> (<em>{None</em><em>, </em><em>int}</em>) – The start index to compute the acl from. If None, will try to use
the number of burn-in iterations in the file; otherwise, will start
at the first sample.</li>
<li><strong>end_index</strong> (<em>{None</em><em>, </em><em>int}</em>) – The end index to compute the acl to. If None, will go to the end
of the current iteration.</li>
<li><strong>min_nsamples</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Require a minimum number of samples to compute an ACL. If the
number of samples per walker is less than this, will just set to
<code class="docutils literal notranslate"><span class="pre">inf</span></code>. Default is 10.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary of ntemps x nchains arrays of the ACLs of each
parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.ensemble_compute_acf">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">ensemble_compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>per_walker=False</em>, <em>walkers=None</em>, <em>parameters=None</em>, <em>temps=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#ensemble_compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.ensemble_compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation function for a parallel tempered, ensemble
MCMC.</p>
<p>By default, parameter values are averaged over all walkers at each
iteration. The ACF is then calculated over the averaged chain for each
temperature. An ACF per-walker will be returned instead if
<code class="docutils literal notranslate"><span class="pre">per_walker=True</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>start_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The start index to compute the acl from. If None (the default), will
try to use the number of burn-in iterations in the file; otherwise,
will start at the first sample.</li>
<li><strong>end_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The end index to compute the acl to. If None (the default), will go to
the end of the current iteration.</li>
<li><strong>per_walker</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Return the ACF for each walker separately. Default is False.</li>
<li><strong>walkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>array</em><em>, </em><em>optional</em>) – Calculate the ACF using only the given walkers. If None (the
default) all walkers will be used.</li>
<li><strong>parameters</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em> or </em><em>array</em><em>, </em><em>optional</em>) – Calculate the ACF for only the given parameters. If None (the
default) will calculate the ACF for all of the model params.</li>
<li><strong>temps</strong> (<em>(</em><em>list of</em><em>) </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>'all'</em><em>, </em><em>optional</em>) – The temperature index (or list of indices) to retrieve. If None
(the default), the ACF will only be computed for the coldest (= 0)
temperature chain. To compute an ACF for all temperates pass ‘all’,
or a list of all of the temperatures.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. If
<code class="docutils literal notranslate"><span class="pre">per-walker</span></code> is True, the arrays will have shape
<code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>. Otherwise, the returned array
will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.ensemble_compute_acl">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">ensemble_compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>start_index=None</em>, <em>end_index=None</em>, <em>min_nsamples=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#ensemble_compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.ensemble_compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation length for a parallel tempered, ensemble
MCMC.</p>
<p>Parameter values are averaged over all walkers at each iteration and
temperature.  The ACL is then calculated over the averaged chain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>start_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The start index to compute the acl from. If None (the default), will
try to use the number of burn-in iterations in the file; otherwise,
will start at the first sample.</li>
<li><strong>end_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The end index to compute the acl to. If None, will go to the end
of the current iteration.</li>
<li><strong>min_nsamples</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Require a minimum number of samples to compute an ACL. If the
number of samples per walker is less than this, will just set to
<code class="docutils literal notranslate"><span class="pre">inf</span></code>. Default is 10.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary of ntemps-long arrays of the ACLs of each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.base_multitemper.read_betas_from_hdf">
<code class="descclassname">pycbc.inference.sampler.base_multitemper.</code><code class="descname">read_betas_from_hdf</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/base_multitemper.html#read_betas_from_hdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.base_multitemper.read_betas_from_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads inverse temperatures from the given file.</p>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.dynesty">
<span id="pycbc-inference-sampler-dynesty-module"></span><h2>pycbc.inference.sampler.dynesty module<a class="headerlink" href="#module-pycbc.inference.sampler.dynesty" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the dynesty sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.dynesty.</code><code class="descname">DynestySampler</code><span class="sig-paren">(</span><em>model</em>, <em>nlive</em>, <em>nprocesses=1</em>, <em>checkpoint_time_interval=None</em>, <em>maxcall=None</em>, <em>loglikelihood_function=None</em>, <em>use_mpi=False</em>, <em>no_save_state=False</em>, <em>run_kwds=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct an Dynesty sampler from the dynesty
package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>nlive</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of live points to use in sampler.</li>
<li><strong>pool</strong> (<em>function with map</em><em>, </em><em>Optional</em>) – A provider of a map function that allows a function call to be run
over multiple sets of arguments and possibly maps them to
cores/nodes/etc.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.checkpoint">
<code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkpoint function for dynesty sampler</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalze and write it to the results file</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em>, <em>loglikelihood_function=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file. Many options are
directly passed to the underlying dynesty sampler, see the official
dynesty documentation for more details on these.</p>
<p>The following options are retrieved in the <code class="docutils literal notranslate"><span class="pre">[sampler]</span></code> section:
* <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">STR</span></code> :</p>
<blockquote>
<div>Required. This must match the sampler’s name.</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">maxiter</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>The maximum number of iterations to run.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dlogz</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code>:</dt>
<dd>The target dlogz stopping condition.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">logl_max</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code>:</dt>
<dd>The maximum logl stopping condition.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">n_effective</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>Target effective number of samples stopping condition</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sample</span> <span class="pre">=</span> <span class="pre">STR</span></code>:</dt>
<dd>The method to sample the space. Should be one of ‘uniform’,
‘rwalk’, ‘rwalk2’ (a modified version of rwalk), or ‘slice’.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">walk</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>Used for some of the walk methods. Sets the minimum number of
steps to take when evolving a point.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">maxmcmc</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>Used for some of the walk methods. Sets the maximum number of steps
to take when evolving a point.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nact</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>used for some of the walk methods. Sets number of autorcorrelation
lengths before terminating evolution of a point.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">first_update_min_ncall</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>The minimum number of calls before updating the bounding region
for the first time.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">first_update_min_neff</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code>:</dt>
<dd>Don’t update the the bounding region untill the efficiency drops
below this value.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">=</span> <span class="pre">STR</span></code>:</dt>
<dd>The method of bounding of the prior volume.
Should be one of ‘single’, ‘balls’, ‘cubes’, ‘multi’ or ‘none’.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">update_interval</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>Number of iterations between updating the bounding regions</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">enlarge</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code>:</dt>
<dd>Factor to enlarge the bonding region.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bootstrap</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>The number of bootstrap iterations to determine the enlargement
factor.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">maxcall</span> <span class="pre">=</span> <span class="pre">INT</span></code>:</dt>
<dd>The maximum number of calls before checking if we should checkpoint</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint_time_interval</span></code> :</dt>
<dd>Sets the time in seconds between checkpointing.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">loglikelihood-function</span></code> :</dt>
<dd>The attribute of the model to use for the loglikelihood. If
not provided, will default to <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</dd>
</dl>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>WorkflowConfigParser instance</em>) – Config file object to parse.</li>
<li><strong>model</strong> (<em>pycbc.inference.model.BaseModel instance</em>) – The model to use.</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the output file to checkpoint and write results to.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1.</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default is False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The sampler instance.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pycbc.inference.sampler.dynesty.DynestySampler" title="pycbc.inference.sampler.dynesty.DynestySampler">DynestySampler</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.logz">
<code class="descname">logz</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.logz" title="Permalink to this definition">¶</a></dt>
<dd><p>return bayesian evidence estimated by
dynesty sampler</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.logz_err">
<code class="descname">logz_err</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.logz_err" title="Permalink to this definition">¶</a></dt>
<dd><p>return error in bayesian evidence estimated by
dynesty sampler</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping model’s metadata fields to arrays of values for
each sample in <code class="docutils literal notranslate"><span class="pre">raw_samples</span></code>.</p>
<p>The arrays may have any shape, and may or may not be thinned.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.name">
<code class="descname">name</code><em class="property"> = 'dynesty'</em><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.niterations">
<code class="descname">niterations</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.niterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.resume_from_checkpoint">
<code class="descname">resume_from_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.resume_from_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.resume_from_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the sampler from the output file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should run the sampler.</p>
<p>Any checkpointing should be done internally in this function.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns raw nested samples</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.set_initial_conditions">
<code class="descname">set_initial_conditions</code><span class="sig-paren">(</span><em>initial_distribution=None</em>, <em>samples_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.set_initial_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.set_initial_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the starting point for the sampler.</p>
<p>Should also set the sampler’s random state.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.dynesty.DynestySampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#DynestySampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.DynestySampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.dynesty.estimate_nmcmc">
<code class="descclassname">pycbc.inference.sampler.dynesty.</code><code class="descname">estimate_nmcmc</code><span class="sig-paren">(</span><em>accept_ratio</em>, <em>old_act</em>, <em>maxmcmc</em>, <em>safety=5</em>, <em>tau=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#estimate_nmcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.estimate_nmcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate autocorrelation length of chain using acceptance fraction</p>
<p>Using ACL = (2/acc) - 1 multiplied by a safety margin. Code adapated from
CPNest:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/johnveitch/cpnest/blob/master/cpnest/sampler.py">https://github.com/johnveitch/cpnest/blob/master/cpnest/sampler.py</a></li>
<li><a class="reference external" href="http://github.com/farr/Ensemble.jl">http://github.com/farr/Ensemble.jl</a></li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>accept_ratio</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em> [</em><em>0</em><em>, </em><em>1</em><em>]</em>) – Ratio of the number of accepted points to the total number of points</li>
<li><strong>old_act</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The ACT of the last iteration</li>
<li><strong>maxmcmc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – The maximum length of the MCMC chain to use</li>
<li><strong>safety</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – A safety factor applied in the calculation</li>
<li><strong>tau</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> (</em><em>optional</em><em>)</em>) – The ACT, if given, otherwise estimated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.sampler.dynesty.sample_rwalk_mod">
<code class="descclassname">pycbc.inference.sampler.dynesty.</code><code class="descname">sample_rwalk_mod</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/dynesty.html#sample_rwalk_mod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.dynesty.sample_rwalk_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified version of dynesty.sampling.sample_rwalk</p>
<p>Adapted from version used in bilby/dynesty</p>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.emcee">
<span id="pycbc-inference-sampler-emcee-module"></span><h2>pycbc.inference.sampler.emcee module<a class="headerlink" href="#module-pycbc.inference.sampler.emcee" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the emcee sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.emcee.</code><code class="descname">EmceeEnsembleSampler</code><span class="sig-paren">(</span><em>model</em>, <em>nwalkers</em>, <em>checkpoint_interval=None</em>, <em>checkpoint_signal=None</em>, <em>logpost_function=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport" title="pycbc.inference.sampler.base_mcmc.EnsembleSupport"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.EnsembleSupport</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC" title="pycbc.inference.sampler.base_mcmc.BaseMCMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.BaseMCMC</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct an MCMC sampler from the emcee
package’s EnsembleSampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of walkers to use in sampler.</li>
<li><strong>pool</strong> (<em>function with map</em><em>, </em><em>Optional</em>) – A provider of a map function that allows a function call to be run
over multiple sets of arguments and possibly maps them to
cores/nodes/etc.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.base_shape">
<code class="descname">base_shape</code><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.base_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>What shape the sampler’s samples arrays are in, excluding
the iterations dimension.</p>
<p>For example, if a sampler uses 20 chains and 3 temperatures, this
would be <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">20)</span></code>. If a sampler only uses a single walker and no
temperatures this would be <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.burn_in_class">
<code class="descname">burn_in_class</code><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.burn_in_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="pycbc.inference.html#pycbc.inference.burn_in.EnsembleMCMCBurnInTests" title="pycbc.inference.burn_in.EnsembleMCMCBurnInTests"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.burn_in.EnsembleMCMCBurnInTests</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.clear_samples">
<code class="descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.clear_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the samples and stats from memory.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.compute_acf">
<em class="property">static </em><code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation function.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_mcmc.ensemble_compute_acf()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_mcmc.ensemble_compute_acf()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. If
<code class="docutils literal notranslate"><span class="pre">per-walker</span></code> is True, the arrays will have shape
<code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.compute_acl">
<em class="property">static </em><code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation length.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_mcmc.ensemble_compute_acl()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_mcmc.ensemble_compute_acf()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary giving the ACL for each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>All data is written by the last checkpoint in the run method, so
this just passes.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping the model’s <code class="docutils literal notranslate"><span class="pre">default_stats</span></code> to arrays of values.</p>
<p>The returned array has shape <code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.name">
<code class="descname">name</code><em class="property"> = 'emcee'</em><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.run_mcmc">
<code class="descname">run_mcmc</code><span class="sig-paren">(</span><em>niterations</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.run_mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.run_mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble for a number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>niterations</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of iterations to run the sampler for.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping <code class="docutils literal notranslate"><span class="pre">variable_params</span></code> to arrays of samples currently
in memory.</p>
<p>The arrays have shape <code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee.EmceeEnsembleSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee.html#EmceeEnsembleSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee.EmceeEnsembleSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.emcee_pt">
<span id="pycbc-inference-sampler-emcee-pt-module"></span><h2>pycbc.inference.sampler.emcee_pt module<a class="headerlink" href="#module-pycbc.inference.sampler.emcee_pt" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the emcee_pt sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.emcee_pt.</code><code class="descname">EmceePTSampler</code><span class="sig-paren">(</span><em>model</em>, <em>ntemps</em>, <em>nwalkers</em>, <em>betas=None</em>, <em>checkpoint_interval=None</em>, <em>checkpoint_signal=None</em>, <em>loglikelihood_function=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base_multitemper.MultiTemperedSupport" title="pycbc.inference.sampler.base_multitemper.MultiTemperedSupport"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_multitemper.MultiTemperedSupport</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport" title="pycbc.inference.sampler.base_mcmc.EnsembleSupport"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.EnsembleSupport</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC" title="pycbc.inference.sampler.base_mcmc.BaseMCMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.BaseMCMC</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct a parallel-tempered MCMC sampler from
the emcee package’s PTSampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>ntemps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of temeratures to use in the sampler.</li>
<li><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of walkers to use in sampler.</li>
<li><strong>betas</strong> (<em>array</em>) – An array of inverse temperature values to be used in emcee_pt’s
temperature ladder. If not provided, <code class="docutils literal notranslate"><span class="pre">emcee_pt</span></code> will use the number
of temperatures and the number of dimensions of the parameter space to
construct the ladder with geometrically spaced temperatures.</li>
<li><strong>loglikelihood_function</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – Set the function to call from the model for the <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1
(no paralleliztion).</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default (False) will use python’s
multiprocessing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.base_shape">
<code class="descname">base_shape</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.base_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>What shape the sampler’s samples arrays are in, excluding
the iterations dimension.</p>
<p>For example, if a sampler uses 20 chains and 3 temperatures, this
would be <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">20)</span></code>. If a sampler only uses a single walker and no
temperatures this would be <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.betas">
<code class="descname">betas</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.betas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.burn_in_class">
<code class="descname">burn_in_class</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.burn_in_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="pycbc.inference.html#pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests" title="pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests</span></code></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.calculate_logevidence">
<em class="property">classmethod </em><code class="descname">calculate_logevidence</code><span class="sig-paren">(</span><em>filename</em>, <em>thin_start=None</em>, <em>thin_end=None</em>, <em>thin_interval=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.calculate_logevidence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.calculate_logevidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log evidence from the given file using <code class="docutils literal notranslate"><span class="pre">emcee_pt</span></code>’s
thermodynamic integration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the file to read the samples from. Should be an
<code class="docutils literal notranslate"><span class="pre">EmceePTFile</span></code>.</li>
<li><strong>thin_start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Index of the sample to begin returning stats. Default is to read
stats after burn in. To start from the beginning set thin_start
to 0.</li>
<li><strong>thin_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all stats
(set thin_interval to 1).</li>
<li><strong>thin_end</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>lnZ</strong> (<em>float</em>) – The estimate of log of the evidence.</li>
<li><strong>dlnZ</strong> (<em>float</em>) – The error on the estimate.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.clear_samples">
<code class="descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.clear_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.compute_acf">
<em class="property">static </em><code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation function.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acf()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acf()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. If
<code class="docutils literal notranslate"><span class="pre">per-walker=True</span></code> is passed as a keyword argument, the arrays
will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>. Otherwise, the
returned array will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.compute_acl">
<em class="property">static </em><code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation length.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acl()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acl()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary of ntemps-long arrays of the ACLs of each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log evidence and writes to the checkpoint file.</p>
<p>If sampling transforms were used, this also corrects the jacobian
stored on disk.</p>
<p>The thin start/interval/end for calculating the log evidence are
retrieved from the checkpoint file’s thinning attributes.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
<p>The following options are retrieved in the <code class="docutils literal notranslate"><span class="pre">[sampler]</span></code> section:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code> :</dt>
<dd>Required. This must match the samlper’s name.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nwalkers</span></code> :</dt>
<dd>Required. The number of walkers to use.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ntemps</span></code> :</dt>
<dd>The number of temperatures to use. Either this, or
<code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> :</dt>
<dd>Path to an hdf file containing the inverse temperatures (“betas”)
to use. The betas will be retrieved from the file’s
<code class="docutils literal notranslate"><span class="pre">.attrs['betas']</span></code>. Either this or <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> must be provided
(but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">niterations</span></code> :</dt>
<dd>The number of iterations to run the sampler for. Either this or
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> :</dt>
<dd>Run the sampler until the given number of effective samples are
obtained. A <code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span></code> must also be provided in this
case. Either this or <code class="docutils literal notranslate"><span class="pre">niterations</span></code> must be provided (but not
both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">thin-interval</span></code> :</dt>
<dd>Thin the samples by the given value before saving to disk. May
provide this, or <code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span></code>, but not both. If
neither options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span></code> :</dt>
<dd>Thin the samples such that the number of samples per chain per
temperature that are saved to disk never exceeds the given value.
May provide this, or <code class="docutils literal notranslate"><span class="pre">thin-interval</span></code>, but not both. If neither
options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span></code> :</dt>
<dd>Sets the checkpoint interval to use. Must be provided if using
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-signal</span></code> :</dt>
<dd>Set the checkpoint signal, e.g., “USR2”. Optional.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">logl-function</span></code> :</dt>
<dd>The attribute of the model to use for the loglikelihood. If
not provided, will default to <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</dd>
</dl>
</li>
</ul>
<p>Settings for burn-in tests are read from <code class="docutils literal notranslate"><span class="pre">[sampler-burn_in]</span></code>. In
particular, the <code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> option is used to set the burn in
tests to perform. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">MultiTemperedMCMCBurnInTests.from_config()</span></code> for details. If no
<code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> is provided, no burn in tests will be carried out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>WorkflowConfigParser instance</em>) – Config file object to parse.</li>
<li><strong>model</strong> (<em>pycbc.inference.model.BaseModel instance</em>) – The model to use.</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the output file to checkpoint and write results to.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1.</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default is False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The sampler instance.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler" title="pycbc.inference.sampler.emcee_pt.EmceePTSampler">EmceePTSampler</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log likelihood ratio and log prior as a dict of arrays.</p>
<p>The returned array has shape ntemps x nwalkers x niterations.</p>
<p>Unfortunately, because <code class="docutils literal notranslate"><span class="pre">emcee_pt</span></code> does not have blob support, this
will only return the loglikelihood and logprior (with the logjacobian
set to zero) regardless of what stats the model can return.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Since the <cite>logjacobian</cite> is not saved by <cite>emcee_pt</cite>, the <cite>logprior</cite>
returned here is the log of the prior pdf in the sampling
coordinate frame rather than the variable params frame. This
differs from the variable params frame by the log of the Jacobian
of the transform from one frame to the other. If no sampling
transforms were used, then the <cite>logprior</cite> is the same.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.name">
<code class="descname">name</code><em class="property"> = 'emcee_pt'</em><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.run_mcmc">
<code class="descname">run_mcmc</code><span class="sig-paren">(</span><em>niterations</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.run_mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.run_mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble for a number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>niterations</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of samples to get from sampler.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping <code class="docutils literal notranslate"><span class="pre">variable_params</span></code> to arrays of samples currently
in memory.</p>
<p>The arrays have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.emcee_pt.EmceePTSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/emcee_pt.html#EmceePTSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.epsie">
<span id="pycbc-inference-sampler-epsie-module"></span><h2>pycbc.inference.sampler.epsie module<a class="headerlink" href="#module-pycbc.inference.sampler.epsie" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes for interacting with epsie samplers.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.epsie.</code><code class="descname">EpsieSampler</code><span class="sig-paren">(</span><em>model</em>, <em>nchains</em>, <em>ntemps=None</em>, <em>betas=None</em>, <em>proposals=None</em>, <em>default_proposal=None</em>, <em>default_proposal_args=None</em>, <em>seed=None</em>, <em>swap_interval=1</em>, <em>checkpoint_interval=None</em>, <em>checkpoint_signal=None</em>, <em>loglikelihood_function=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base_multitemper.MultiTemperedSupport" title="pycbc.inference.sampler.base_multitemper.MultiTemperedSupport"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_multitemper.MultiTemperedSupport</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC" title="pycbc.inference.sampler.base_mcmc.BaseMCMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.BaseMCMC</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>Constructs an MCMC sampler using epsie’s parallel-tempered sampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>nchains</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of chains to use in the sampler.</li>
<li><strong>ntemps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Number of temperatures to use in the sampler. A geometrically-spaced
temperature ladder with the gievn number of levels will be constructed
based on the number of parameters. If not provided, must provide
<code class="docutils literal notranslate"><span class="pre">betas</span></code>.</li>
<li><strong>betas</strong> (<em>array</em><em>, </em><em>optional</em>) – An array of inverse temperature values to be used in for the
temperature ladder. If not provided, must provide <code class="docutils literal notranslate"><span class="pre">ntemps</span></code>.</li>
<li><strong>proposals</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.10)"><em>list</em></a><em>, </em><em>optional</em>) – List of proposals to use. Any parameters that do not have a proposal
provided will use the <code class="docutils literal notranslate"><span class="pre">default_propsal</span></code>. <strong>Note:</strong> proposals should
be specified for the sampling parameters, not the
variable parameters.</li>
<li><strong>default_proposal</strong> (<em>an epsie.Proposal class</em><em>, </em><em>optional</em>) – The default proposal to use for parameters not in <code class="docutils literal notranslate"><span class="pre">proposals</span></code>.
Default is <code class="xref py py-class docutils literal notranslate"><span class="pre">epsie.proposals.Normal</span></code>.</li>
<li><strong>default_proposal_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a><em>, </em><em>optional</em>) – Dictionary of arguments to pass to the default proposal.</li>
<li><strong>swap_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of iterations between temperature swaps. Default is 1.</li>
<li><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Seed for epsie’s random number generator. If None provided, will create
one.</li>
<li><strong>checkpoint_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Specify the number of iterations to do between checkpoints. If not
provided, no checkpointin will be done.</li>
<li><strong>checkpoint_signal</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – Set the signal to use when checkpointing. For example, ‘USR2’.</li>
<li><strong>loglikelihood_function</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – Set the function to call from the model for the <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1
(no paralleliztion).</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default (False) will use python’s
multiprocessing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.acl">
<code class="descname">acl</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.acl" title="Permalink to this definition">¶</a></dt>
<dd><p>The autocorrelation lengths of the chains.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.base_shape">
<code class="descname">base_shape</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.base_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>What shape the sampler’s samples arrays are in, excluding
the iterations dimension.</p>
<p>For example, if a sampler uses 20 chains and 3 temperatures, this
would be <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">20)</span></code>. If a sampler only uses a single walker and no
temperatures this would be <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.betas">
<code class="descname">betas</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.betas" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse temperatures being used.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.burn_in_class">
<code class="descname">burn_in_class</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.burn_in_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="pycbc.inference.html#pycbc.inference.burn_in.MultiTemperedMCMCBurnInTests" title="pycbc.inference.burn_in.MultiTemperedMCMCBurnInTests"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.burn_in.MultiTemperedMCMCBurnInTests</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.clear_samples">
<code class="descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.clear_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.compute_acf">
<em class="property">static </em><code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation function.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.compute_acf()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.compute_acf()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. The arrays
will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nchains</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.compute_acl">
<em class="property">static </em><code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation length.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.compute_acl()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.compute_acl()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary of ntemps-long arrays of the ACLs of each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.effective_nsamples">
<code class="descname">effective_nsamples</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.effective_nsamples" title="Permalink to this definition">¶</a></dt>
<dd><p>The effective number of samples post burn-in that the sampler has
acquired so far.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Do any finalization to the samples file before exiting.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
<p>The following options are retrieved in the <code class="docutils literal notranslate"><span class="pre">[sampler]</span></code> section:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code> :</dt>
<dd>(required) must match the samlper’s name</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nchains</span></code> :</dt>
<dd>(required) the number of chains to use</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ntemps</span></code> :</dt>
<dd>The number of temperatures to use. Either this, or
<code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">inverse-temperatures-file</span></code> :</dt>
<dd>Path to an hdf file containing the inverse temperatures (“betas”)
to use. The betas will be retrieved from the file’s
<code class="docutils literal notranslate"><span class="pre">.attrs['betas']</span></code>. Either this or <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> must be provided
(but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">niterations</span></code> :</dt>
<dd>The number of iterations to run the sampler for. Either this or
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> :</dt>
<dd>Run the sampler until the given number of effective samples are
obtained. A <code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span></code> must also be provided in this
case. Either this or <code class="docutils literal notranslate"><span class="pre">niterations</span></code> must be provided (but not
both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">thin-interval</span></code> :</dt>
<dd>Thin the samples by the given value before saving to disk. May
provide this, or <code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span></code>, but not both. If
neither options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span></code> :</dt>
<dd>Thin the samples such that the number of samples per chain per
temperature that are saved to disk never exceeds the given value.
May provide this, or <code class="docutils literal notranslate"><span class="pre">thin-interval</span></code>, but not both. If neither
options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span></code> :</dt>
<dd>Sets the checkpoint interval to use. Must be provided if using
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-signal</span></code> :</dt>
<dd>Set the checkpoint signal, e.g., “USR2”. Optional.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">seed</span></code> :</dt>
<dd>The seed to use for epsie’s random number generator. If not
provided, epsie will create one.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">logl-function</span></code> :</dt>
<dd>The attribute of the model to use for the loglikelihood. If
not provided, will default to <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">swap-interval</span></code> :</dt>
<dd>The number of iterations between temperature swaps. Default is 1.</dd>
</dl>
</li>
</ul>
<p>Jump proposals must be provided for every sampling
parameter. These are retrieved from subsections
<code class="docutils literal notranslate"><span class="pre">[jump_proposal-{params}]</span></code>, where params is a
<code class="xref py py-const docutils literal notranslate"><span class="pre">pycbc.VARARGS_DELIM</span></code> separated list of parameters the
proposal should be used for. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">inference.jump.epsie_proposals_from_config()</span></code> for
details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Jump proposals should be specified for <strong>sampling parameters</strong>,
not <strong>variable parameters</strong>.</p>
</div>
<p>Settings for burn-in tests are read from <code class="docutils literal notranslate"><span class="pre">[sampler-burn_in]</span></code>. In
particular, the <code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> option is used to set the burn in
tests to perform. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">MultiTemperedMCMCBurnInTests.from_config()</span></code> for details. If no
<code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> is provided, no burn in tests will be carried out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>WorkflowConfigParser instance</em>) – Config file object to parse.</li>
<li><strong>model</strong> (<em>pycbc.inference.model.BaseModel instance</em>) – The model to use.</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the output file to checkpoint and write results to.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1.</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default is False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The sampler instance.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">EpsiePTSampler</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping the model’s <code class="docutils literal notranslate"><span class="pre">default_stats</span></code> to arrays of values.</p>
<p>The arrays have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nchains</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.name">
<code class="descname">name</code><em class="property"> = 'epsie'</em><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.pos">
<code class="descname">pos</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of the current chain positions.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.run_mcmc">
<code class="descname">run_mcmc</code><span class="sig-paren">(</span><em>niterations</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.run_mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.run_mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the chains for a number of iterations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>niterations</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of samples to get from sampler.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping <code class="docutils literal notranslate"><span class="pre">variable_params</span></code> to arrays of samples currently
in memory.</p>
<p>The arrays have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nchains</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
<p>The dictionary also contains sampling parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.seed">
<code class="descname">seed</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.seed" title="Permalink to this definition">¶</a></dt>
<dd><p>The seed used for epsie’s random bit generator.</p>
<p>This is not the same as the seed used for the prior distributions.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.set_p0">
<code class="descname">set_p0</code><span class="sig-paren">(</span><em>samples_file=None</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.set_p0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.set_p0" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial position of the chains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples_file</strong> (<em>InferenceFile</em><em>, </em><em>optional</em>) – If provided, use the last iteration in the given file for the
starting positions.</li>
<li><strong>prior</strong> (<a class="reference internal" href="pycbc.distributions.html#pycbc.distributions.joint.JointDistribution" title="pycbc.distributions.joint.JointDistribution"><em>JointDistribution</em></a><em>, </em><em>optional</em>) – Use the given prior to set the initial positions rather than
<code class="docutils literal notranslate"><span class="pre">model</span></code>’s prior.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p0</strong> – A dictionary maping sampling params to the starting positions.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.swap_interval">
<code class="descname">swap_interval</code><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.swap_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations between temperature swaps.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.epsie.EpsieSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/epsie.html#EpsieSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.epsie.EpsieSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance ratios, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.multinest">
<span id="pycbc-inference-sampler-multinest-module"></span><h2>pycbc.inference.sampler.multinest module<a class="headerlink" href="#module-pycbc.inference.sampler.multinest" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the Multinest sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.multinest.</code><code class="descname">MultinestSampler</code><span class="sig-paren">(</span><em>model</em>, <em>nlivepoints</em>, <em>checkpoint_interval=1000</em>, <em>importance_nested_sampling=False</em>, <em>evidence_tolerance=0.1</em>, <em>sampling_efficiency=0.01</em>, <em>constraints=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct a nested sampler from
the Multinest package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>nlivepoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of live points to use in sampler.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.check_if_finished">
<code class="descname">check_if_finished</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.check_if_finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.check_if_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate remaining evidence to see if desired evidence-tolerance
stopping criterion has been reached.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.checkpoint">
<code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps current samples to the checkpoint file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.checkpoint_interval">
<code class="descname">checkpoint_interval</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.checkpoint_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of iterations between checkpoints.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.dlogz">
<code class="descname">dlogz</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.dlogz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current error estimate of the log evidence.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>All data is written by the last checkpoint in the run method, so
this just passes.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.get_posterior_samples">
<code class="descname">get_posterior_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.get_posterior_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.get_posterior_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Read posterior samples from ASCII output file created by
multinest.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.importance_dlogz">
<code class="descname">importance_dlogz</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.importance_dlogz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current error estimate of the importance
weighted log evidence.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.importance_logz">
<code class="descname">importance_logz</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.importance_logz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current importance weighted estimate of the log
evidence.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.loglikelihood">
<code class="descname">loglikelihood</code><span class="sig-paren">(</span><em>cube</em>, <em>*extra_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.loglikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.loglikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Log likelihood evaluator that gets passed to multinest.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.logz">
<code class="descname">logz</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.logz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current estimate of the log evidence.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping the model’s <code class="docutils literal notranslate"><span class="pre">default_stats</span></code> to arrays of values.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.name">
<code class="descname">name</code><em class="property"> = 'multinest'</em><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.niterations">
<code class="descname">niterations</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.niterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current number of iterations.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.nlivepoints">
<code class="descname">nlivepoints</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.nlivepoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of live points used in sampling.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.resume_from_checkpoint">
<code class="descname">resume_from_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.resume_from_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.resume_from_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume sampler from checkpoint</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the sampler until the specified evidence tolerance
is reached.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping <code class="docutils literal notranslate"><span class="pre">variable_params</span></code> to arrays of samples currently
in memory.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.set_initial_conditions">
<code class="descname">set_initial_conditions</code><span class="sig-paren">(</span><em>initial_distribution=None</em>, <em>samples_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.set_initial_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.set_initial_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial starting point for the sampler.</p>
<p>If a starting samples file is provided, will also load the random
state from it.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.setup_output">
<code class="descname">setup_output</code><span class="sig-paren">(</span><em>output_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.setup_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.setup_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the sampler’s checkpoint and output files.</p>
<p>The checkpoint file has the same name as the output file, but with
<code class="docutils literal notranslate"><span class="pre">.checkpoint</span></code> appended to the name. A backup file will also be
created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sampler</strong> (<em>sampler instance</em>) – Sampler</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of the output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.transform_prior">
<code class="descname">transform_prior</code><span class="sig-paren">(</span><em>cube</em>, <em>*extra_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.transform_prior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.transform_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the unit hypercube that multinest makes its draws
from, into the prior space defined in the config file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.multinest.MultinestSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/multinest.html#MultinestSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.multinest.MultinestSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.ptemcee">
<span id="pycbc-inference-sampler-ptemcee-module"></span><h2>pycbc.inference.sampler.ptemcee module<a class="headerlink" href="#module-pycbc.inference.sampler.ptemcee" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the emcee_pt sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.ptemcee.</code><code class="descname">PTEmceeSampler</code><span class="sig-paren">(</span><em>model</em>, <em>nwalkers</em>, <em>ntemps=None</em>, <em>Tmax=None</em>, <em>betas=None</em>, <em>adaptive=False</em>, <em>adaptation_lag=None</em>, <em>adaptation_time=None</em>, <em>scale_factor=None</em>, <em>loglikelihood_function=None</em>, <em>checkpoint_interval=None</em>, <em>checkpoint_signal=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.EnsembleSupport" title="pycbc.inference.sampler.base_mcmc.EnsembleSupport"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.EnsembleSupport</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base_mcmc.BaseMCMC" title="pycbc.inference.sampler.base_mcmc.BaseMCMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base_mcmc.BaseMCMC</span></code></a>, <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct the parallel-tempered ptemcee sampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Number of walkers to use in sampler.</li>
<li><strong>ntemps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Specify the number of temps to use. Either this, <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>, or <code class="docutils literal notranslate"><span class="pre">betas</span></code>
must be specified.</li>
<li><strong>Tmax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Specify the maximum temperature to use. This may be used with
<code class="docutils literal notranslate"><span class="pre">ntemps</span></code>; see <code class="xref py py-func docutils literal notranslate"><span class="pre">ptemcee.make_ladder()</span></code> for details. Either
this, <code class="docutils literal notranslate"><span class="pre">ntemps</span></code>, or <code class="docutils literal notranslate"><span class="pre">betas</span></code> must be specified.</li>
<li><strong>betas</strong> (<em>list of float</em><em>, </em><em>optional</em>) – Specify the betas to use. Must be provided if <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> and <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>
are not given. Will override <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> and <code class="docutils literal notranslate"><span class="pre">Tmax</span></code> if provided.</li>
<li><strong>adaptive</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether or not to use adaptive temperature levels. Default is False.</li>
<li><strong>adaptation_lag</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Only used if <code class="docutils literal notranslate"><span class="pre">adaptive</span></code> is True; see <code class="xref py py-mod docutils literal notranslate"><span class="pre">ptemcee.Sampler</span></code> for
details. If not provided, will use <code class="docutils literal notranslate"><span class="pre">ptemcee</span></code>’s default.</li>
<li><strong>adaptation_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Only used if <code class="docutils literal notranslate"><span class="pre">adaptive</span></code> is True; see <code class="xref py py-mod docutils literal notranslate"><span class="pre">ptemcee.Sampler</span></code> for
details. If not provided, will use <code class="docutils literal notranslate"><span class="pre">ptemcee</span></code>’s default.</li>
<li><strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Scale factor used for the stretch proposal; see
<code class="xref py py-mod docutils literal notranslate"><span class="pre">ptemcee.Sampler</span></code> for details. If not provided, will use
<code class="docutils literal notranslate"><span class="pre">ptemcee</span></code>’s default.</li>
<li><strong>loglikelihood_function</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – Set the function to call from the model for the <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1
(no paralleliztion).</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default (False) will use python’s
multiprocessing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptation_lag">
<code class="descname">adaptation_lag</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptation_lag" title="Permalink to this definition">¶</a></dt>
<dd><p>The adaptation lag for the beta evolution.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptation_time">
<code class="descname">adaptation_time</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptation_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The adaptation time for the beta evolution.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptive">
<code class="descname">adaptive</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not the betas are adapted.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.base_shape">
<code class="descname">base_shape</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.base_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>What shape the sampler’s samples arrays are in, excluding
the iterations dimension.</p>
<p>For example, if a sampler uses 20 chains and 3 temperatures, this
would be <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">20)</span></code>. If a sampler only uses a single walker and no
temperatures this would be <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.betas">
<code class="descname">betas</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.betas" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the beta history currently in memory.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.burn_in_class">
<code class="descname">burn_in_class</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.burn_in_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="pycbc.inference.html#pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests" title="pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.burn_in.EnsembleMultiTemperedMCMCBurnInTests</span></code></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.calculate_logevidence">
<em class="property">classmethod </em><code class="descname">calculate_logevidence</code><span class="sig-paren">(</span><em>filename</em>, <em>thin_start=None</em>, <em>thin_end=None</em>, <em>thin_interval=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.calculate_logevidence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.calculate_logevidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log evidence from the given file.
This uese <code class="docutils literal notranslate"><span class="pre">ptemcee</span></code>’s thermodynamic integration.
:param filename: Name of the file to read the samples from. Should be an</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">PTEmceeFile</span></code>.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thin_start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Index of the sample to begin returning stats. Default is to read
stats after burn in. To start from the beginning set thin_start
to 0.</li>
<li><strong>thin_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all stats
(set thin_interval to 1).</li>
<li><strong>thin_end</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) – Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>lnZ</strong> (<em>float</em>) – The estimate of log of the evidence.</li>
<li><strong>dlnZ</strong> (<em>float</em>) – The error on the estimate.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.chain">
<code class="descname">chain</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>The current chain of samples in memory.
The chain is returned as a <code class="xref py py-mod docutils literal notranslate"><span class="pre">ptemcee.chain.Chain</span></code> instance. If
no chain has been created yet (<code class="docutils literal notranslate"><span class="pre">_chain</span></code> is None), then will create
a new chain using the current <code class="docutils literal notranslate"><span class="pre">ensemble</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.clear_samples">
<code class="descname">clear_samples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.clear_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.clear_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.compute_acf">
<em class="property">static </em><code class="descname">compute_acf</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.compute_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.compute_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation function.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acf()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACFs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acf()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Dictionary of arrays giving the ACFs for each parameter. If
<code class="docutils literal notranslate"><span class="pre">per-walker=True</span></code> is passed as a keyword argument, the arrays
will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>. Otherwise, the
returned array will have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.compute_acl">
<em class="property">static </em><code class="descname">compute_acl</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.compute_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.compute_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrelation length.</p>
<p>Calls <code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acl()</span></code>; see that
function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Name of a samples file to compute ACLs for.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">base_multitemper.ensemble_compute_acl()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary of ntemps-long arrays of the ACLs of each parameter.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.ensemble">
<code class="descname">ensemble</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current ptemcee ensemble.</p>
<p>The ensemble stores the current location of and temperatures of the
walkers. If the ensemble hasn’t been setup yet, will set one up
using p0 for the positions. If set_p0 hasn’t been run yet, this will
result in a ValueError.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log evidence and writes to the checkpoint file.</p>
<p>If sampling transforms were used, this also corrects the jacobian
stored on disk.</p>
<p>The thin start/interval/end for calculating the log evidence are
retrieved from the checkpoint file’s thinning attributes.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>nprocesses=1</em>, <em>use_mpi=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
<p>The following options are retrieved in the <code class="docutils literal notranslate"><span class="pre">[sampler]</span></code> section:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">STR</span></code> :</dt>
<dd>Required. This must match the sampler’s name.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>Required. The number of walkers to use.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>The number of temperatures to use. This may be used in combination
with <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>. Either this, <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>, <code class="docutils literal notranslate"><span class="pre">betas</span></code> or <code class="docutils literal notranslate"><span class="pre">betas-file</span></code>
must be provided.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">tmax</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code> :</dt>
<dd>The maximum temperature to use. This may be used in combination
with <code class="docutils literal notranslate"><span class="pre">ntemps</span></code>, or alone.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">betas</span> <span class="pre">=</span> <span class="pre">FLOAT1</span> <span class="pre">FLOAT2</span> <span class="pre">[...]</span></code> :</dt>
<dd>Space-separated list of (intial) inverse temperatures (“betas”) to
use. This sets both the number of temperatures and the tmax. A
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised if both this and <code class="docutils literal notranslate"><span class="pre">ntemps</span></code> or
<code class="docutils literal notranslate"><span class="pre">Tmax</span></code> are provided.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">betas-file</span> <span class="pre">=</span> <span class="pre">STR</span></code> :</dt>
<dd>Path to an hdf file containing the inverse temperatures (“betas”)
to use. The betas will be retrieved from the file’s
<code class="docutils literal notranslate"><span class="pre">.attrs['betas']</span></code>. A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised if both this
and <code class="docutils literal notranslate"><span class="pre">betas</span></code> are provided.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adaptive</span> <span class="pre">=</span></code> :</dt>
<dd>If provided, temperature adaptation will be turned on.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adaptation-lag</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>The adaptation lag to use (see ptemcee for details).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adaptation-time</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>The adaptation time to use (see ptemcee for details).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">scale-factor</span> <span class="pre">=</span> <span class="pre">FLOAT</span></code> :</dt>
<dd>The scale factor to use for the emcee stretch.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">niterations</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>The number of iterations to run the sampler for. Either this or
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code> must be provided (but not both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">effective-nsamples</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>Run the sampler until the given number of effective samples are
obtained. A <code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span></code> must also be provided in this
case. Either this or <code class="docutils literal notranslate"><span class="pre">niterations</span></code> must be provided (but not
both).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">thin-interval</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>Thin the samples by the given value before saving to disk. May
provide this, or <code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span></code>, but not both. If
neither options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">max-samples-per-chain</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>Thin the samples such that the number of samples per chain per
temperature that are saved to disk never exceeds the given value.
May provide this, or <code class="docutils literal notranslate"><span class="pre">thin-interval</span></code>, but not both. If neither
options are provided, will save all samples.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-interval</span> <span class="pre">=</span> <span class="pre">INT</span></code> :</dt>
<dd>Sets the checkpoint interval to use. Must be provided if using
<code class="docutils literal notranslate"><span class="pre">effective-nsamples</span></code>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint-signal</span> <span class="pre">=</span> <span class="pre">STR</span></code> :</dt>
<dd>Set the checkpoint signal, e.g., “USR2”. Optional.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">logl-function</span> <span class="pre">=</span> <span class="pre">STR</span></code> :</dt>
<dd>The attribute of the model to use for the loglikelihood. If
not provided, will default to <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>.</dd>
</dl>
</li>
</ul>
<p>Settings for burn-in tests are read from <code class="docutils literal notranslate"><span class="pre">[sampler-burn_in]</span></code>. In
particular, the <code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> option is used to set the burn in
tests to perform. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">EnsembleMultiTemperedMCMCBurnInTests.from_config()</span></code> for
details. If no <code class="docutils literal notranslate"><span class="pre">burn-in-test</span></code> is provided, no burn in tests will be
carried out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<em>WorkflowConfigParser instance</em>) – Config file object to parse.</li>
<li><strong>model</strong> (<em>pycbc.inference.model.BaseModel instance</em>) – The model to use.</li>
<li><strong>output_file</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em>) – The name of the output file to checkpoint and write results to.</li>
<li><strong>nprocesses</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – The number of parallel processes to use. Default is 1.</li>
<li><strong>use_mpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Use MPI for parallelization. Default is False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The sampler instance.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pycbc.inference.sampler.emcee_pt.EmceePTSampler" title="pycbc.inference.sampler.emcee_pt.EmceePTSampler">EmceePTSampler</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log likelihood ratio and log prior as a dict of arrays.</p>
<p>The returned array has shape ntemps x nwalkers x niterations.</p>
<p>Unfortunately, because <code class="docutils literal notranslate"><span class="pre">ptemcee</span></code> does not have blob support, this
will only return the loglikelihood and logprior (with the logjacobian
set to zero) regardless of what stats the model can return.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Since the <code class="docutils literal notranslate"><span class="pre">logjacobian</span></code> is not saved by <code class="docutils literal notranslate"><span class="pre">ptemcee</span></code>, the
<code class="docutils literal notranslate"><span class="pre">logprior</span></code> returned here is the log of the prior pdf in the
sampling coordinate frame rather than the variable params frame.
This differs from the variable params frame by the log of the
Jacobian of the transform from one frame to the other. If no
sampling transforms were used, then the <code class="docutils literal notranslate"><span class="pre">logprior</span></code> is the same.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.name">
<code class="descname">name</code><em class="property"> = 'ptemcee'</em><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.ntemps">
<code class="descname">ntemps</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.ntemps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of temeratures that are set.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.run_mcmc">
<code class="descname">run_mcmc</code><span class="sig-paren">(</span><em>niterations</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.run_mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.run_mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble for a number of samples.
:param niterations: Number of samples to get from sampler.
:type niterations: int</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping <code class="docutils literal notranslate"><span class="pre">variable_params</span></code> to arrays of samples currently
in memory.
The arrays have shape <code class="docutils literal notranslate"><span class="pre">ntemps</span> <span class="pre">x</span> <span class="pre">nwalkers</span> <span class="pre">x</span> <span class="pre">niterations</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.scale_factor">
<code class="descname">scale_factor</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.scale_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>The scale factor used by ptemcee.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.set_state_from_file">
<code class="descname">set_state_from_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.set_state_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.set_state_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the sampler back to the instance saved in a file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.starting_betas">
<code class="descname">starting_betas</code><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.starting_betas" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the betas that were used at startup.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ptemcee.PTEmceeSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ptemcee.html#PTEmceeSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ptemcee.PTEmceeSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler.ultranest">
<span id="pycbc-inference-sampler-ultranest-module"></span><h2>pycbc.inference.sampler.ultranest module<a class="headerlink" href="#module-pycbc.inference.sampler.ultranest" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the ultranest sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler.ultranest.</code><code class="descname">UltranestSampler</code><span class="sig-paren">(</span><em>model</em>, <em>log_dir=None</em>, <em>stepsampling=False</em>, <em>enable_plots=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler.base.BaseSampler" title="pycbc.inference.sampler.base.BaseSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycbc.inference.sampler.base.BaseSampler</span></code></a></p>
<p>This class is used to construct an Ultranest sampler from the ultranest
package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>model</em>) – A model from <code class="docutils literal notranslate"><span class="pre">pycbc.inference.models</span></code>.</li>
<li><strong>log_dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Folder where files should be stored for resuming (optional).</li>
<li><strong>stepsampling</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a>) – If false, uses rejection sampling. If true, uses
hit-and-run sampler, which scales better with dimensionality.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.checkpoint">
<code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The sampler must have a checkpoint method for dumping raw samples
and stats to the file type defined by <code class="docutils literal notranslate"><span class="pre">io</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Do any finalization to the samples file before exiting.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>output_file=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the sampler from the given config file.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.io">
<code class="descname">io</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.io" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that inherits from <code class="docutils literal notranslate"><span class="pre">BaseInferenceFile</span></code> to handle IO with
an hdf file.</p>
<p>This should be a class, not an instance of class, so that the sampler
can initialize it when needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.logz">
<code class="descname">logz</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.logz" title="Permalink to this definition">¶</a></dt>
<dd><p>return bayesian evidence estimated by
ultranest sampler</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.logz_err">
<code class="descname">logz_err</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.logz_err" title="Permalink to this definition">¶</a></dt>
<dd><p>return error in bayesian evidence estimated by
ultranest sampler</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.model_stats">
<code class="descname">model_stats</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.model_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping model’s metadata fields to arrays of values for
each sample in <code class="docutils literal notranslate"><span class="pre">raw_samples</span></code>.</p>
<p>The arrays may have any shape, and may or may not be thinned.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.name">
<code class="descname">name</code><em class="property"> = 'ultranest'</em><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.niterations">
<code class="descname">niterations</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.niterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.resume_from_checkpoint">
<code class="descname">resume_from_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.resume_from_checkpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.resume_from_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the sampler from the output file.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should run the sampler.</p>
<p>Any checkpointing should be done internally in this function.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.samples">
<code class="descname">samples</code><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict mapping variable_params to arrays of samples currently
in memory. The dictionary may also contain sampling_params.</p>
<p>The sample arrays may have any shape, and may or may not be thinned.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler.ultranest.UltranestSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler/ultranest.html#UltranestSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.ultranest.UltranestSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes samples, model stats, acceptance fraction, and random state
to the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – The file to write to. The file is opened using the <code class="docutils literal notranslate"><span class="pre">io</span></code> class
in an an append state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pycbc.inference.sampler" title="Permalink to this headline">¶</a></h2>
<p>This modules provides a list of implemented samplers for parameter estimation.</p>
<dl class="function">
<dt id="pycbc.inference.sampler.load_from_config">
<code class="descclassname">pycbc.inference.sampler.</code><code class="descname">load_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>model</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler.html#load_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler.load_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a sampler from the given config file.</p>
<p>This looks for a name in the section <code class="docutils literal notranslate"><span class="pre">[sampler]</span></code> to determine which
sampler class to load. That sampler’s <code class="docutils literal notranslate"><span class="pre">from_config</span></code> is then called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cp</strong> (<a class="reference internal" href="pycbc.workflow.html#pycbc.workflow.configuration.WorkflowConfigParser" title="pycbc.workflow.configuration.WorkflowConfigParser"><em>WorkflowConfigParser</em></a>) – Config parser to read from.</li>
<li><strong>model</strong> (<em>pycbc.inference.model</em>) – Which model to pass to the sampler.</li>
<li><strong>**kwargs</strong> – All other keyword arguments are passed directly to the sampler’s
<code class="docutils literal notranslate"><span class="pre">from_config</span></code> file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The initialized sampler.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sampler</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pycbc.inference.models.html" class="btn btn-neutral float-left" title="pycbc.inference.models package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pycbc.inject.html" class="btn btn-neutral float-right" title="pycbc.inject package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, 2016, 2017, Alexander Nitz, Ian Harry, Christopher M. Biwer, Duncan A.  Brown, Josh Willis, and Tito Dal Canton.
      <span class="lastupdated">Last updated on Oct 20, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>