#! /usr/bin/python

import argparse
import ctypes
import logging
import numpy
from glue import lal
from glue import segments
from pycbc import frame
from pycbc import types
from pycbc.filter.zpk import filter_zpk

import ROOT
ROOT.gSystem.Load('/usr/lib64/libdmtsigp.so')
ROOT.gSystem.Load('/usr/lib64/libgdsplot.so')
from foton import FilterFile, Filter

# command line usage
parser = argparse.ArgumentParser(usage='pycbc_calibrate_data [--options]',
                  description='Read the detector data and applies filters to calibrate the data.')

# time options
parser.add_argument("--gps-start-time", type=int, required=True,
                  help="Time to begin filtering input data.")
parser.add_argument("--gps-end-time", type=int, required=True,
                  help="Time to finish filtering input data.")

# frame options
parser.add_argument("--frame-cache", type=str, required=True,
                  help="Path to frame cache that contains data.")

# foton options
parser.add_argument("--filter-file", type=str, required=True,
                  help="Path to foton filter file to extract filterbanks.")

# output options
parser.add_argument("--output-file", type=str, required=True,
                  help="The name of the ASCII output file that contains h(t).")

# parse command line
opts = parser.parse_args()

# setup log
logging_level = logging.DEBUG
logging.basicConfig(format='%(asctime)s : %(message)s', level=logging_level)

# FIXME: hardcoded filterbank information for OAF model
channel_names = ['L1:CAL-DARM_ERR_WHITEN_OUT_DQ', 'L1:CAL-DARM_CTRL_WHITEN_OUT_DQ']
filterbank_names = ['CAL_SUM_DARM_ERR', 'CAL_SUM_DARM_L1', 'CAL_SUM_DARM_L2', 'CAL_SUM_DARM_L3', 'CAL_SUM_DARM_M0']
swstat_channel_names = ['L1:OAF-CAL_SUM_DARM_ERR_SWSTAT', 'L1:OAF-CAL_SUM_DARM_L1_SWSTAT', 'L1:OAF-CAL_SUM_DARM_L2_SWSTAT', 'L1:OAF-CAL_SUM_DARM_L3_SWSTAT', 'L1:OAF-CAL_SUM_DARM_M0_SWSTAT']
gain_channel_names = ['L1:OAF-CAL_SUM_DARM_ERR_GAIN', 'L1:OAF-CAL_SUM_DARM_L1_GAIN', 'L1:OAF-CAL_SUM_DARM_L2_GAIN', 'L1:OAF-CAL_SUM_DARM_L3_GAIN', 'L1:OAF-CAL_SUM_DARM_M0_GAIN']

# read frame cache
logging.info('Reading cache file...')
frame_cache = lal.Cache.fromfilenames([opts.frame_cache])
frame_filenames = [entry.path for entry in frame_cache]

# get channel data from frame files
logging.info('Reading frame files...')
data = frame.read_frame(frame_filenames, channel_names,
                            start_time=opts.gps_start_time, end_time=opts.gps_end_time)

# get filter files
logging.info('Reading filter files...')
filter_file = FilterFile(opts.filter_file)

# put data into arrays
darm_err = filter_zpk(data[0], [100]*5, [1]*5, 1e-10)
darm_err = darm_err.numpy()
darm_out = filter_zpk(data[1], [100]*5, [1]*5, 1e-10)
darm_out = darm_out.numpy()

def filter_data(data, frame_filenames, swstat_channel_name, filter_name, start_time, end_time):
    '''
    A naive function to determine if the filter was on at the time
    and then filter the data.

    This module just checks the first time in the SWSTAT channel
    to see if the filter was on, it doesn't check beyond that.

    This is just for a first test on a small chunck of data.

    To read the SWSTAT bits, reference: https://dcc.ligo.org/DocDB/0107/T1300711/001/LIGO-T1300711-v1.pdf

    Bit 0-9 = Filter on/off switches for the 10 filters in an SFM.
    Bit 10 = Filter module input switch on/off
    Bit 11 = Filter module offset switch on/off
    Bit 12 = Filter module output switch on/off
    Bit 13 = Filter module limit switch on/off 
    Bit 14 = Filter module history reset momentary switch
    '''

    # loop over bits that state if the filter was on or off
    swstat = frame.read_frame(frame_filenames, swstat_channel_name,
                      start_time=start_time, end_time=end_time)

    # convert number in channel to binary
    bits = bin(int(swstat[0]))

    # check if filterbank input or output was off
    # if it was then return a TimeSeries of zeroes
    # FIXME: sampling rate is hardcoded
    if len(bits) < 14 or int(bits[-13]) == 0 or int(bits[-11]) == 0:
        sample_rate = 16384
        return numpy.zeros(int(end_time-start_time)*sample_rate) 

    # loop over the 10 filters in the filterbank
    for i in range(10):

        # read the filter
        filter = Filter(filter_file[filter_name][i])

        # if bit is on then filter the data
        bit = int(bits[-(i+1)])
        if bit:

            # if there are second-order sections then filter with them
            if len(filter.sections):
                data = filter.apply(data)

            # else it is a filter with only gain so apply the gain
            else:
                data = float(filter.design.design.rstrip(')').strip('gain(')) * data

    return  data

def read_gain_from_frames(frame_filenames, gain_channel_name, start_time, end_time):
    '''
    Returns the gain from the file.
    '''

    # get timeseries from frame
    gain = frame.read_frame(frame_filenames, gain_channel_name,
                      start_time=start_time, end_time=end_time)

    return gain[0]

# apply filters to DARM error
logging.info('Filtering DARM error...')
darm_err_filtered = filter_data(darm_err, frame_filenames, swstat_channel_names[0], filterbank_names[0],
                                           data[0].start_time, data[0].start_time+data[0].duration)

# apply filters to DARM control
logging.info('Filtering DARM control...')
darm_out_l1_filtered = filter_data(darm_out, frame_filenames, swstat_channel_names[1], filterbank_names[1],
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_l2_filtered = filter_data(darm_out, frame_filenames, swstat_channel_names[2], filterbank_names[2],
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_l3_filtered = filter_data(darm_out, frame_filenames, swstat_channel_names[3], filterbank_names[3],
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_m0_filtered = filter_data(darm_out, frame_filenames, swstat_channel_names[4], filterbank_names[4],
                                           data[0].start_time, data[0].start_time+data[0].duration)

# sum filtered DARM control
logging.info('Summing filtered DARM control...')
gain_l1 = read_gain_from_frames(frame_filenames, gain_channel_names[1], data[0].start_time, data[0].start_time+data[0].duration)
gain_l2 = read_gain_from_frames(frame_filenames, gain_channel_names[2], data[0].start_time, data[0].start_time+data[0].duration)
gain_l3 = read_gain_from_frames(frame_filenames, gain_channel_names[3], data[0].start_time, data[0].start_time+data[0].duration)
gain_m0 = read_gain_from_frames(frame_filenames, gain_channel_names[4], data[0].start_time, data[0].start_time+data[0].duration)
sum_darm_out_filtered = gain_m0*darm_out_m0_filtered + gain_l1*darm_out_l1_filtered + gain_l2*darm_out_l2_filtered + gain_l3*darm_out_l3_filtered

# sum filtered error and filtered control
logging.info('Summing filtered DARM control and filtered error...')
gain_err = read_gain_from_frames(frame_filenames, gain_channel_names[0], data[0].start_time, data[0].start_time+data[0].duration)
sum_darm_filtered = sum_darm_out_filtered + gain_err*darm_err_filtered

# write output
logging.info('Writing data...')
output_data = types.TimeSeries(sum_darm_filtered, delta_t=data[0].delta_t, epoch=data[0].start_time)
output_data.save(opts.output_file)

# exit
logging.info('Done.')
