#! /usr/bin/python

import argparse
import logging
import numpy
import sys
from pycbc.filter.fotonfilter import filter_data, get_swstat_bits, read_gain_from_frames
from pycbc.frame import frame_paths
from pycbc.inject import InjectionSet, legacy_approximant_name
from pycbc.types import TimeSeries
from pycbc.waveform import get_td_waveform

import ROOT
ROOT.gSystem.Load('/usr/lib64/libdmtsigp.so')
ROOT.gSystem.Load('/usr/lib64/libgdsplot.so')
from foton import FilterFile, Filter

# list of IFOs
ifo_list = ['H1', 'L1']

# command line usage
parser = argparse.ArgumentParser(usage='pycbc_hwinj_to_counts [--options]',
             description='Injects a waveform into a time series of zeroes \
                               and filters using a filterbank.')

# injection options
parser.add_argument("--data-file", type=str, required=True,
             help="Path to single-column ASCII file with time series.")
parser.add_argument("--ifo", choices=ifo_list, required=True,
             help="IFO to generate waveform.")

# foton options
parser.add_argument("--filter-file", type=str, required=True,
             help="Path to foton filter file to extract filterbanks.")
parser.add_argument("--model-name", type=str, required=True,
             help="Name of the model.")
parser.add_argument("--filterbank-name", type=str, required=True,
             help="Name of the filterbank to filter time series.")

# frame file options
parser.add_argument("--frame-type", type=str, required=True,
             help="Frame type that has SWSTAT channels.")
parser.add_argument("--gps-start-time", type=int, required=True,
             help="Time to start reading data.")
parser.add_argument("--gps-end-time", type=int, required=True,
             help="Time to stop reading data.")

# output options
parser.add_argument("--output-file", type=str, required=True,
             help="The name of the ASCII output file that contains h(t).")
parser.add_argument("--sample-rate", type=int, required=True,
             help="The sample rate of the ASCII output file that contains h(t).")

# parse command line
opts = parser.parse_args()

# setup log
logging_level = logging.DEBUG
logging.basicConfig(format='%(asctime)s : %(message)s', level=logging_level)

# read data file with time series
data = numpy.loadtxt(opts.data_file)

# read foton filter file
logging.info('Reading foton filter file')
filter_file = FilterFile(opts.filter_file)

# read frame files
logging.info('Querying and reading frame files')
frame_paths = frame_paths(opts.frame_type, opts.gps_start_time, opts.gps_end_time)

# setup filterbank
logging.info('Filtering with %s filterbank', opts.filterbank_name)
swstat_channel_name = '%s:%s-%s_SWSTAT'%(opts.ifo, opts.model_name, opts.filterbank_name)
gain_channel_name = '%s:%s-%s_GAIN'%(opts.ifo, opts.model_name, opts.filterbank_name)

bits = '1000000011'
#bits = '0000000000'
filterbank_off = False

# get bits for filter modules on/off and if filterbank was on/off
#bits, filterbank_off = get_swstat_bits(frame_paths, swstat_channel_name, opts.gps_start_time, opts.gps_start_time+1)
logging.info('Will use bits %s and the input/output was off at this time is %s', bits, filterbank_off)

# filter data
data_filt = filter_data(data, opts.filterbank_name, filter_file, bits, filterbank_off=filterbank_off)

# apply filterbank gain
gain = read_gain_from_frames(frame_paths, gain_channel_name, opts.gps_start_time, opts.gps_start_time+1)
data_filt = gain * data_filt

# write output
logging.info('Writing filtered data')
numpy.savetxt(opts.output_file, data_filt)

# exit
logging.info('Done')
